<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019.05-2019.06 学习总结</title>
    <url>/2019/06/04/project_experience/2019.06/</url>
    <content><![CDATA[<div align='center' ><font size='70'>2019.05-2019.06 学习总结</font></div>
<hr>
<p><span id="toc"></span></p>
<p>[TOC]</p>
<hr>
<h2 id="阶段一：基础知识回顾">阶段一：基础知识回顾</h2>
<h3 id="C语言基础语法回顾：">&gt; C语言基础语法回顾：</h3>
<blockquote>
<p>变更代码习惯，转语言——“倒时差”</p>
</blockquote>
<h4 id="相关留存资料：">&gt; 相关留存资料：</h4>
<div class="pdf-container" data-target="https://drive.google.com/file/d/1644m_lW65hk8UBkXqBdFv61zy-y17bBq/preview" data-height="500px"></div>
<span id="more"></span>
<h3 id="计算机网络基础知识回顾：">&gt; 计算机网络基础知识回顾：</h3>
<blockquote>
<p>回顾计算机网络结构，重点回顾计算网络网络层传输层应用层的工作相关知识，并进行总结。</p>
</blockquote>
<h4 id="相关留存资料：-2">&gt; 相关留存资料：</h4>
<div class="pdf-container" data-target="https://drive.google.com/file/d/1MMx2EWgg-tMt0YcJeQkaBbQkAXvVYVJT/preview" data-height="500px"></div>
<h3 id="Unix环境高级编程：">&gt; Unix环境高级编程：</h3>
<blockquote>
<p>学习网络编程，Linux环境下C语言编程，学习Socket编程相关知识。</p>
</blockquote>
<h4 id="相关留存资料：-3">&gt; 相关留存资料：</h4>
<blockquote>
<p>Github Repository：    <a href="https://github.com/liuxing1Tec/C_Learning/tree/master/SOCKET%E7%BC%96%E7%A8%8B"><strong>C_Learning/SOCKET编程</strong></a></p>
</blockquote>
<h2 id="阶段二：网络编程实战">阶段二：网络编程实战</h2>
<h3 id="网络聊天客户端的开发：">&gt; 网络聊天客户端的开发：</h3>
<blockquote>
<p>Socket编程实战。</p>
</blockquote>
<h4 id="相关留存资料：-4">&gt; 相关留存资料：</h4>
<blockquote>
<p>Github Repository：    <a href="https://github.com/liuxing1Tec/Unix_chatroom"><strong>Unix_chatroom</strong></a></p>
</blockquote>
<h3 id="网络开发复盘：">&gt; 网络开发复盘：</h3>
<blockquote>
<p>开发流程总结。</p>
</blockquote>
<h4 id="相关留存资料：-5">&gt; 相关留存资料：</h4>
<blockquote>
<p>客户端开发流程以源文件：    <a href="https://github.com/liuxing1Tec/C_Learning/blob/master/SOCKET%E7%BC%96%E7%A8%8B/select_echo/src/echocli.c"><strong>SOCKET编程/select_echo/src/echocli.c</strong></a>，为例<br>
服务器端开发流程以源文件：    <a href="https://github.com/liuxing1Tec/C_Learning/blob/master/SOCKET%E7%BC%96%E7%A8%8B/select_echo/src/echosrv.c"><strong>SOCKET编程/select_echo/src/echosrv.c</strong></a>，为例</p>
</blockquote>
<h2 id="阶段三：补充性学习：查漏补缺">阶段三：补充性学习：查漏补缺</h2>
<h3 id="C语言深入学习：">&gt; C语言深入学习：</h3>
<blockquote>
<p>C语言底层知识总结（堆栈、结构体、作用域、malloc()以及free()机制等）。</p>
</blockquote>
<h4 id="相关留存资料：-6">&gt; 相关留存资料：</h4>
<div class="pdf-container" data-target="https://drive.google.com/file/d/1hC78fv6IeNWt6U2EEI7muiUL-xUUW58c/preview" data-height="500px"></div>
<h3 id="项目开发流程深入学习：">&gt; 项目开发流程深入学习：</h3>
<blockquote>
<p>项目开发流程总结（C项目管理、GCC、GDB等）。</p>
</blockquote>
<h4 id="相关留存资料：-7">&gt; 相关留存资料：</h4>
<div class="pdf-container" data-target="https://drive.google.com/file/d/1HWIYnT_FpXFvE0wjUFZTvritoOo9IJVY/preview" data-height="500px"></div>
<h3 id="AC-AP网络知识学习：">&gt; AC/AP网络知识学习：</h3>
<blockquote>
<p>AC/AP相关知识了解。</p>
</blockquote>
<h4 id="相关留存资料：-8">&gt; 相关留存资料：</h4>
<div class="pdf-container" data-target="https://drive.google.com/file/d/1ClhF03htEg2MFs4S_tFv6znQeFdad3fA/preview" data-height="500px"></div>
]]></content>
      <categories>
        <category>项目经历</category>
      </categories>
  </entry>
  <entry>
    <title>2020.07-2020.09 学习总结</title>
    <url>/2020/10/01/project_experience/2020.10/</url>
    <content><![CDATA[<div align='center' ><font size='70'>2020.07-2020.09 学习总结</font></div>
<hr>
<p><span id="toc"></span></p>
<p>[TOC]</p>
<hr>
<h1>C++</h1>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<h2 id="C-基于容器（docker）的开发环境配置">C++ 基于容器（docker）的开发环境配置</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<h3 id="配置ODBC">配置ODBC</h3>
<p>在<strong>安装</strong>配置之前，需要先大概了解一下 MyODBC 的架构，MyODBC 体系结构建立在 5 个组件上，如下图所示：<br>
<img src="http://pic.colliexyy.com/16566671925562.jpg" alt=""></p>
 <span id="more"></span>
<p><strong>Driver Manager</strong><br>
负责管理应用程序和驱动程序间的通信，主要功能包括：解析 DSN (数据源名称，ODBC 的数据源名称在 odbc.ini 文件中配置)，加载和卸载驱动程序，处理 ODBC 调用，将其传递给驱动程序。</p>
<p><strong>ODBC.INI</strong><br>
odbc.ini 是 ODBC 配置文件，记录了连接到服务器所需的驱动信息和数据库信息。Driver Manager 将使用它来确定加载哪个驱动程序（使用数据源名 DSN ）。驱动程序将根据指定的DSN来读取连接参数。</p>
<p><strong>Connector/ODBC(MyODBC驱动程序)</strong><br>
实现 ODBC API 所提供的功能，它负责处理 ODBC 函数调用，将 SQL 请求提交给 MySQL 服务器，并将结果返回给应用程序。</p>
<p>在 Linux 下配置 mysql ODBC 需要有以下步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 安装 Driver Manager，本案例使用 unixODBC 来作为 Driver Manager。</span><br><span class="line">2. 安装 MySQL 驱动程序，本案例使用 Connector/ODBC。</span><br><span class="line">3. 配置 ODBC.INI</span><br></pre></td></tr></table></figure>
<p><strong>第一步：下载安装包</strong></p>
<p>需要下载两个安装包 <code>unixODBC 2.3.0</code> 和 <code>mysql Connector/ODBC 3.51</code><br>
unixODBC 源码包：<code>ftp://ftp.unixodbc.org/pub/unixODBC/unixODBC-2.3.0.tar.gz</code><br>
mysql Connector/ODBC 源码包：<code>http://dev.mysql.com/downloads/connector/odbc/3.51.html%23downloads</code><br>
选择</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">版本：5.1.11</span><br><span class="line">平台：Oracle&amp;Red Hat Linux6</span><br><span class="line">下载：mysql-connector-odbc-5.1.11-linux-el6-x86-64bit.tar.gz</span><br></pre></td></tr></table></figure>
<p><strong>第二步：安装 unixODBC</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf unixODBC-2.3.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> unixODBC-2.3.4</span><br><span class="line">./configure --prefix=/usr/local/unixODBC-2.3.4 --includedir=/usr/include --libdir=/usr/local/lib -bindir=/usr/bin --sysconfdir=/usr/local/etc</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装完成后,可以在/usr/bin目录下有下面的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root      75312 Nov 1 16:22 odbcinst</span><br><span class="line">-rwxr-xr-x 1 root root      10922 Nov 1 16:22 odbc_config</span><br><span class="line">-rwxr-xr-x 1 root root      37650 Nov 1 16:22 iusql</span><br><span class="line">-rwxr-xr-x 1 root root      44400 Nov 1 16:22 isql</span><br><span class="line">-rwxr-xr-x 1 root root      95903 Nov 1 16:22 dltest</span><br></pre></td></tr></table></figure>
<p>在/usr/local/lib目录下面有这些文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root 422955 Nov 1 16:22 libodbcinst.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     20 Nov 1 16:22 libodbcinst.so.1 -&gt; libodbcinst.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     20 Nov 1 16:22 libodbcinst.so -&gt; libodbcinst.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    981 Nov 1 16:22 libodbcinst.la</span><br><span class="line">-rwxr-xr-x 1 root root 169157 Nov 1 16:22 libodbc.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Nov 1 16:22 libodbc.so.1 -&gt; libodbc.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Nov 1 16:22 libodbc.so -&gt; libodbc.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    957 Nov 1 16:22 libodbc.la</span><br><span class="line">-rwxr-xr-x 1 root root 489405 Nov 1 16:22 libodbccr.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     18 Nov 1 16:22 libodbccr.so.1 -&gt; libodbccr.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     18 Nov 1 16:22 libodbccr.so -&gt; libodbccr.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    969 Nov 1 16:22 libodbccr.la</span><br></pre></td></tr></table></figure>
<p><strong>第三步：安装 mysql Connector/ODBC</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf mysql-connector-odbc-5.1.11-linux-el6-x86-64bit.tar.gz</span><br><span class="line"><span class="built_in">cd</span> mysql-connector-odbc-5.1.11-linux-el6-x86-64bit/lib</span><br><span class="line"><span class="built_in">cp</span> libmyodbc5.so /usr/local/lib</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> bin</span><br></pre></td></tr></table></figure>
<p><strong>注册驱动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./myodbc-installer -d -a -n <span class="string">&quot;MySQL ODBC 5.1 Driver&quot;</span> -t <span class="string">&quot;DRIVER=/usr/local/lib/libmyodbc5.so;SETUP=/usr/local/lib/libmyodbc5.so&quot;</span></span><br><span class="line"></span><br><span class="line">//odbc 5.3及以上是libmyodbc5a.so和libmyodbc5w.so。其中c5a是Ansi版，c5w是Unicode版</span><br></pre></td></tr></table></figure>
<p>假如注册的时候报错找不到libodbc.so.2,但是之前确实装成功了unixodbc,可能是因为系统找不到/usr/local/lib库目录，需要添加系统搜索库目录路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line">//将/usr/local/lib直接添加在配置文件里</span><br><span class="line"></span><br><span class="line">ldconfig</span><br><span class="line"></span><br><span class="line">//重新缓存配置文件(为了加快程序执行时对共享库的定位速度，避免使用搜索路径查找共享库的低效率，所以是直接读取库列表文件/etc/ld.so.cache缓存文件并从中进行搜索的)</span><br></pre></td></tr></table></figure>
<p><strong>第四步：配置 ODBC.INI</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">odbcinst -j</span><br><span class="line"></span><br><span class="line">unixODBC 2.3.1</span><br><span class="line">DRIVERS............: /etc/odbcinst.ini</span><br><span class="line">SYSTEM DATA SOURCES: /etc/odbc.ini</span><br><span class="line">FILE DATA SOURCES..: /etc/ODBCDataSources</span><br><span class="line">USER DATA SOURCES..: /root/.odbc.ini</span><br><span class="line">SQLULEN Size.......: 8</span><br><span class="line">SQLLEN Size........: 8</span><br><span class="line">SQLSETPOSIROW Size.: 8</span><br></pre></td></tr></table></figure>
<p>编辑文件<code>/etc/odbc.ini</code>，把下面的内容加上去。不同版本<code>mysql</code>驱动的配置方法，有细微差异。此处使用的版本是<code>mysql Connector 3.51</code>。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqlDSN]</span></span><br><span class="line"><span class="attr">Driver</span>      = /usr/local/lib/libmyodbc5.so</span><br><span class="line"><span class="attr">Description</span> = MyODBC <span class="number">5</span> Driver DSN</span><br><span class="line"><span class="attr">SERVER</span>      = <span class="number">172.31</span>.<span class="number">108.133</span></span><br><span class="line"><span class="attr">PORT</span>        = <span class="number">3306</span></span><br><span class="line"><span class="attr">USER</span>        = root</span><br><span class="line"><span class="attr">Password</span>    = <span class="number">123456</span></span><br><span class="line"><span class="attr">Database</span>    = PM</span><br><span class="line"><span class="attr">OPTION</span>      = <span class="number">3</span></span><br><span class="line"><span class="attr">charset</span>     = UTF8</span><br></pre></td></tr></table></figure>
<p><strong>第五步：设置环境变量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DBCINI=/usr/local/etc/odbc.ini</span><br><span class="line"><span class="built_in">export</span> DBCSYSINI=/usr/local/etc</span><br></pre></td></tr></table></figure>
<p><strong>第六步：重启电脑</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p><strong>第七步：测试ODBC配置是否成功</strong><br>
isql 是 unixODBC 带的一个 ODBC 客户端访问工具，使用<code>isql +数据源名</code>来访问目标数据库。如果 ODBC 配置正确，会显示下面的界面。在<code>SQL&gt;</code>提示符下输入 SQL 语句查询数据库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">isql mysqlDSN</span><br><span class="line"></span><br><span class="line">+---------------------------------------+</span><br><span class="line">| Connected!                           |</span><br><span class="line">|                                      |</span><br><span class="line">| sql-statement                        |</span><br><span class="line">| <span class="built_in">help</span> [tablename]                     |</span><br><span class="line">| quit                                 |</span><br><span class="line">|                                      |</span><br><span class="line">+---------------------------------------+</span><br></pre></td></tr></table></figure>
<p><strong>遇到的问题：</strong></p>
<ul>
<li>问题1<br>
在第三步安装 mysql connector/ODBC 中的注册驱动中，我总是会出现<code>./myodbc-installer: error while loading shared libraries: libodbc.so.2: cannot open shared object file: No such file or directory.</code>这种错误，后来发现错误有两点：
<ol>
<li>我下载的是 mysql-connector-5.3.6 ，可能版本比较高，而我初次下载用的是unixODBC-2.3.0，版本较低，里面没有 libodbc.so.2 这个库文件（可以用<code>find / -name libodbc.so.2</code>来查）。后来下载了一个 unixODBC-2.3.4 就好了。</li>
<li>改了版本之后，我发现还是有这个错误，在网上查了下，说是程序查找默认路径为 /lib 和 /usr/lib，而我的 <a href="http://libmyodbc5w.so">libmyodbc5w.so</a> 和 <a href="http://libmmyodbc5a.so">libmmyodbc5a.so</a> 都在 /usr/local/lib 中，所以查不到，所以需要设置一下共享库路径，以下我贴一下网上查的内容：</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/ld.so.conf</span><br><span class="line">include ld.so.conf.d/*.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/usr/local/lib&quot;</span> &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>
<ul>
<li>问题2<br>
如果共享库文件安装到了其它非<code>/lib</code>或<code>/usr/lib</code>目录下，但是又不想在<code>/etc/ld.so.conf</code>中加路径(或者是没有权限加路径)。那可以 export 一个全局变量<code>LD_LIBRARY_PATH</code>，然后运行程序的时候就会去这个目录中找共享库。<code>LD_LIBRARY_PATH</code>的意思是告诉 loader 在哪些目录中可以找到共享库。<br>
可以设置多个搜索目录，这些目录之间用冒号分隔开。<br>
比如：<br>
安装了一个 mysql 到<code>/usr/local/mysql</code>目录下，其中有一大堆库文件在<code>/usr/local/mysql/lib</code>下面，则可以在 .bashrc 或 .bash_profile 或 shell 里加入以下语句即可：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=/usr/local/mysql/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>
<p>一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。</p>
<ul>
<li>问题3<br>
如果程序需要的库文件比系统目前存在的村文件版本低，可以做一个链接<br>
比如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error while loading shared libraries: libncurses.so.4: cannot open shared</span><br><span class="line">object file: No such file or directory</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /usr/lib/libncu*</span><br><span class="line">/usr/lib/libncurses.a   /usr/lib/libncurses.so.5</span><br><span class="line">/usr/lib/libncurses.so  /usr/lib/libncurses.so.5.3</span><br></pre></td></tr></table></figure>
<p>可见虽然没有 libncurses.so.4，但有 libncurses.so.5，是可以向下兼容的<br>
建一个链接就好了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s  /usr/lib/libncurses.so.5.3  /usr/lib/libncurses.so.4</span><br></pre></td></tr></table></figure>
<ul>
<li>问题4<br>
isql 连接数据库失败，重新注册驱动：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/myodbc-installer  -d -a -n <span class="string">&quot;MySQL_UNICODE&quot;</span>  -t <span class="string">&quot;DRIVER=/usr/lib64/libmyodbc8w.so;SETUP=/usr/lib64/libmyodbc8w.so&quot;</span></span><br><span class="line">/usr/bin/myodbc-installer  -d -a -n <span class="string">&quot;MySQL_ANSI&quot;</span>  -t <span class="string">&quot;DRIVER=/usr/lib64/libmyodbc8a.so;SETUP=/usr/lib64/libmyodbc8a.so&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用 rpm 命令查看 rpm 包的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qpl xxx.rpm</span><br></pre></td></tr></table></figure>
<p>可以看到<code>mysql-connector-odbc-8.0.20-1.el7.x86_64.rpm</code>的包内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">warning: mysql-connector-odbc-8.0.20-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">/usr/bin/myodbc-installer</span><br><span class="line">/usr/lib64/libmyodbc8a.so</span><br><span class="line">/usr/lib64/libmyodbc8w.so</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/ChangeLog</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/INFO_BIN</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/INFO_SRC</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/LICENSE.txt</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/README.txt</span><br></pre></td></tr></table></figure>
<p>可以知道 rpm 包 安装的时候各个基础件的安装位置。</p>
<h3 id="NGINX-的配置与基础命令">NGINX 的配置与基础命令</h3>
<p><strong>nginx 配置</strong></p>
<p><strong>查看 nginx 配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/nginx/nginx.conf</span><br><span class="line"><span class="built_in">cat</span> /etc/nginx/conf.d/xxxxxxxx.conf</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>stdname</code> 对应的监听端口设置 nginx 监听 18026 并转发至 stdnameSvr 的 监听端口 19026。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       18026;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location /stdname/  &#123;</span><br><span class="line">                fastcgi_pass   127.0.0.1:19026;</span><br><span class="line">                fastcgi_index index.cgi;</span><br><span class="line">                #fastcgi_param SCRIPT_FILENAME fcgi$fastcgi_script_name;</span><br><span class="line">                include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</br>
<p><strong>验证 nginx 配置文件是否正确</strong></p>
<p>进入 nginx 安装目录 sbin 下，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./nginx -t</span><br></pre></td></tr></table></figure>
<p>看到如下显示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx: the configuration file /.../nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /.../nginx.conf <span class="built_in">test</span> is successful</span><br></pre></td></tr></table></figure>
<p>说明配置文件正确！</p>
<p><strong>运行 nginx</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/path_of_nginx/nginx -c /path_of_nginx.conf/nginx.conf</span><br></pre></td></tr></table></figure>
<p><code>-c</code>：指定 nginx 运行时使用的 conf 文件路径<br>
<code>-t</code>：加上<code>-t</code>可以测试 nginx 配置是否正确</p>
<p><strong>停止 nginx</strong></p>
<p>查看进程号然后杀死进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br><span class="line"><span class="built_in">kill</span> -QUIT &lt;pid_of_nginx&gt;   //从容停止</span><br><span class="line"><span class="built_in">kill</span> -TERM &lt;pid_of_nginx&gt;   //快速停止</span><br><span class="line"><span class="built_in">kill</span> -INT &lt;pid_of_nginx&gt;    //快速停止</span><br><span class="line"><span class="built_in">kill</span> -9 nginx               //强制停止</span><br></pre></td></tr></table></figure>
<p><strong>重启 nginx</strong></p>
<p><strong>方法一：</strong><br>
找到 nginx 可执行文件路径，然后输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
</br>
<p><strong>方法二：</strong><br>
查找当前 nginx 进程号，然后输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;pid_of_nginx&gt;</span><br></pre></td></tr></table></figure>
<p>实现重启 nginx 服务。</p>
<h3 id="Docker-端口映射">Docker 端口映射</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 8080:18026 &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>
<p><code>-p</code>：是容器内部端口绑定到指定的主机端口。这里指将主机的8080端口映射到容器的18026端口。</p>
</br>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 127.0.0.1:8080:18026 &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>
<p>这样我们就可以通过访问 127.0.0.1:8080 来访问容器的 18026 端口。</p>
</br>
<p>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 /udp。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 127.0.0.1:8080:18026/udp &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>
</br>
<p><code>docker port &lt;CONTAINER ID&gt; &lt;PORT&gt;</code>命令可以让我们快捷地查看端口的绑定情况。</p>
<h3 id="启动微服务">启动微服务</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recurse-submodules https://gitlab.xxxxxxxx.net/.../*.git</span><br><span class="line">//带这个参数，才会把 public 下载到子目录里面去</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /path_of_project/</span><br><span class="line"></span><br><span class="line">sh build.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> bin/root_of_work_dir/</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> VEHICLE_DATA_CONFIG=/root_of_work_dir/vehicle/config/config.xml</span><br><span class="line">//代码中有对 VEHICLE_DATA_CONFIG 的宏定义，修改为本地路径</span><br><span class="line"></span><br><span class="line">spawn_fcgi -a 127.0.0.1 -p 19026 -C 25 -U nginx -f stdnameSvr -F 1</span><br><span class="line">//运行 stdnameSvr 服务</span><br><span class="line"></span><br><span class="line">netstat -ntpl</span><br><span class="line">//查看 nginx 和 stdnameSvr 服务是否均已开启</span><br></pre></td></tr></table></figure>
<p>**注释：**<strong>spawn-fcgi 用法了解</strong></p>
<p>spawn-fcgi 是一个小程序，作用是管理 fast-cgi 进程。</p>
<p>用 spawn 启动 FCGI 程序的方式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./spawn-fcgi -a 127.0.0.1 -p 8080 -F <span class="variable">$&#123;count&#125;</span> -f <span class="variable">$&#123;webroot&#125;</span>/bin/demo.fcgi</span><br></pre></td></tr></table></figure>
<p>这样就会启动 count 个 demo.fcgi 程序，他们共同监听同一个 listen 端口 8080，从而提供服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./spawn_fcgi -h</span><br><span class="line">Usage: spawn-fcgi [options] [-- &lt;fcgiapp&gt; [fcgi app arguments]]</span><br><span class="line"></span><br><span class="line">spawn-fcgi v1.6.5 - spawns FastCGI processes</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -f &lt;path&gt;      filename of the fcgi-application (deprecated; ignored <span class="keyword">if</span></span><br><span class="line">                &lt;fcgiapp&gt; is given; needs /bin/sh)</span><br><span class="line"> -d &lt;directory&gt; <span class="built_in">chdir</span> to directory before spawning</span><br><span class="line"> -a &lt;address&gt;   <span class="built_in">bind</span> to IPv4/IPv6 address (defaults to 0.0.0.0)</span><br><span class="line"> -p &lt;port&gt;      <span class="built_in">bind</span> to TCP-port</span><br><span class="line"> -s &lt;path&gt;      <span class="built_in">bind</span> to Unix domain socket</span><br><span class="line"> -M &lt;mode&gt;      change Unix domain socket mode (octal <span class="built_in">integer</span>, default: allow</span><br><span class="line">                <span class="built_in">read</span>+write <span class="keyword">for</span> user and group as far as <span class="built_in">umask</span> allows it)</span><br><span class="line"> -C &lt;children&gt;  (PHP only) numbers of childs to spawn (default: not setting</span><br><span class="line">                the PHP_FCGI_CHILDREN environment variable - PHP defaults to 0)</span><br><span class="line"> -F &lt;children&gt;  number of children to fork (default 1)</span><br><span class="line"> -b &lt;backlog&gt;   backlog to allow on the socket (default 1024)</span><br><span class="line"> -P &lt;path&gt;      name of PID-file <span class="keyword">for</span> spawned process (ignored <span class="keyword">in</span> no-fork mode)</span><br><span class="line"> -n             no fork (<span class="keyword">for</span> daemontools)</span><br><span class="line"> -v             show version</span><br><span class="line"> -?, -h         show this <span class="built_in">help</span></span><br><span class="line">(root only)</span><br><span class="line"> -c &lt;directory&gt; <span class="built_in">chroot</span> to directory</span><br><span class="line"> -S             create socket before <span class="built_in">chroot</span>() (default is to create the socket</span><br><span class="line">                <span class="keyword">in</span> the <span class="built_in">chroot</span>)</span><br><span class="line"> -u &lt;user&gt;      change to user-id</span><br><span class="line"> -g &lt;group&gt;     change to group-id (default: primary group of user <span class="keyword">if</span> -u</span><br><span class="line">                is given)</span><br><span class="line"> -U &lt;user&gt;      change Unix domain socket owner to user-id</span><br><span class="line"> -G &lt;group&gt;     change Unix domain socket group to group-id</span><br></pre></td></tr></table></figure>
<h2 id="C-OTL-流处理包">C++ OTL 流处理包</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
otl的源码只有一个头文件——otlv4.h。下面以一个例子来说明如何使用otl。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;otlv4.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OTL_ORA10G</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CAboutDlg::OnBnClickedOk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">    otl_connect OracleDb;  <span class="comment">// 定义一个oracle数据库的连接对象</span></span><br><span class="line"></span><br><span class="line">    OracleDb.<span class="built_in">otl_initialize</span>(TRUE);<span class="comment">// 以线程安全模式初始化OCI环境 </span></span><br><span class="line"></span><br><span class="line">    std::string szConnectString = _T(<span class="string">&quot;system/zjc@ORCL&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 连接数据库</span></span><br><span class="line">        OracleDb.<span class="built_in">rlogon</span>(szConnectString.<span class="built_in">c_str</span>(), <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 查询数据库中所有用户</span></span><br><span class="line">        std::string strSql = _T(<span class="string">&quot;SELECT username FROM dba_users&quot;</span>);</span><br><span class="line">        <span class="function">otl_stream <span class="title">i</span><span class="params">(<span class="number">1024</span>, <span class="comment">// buffer size  </span></span></span></span><br><span class="line"><span class="params"><span class="function">                     strSql.c_str(),</span></span></span><br><span class="line"><span class="params"><span class="function">                     OracleDb <span class="comment">// connect object  </span></span></span></span><br><span class="line"><span class="params"><span class="function">                    )</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> nNumUser = <span class="number">0</span>;</span><br><span class="line">        TCHAR szNum[<span class="number">64</span>];</span><br><span class="line">        <span class="keyword">while</span> (!i.<span class="built_in">eof</span>())<span class="comment">// while not end-of-data  </span></span><br><span class="line">        &#123;</span><br><span class="line">            i &gt;&gt; szNum; <span class="comment">//获取单个用户名</span></span><br><span class="line">            nNumUser++;</span><br><span class="line">        &#125;</span><br><span class="line">        CString strNum;</span><br><span class="line">        strNum.<span class="built_in">Format</span>((<span class="string">&quot;当前oracle数据库用户个数为：%d&quot;</span>), nNumUser);</span><br><span class="line">        <span class="built_in">AfxMessageBox</span>(strNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (otl_exception &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TRACE</span>(_T(<span class="string">&quot;Oracle connecterror(msg:%s, stm_text: %s, sqlstate: %s, var_info: %s)&quot;</span>), p.msg, p.stm_text,</span><br><span class="line">              p.sqlstate, p.var_info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OnOK</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码例子连接<code>Oracle</code>数据库用到了<code>rlogon()</code>函数，调用它时需要为它提供一个连接字符串，一般是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[User Name]/[Password]@[TNS Alias]</span><br></pre></td></tr></table></figure>
<p>这里的<code>TNS Alias</code>指在<code>tnsnames.ora</code>中配置<code>TNS</code>名，比如我的<code>tnsnames.ora</code>里有以下的配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tnsnames.ora Network Configuration File: D:\oracle\product\10.2.0\db_1\network\admin\tnsnames.ora</span></span><br><span class="line"><span class="comment"># Generated by Oracle configuration tools.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORCL =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS = (PROTOCOL = TCP)(HOST = zjc)(PORT = 1521))</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SERVER = DEDICATED)</span><br><span class="line">      (SERVICE_NAME = orcl)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">EXTPROC_CONNECTION_DATA =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS_LIST =</span><br><span class="line">      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SID = PLSExtProc)</span><br><span class="line">      (PRESENTATION = RO)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>那么<code>TNS Alias</code>就是<code>ORCL</code>。</p>
<p>此外需要注意的是使用<code>otl</code>连接<code>oracle</code>数据库需要链接<code>oci.lib</code>，也就是说需要包含它的头文件和库文件路径。</p>
<h2 id="Vector-遍历的几种方法">Vector 遍历的几种方法</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<blockquote>
<p><code>vector&lt;int&gt; v1&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10&#125;;</code></p>
</blockquote>
<h3 id="一、通过数组下标遍历">一、通过数组下标遍历</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="二、通过迭代器遍历">二、通过迭代器遍历</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = v1.<span class="built_in">begin</span>(); iter != v1.<span class="built_in">end</span>(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="三、C-11标准，auto关键字遍历">三、C++11标准，auto关键字遍历</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = v1.<span class="built_in">begin</span>(); iter != v1.<span class="built_in">end</span>(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v1)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="四、for-each加函数">四、for_each加函数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printer</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    for_each(v1.<span class="built_in">cbegin</span>(), v1.<span class="built_in">cend</span>(), printer&lt;<span class="type">int</span>&gt;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h2 id="C-计时方法——chrono">C++ 计时方法——chrono</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
<strong>传统计时方法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> start = <span class="built_in">clock</span>();</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line"><span class="type">clock_t</span> end   = <span class="built_in">clock</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;花费了&quot;</span> &lt;&lt; (<span class="type">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;秒&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>此方法可以精确到毫秒，输出样例：<strong>花费了0.123秒</strong></p>
<p><strong>C++11 最佳计时方法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>   </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> start = system_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line"><span class="keyword">auto</span> end   = system_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> duration = <span class="built_in">duration_cast</span>&lt;microseconds&gt;(end - start);</span><br><span class="line">cout &lt;&lt;  <span class="string">&quot;花费了&quot;</span> &lt;&lt; <span class="built_in">double</span>(duration.<span class="built_in">count</span>()) * microseconds::period::num / microseconds::period::den &lt;&lt; <span class="string">&quot;秒&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//duration_cast&lt; &gt; 表示类型转换</span></span><br><span class="line"><span class="comment">//microseconds 表示微妙。除此之外，还有五种时间单位：hours, minutes, seconds, milliseconds, nanoseconds</span></span><br><span class="line"><span class="comment">//num 和 den分别表示分子(numerator)和分母(denominator)。在我给出的代码中，num等于1， den等于1,000,000</span></span><br><span class="line"><span class="comment">//count( ) 用来返回时间</span></span><br></pre></td></tr></table></figure>
<h2 id="其他开发过程中可能会遇到的坑">其他开发过程中可能会遇到的坑</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">virtual</span> <span class="type">const</span> <span class="keyword">override</span> <span class="keyword">explicit</span> <span class="keyword">extern</span></span><br></pre></td></tr></table></figure>
<ul>
<li>以上限定词的作用以及继承关系的嵌套需要更加明晰，很容易被这些限定词把逻辑弄乱。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CurlCXX <span class="title">curl</span><span class="params">(url, <span class="number">1</span>)</span></span>; <span class="comment">//1s timeout</span></span><br><span class="line">curl.<span class="built_in">post</span>(body);</span><br></pre></td></tr></table></figure>
<ul>
<li>注意学会<code>curl</code>发包的用法，并且<code>post</code>时，<code>body</code>当中要注意<code>fastcgi</code>框架当中约定了<code>post</code>数据格式为<code>x-www-form-urlencoded/form-data</code>，因此一定要注意<code>body</code>里面的数据，单个字段内不能出现容易导致解析错误的<code>'&amp;'</code>字符，若不得不包含<code>'&amp;'</code>字符，则要用转义字符<code>'\&amp;'</code>包起来，否则会导致参数错误。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> CallRecord *app;</span><br><span class="line">app = <span class="built_in">app_ptr</span>();</span><br><span class="line"><span class="built_in">const_cast</span>&lt;CallRecord *&gt;(app)-&gt;<span class="built_in">reload_cache</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>注意对<code>const</code>类型的对象操作时，需要用<code>const_cast&lt;XXXXXX&gt;</code>对该对象进行强制类型转换。</li>
</ul>
<h1>MySQL</h1>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<h2 id="SQL-SELECT-DISTINCT-语句">SQL SELECT DISTINCT 语句</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。DISTINCT 关键词用于返回唯一不同的值。</p>
<p><strong>SQL SELECT DISTINCT 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<!---more--->
<h2 id="SQL-UPDATE-语句">SQL UPDATE 语句</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
UPDATE 语句用于更新表中已存在的记录。</p>
<p><strong>SQL UPDATE 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1<span class="operator">=</span>value1,column2<span class="operator">=</span>value2,...</span><br><span class="line"><span class="keyword">WHERE</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure>
<p><strong>请注意</strong> : SQL UPDATE 语句中的 WHERE 子句！WHERE 子句规定哪条记录或者哪些记录需要更新。如果您省略了 WHERE 子句，所有的记录都将被更新！</p>
<h2 id="SQL-DELETE-语句">SQL DELETE 语句</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
DELETE 语句用于删除表中的行(记录)。</p>
<p><strong>SQL DELETE 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure>
<p><strong>请注意</strong> : SQL DELETE 语句中的 WHERE 子句！WHERE 子句规定哪条记录或者哪些记录需要删除。如果您省略了 WHERE 子句，所有的记录都将被删除！</p>
<h2 id="SQL-REGEXP-语句">SQL REGEXP 语句</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
作为一个更为复杂的示例，正则表达式 <code>B[an]*s</code> 匹配下述字符串中的任何一个：<code>Bananas，Baaaaas，Bs</code>，以及以 B 开始，以 s 结束、并在其中包含任意数目 a 或 n 字符的任何其他字符串。</p>
<p>以下是可用于随 REGEXP 操作符的表的模式。</p>
<p><img src="http://pic.colliexyy.com/16566671925579.jpg" alt=""></p>
<p>应用示例，查找用户表中 Email 格式错误的用户记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">NOT</span> REGEXP <span class="string">&#x27;^[A-Z0-9._%-]+@[A-Z0-9.-]+.[A-Z]&#123;2,4&#125;$&#x27;</span></span><br></pre></td></tr></table></figure>
<p>MySQL 数据库中正则表达式的语法，主要包括各种符号的含义。</p>
<p><strong>^ 字符</strong></p>
<p>匹配字符串的开始位置，如 <code>^a</code> 表示以字母 a 开头的字符串。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="string">&#x27;xxxyyy&#x27;</span> REGEXP <span class="string">&#x27;^xx&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="string">&#x27;xxxyyy&#x27;</span> REGEXP <span class="string">&#x27;^xx&#x27;</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+</span></span><br><span class="line"><span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>查询 xxxyyy 字符串中是否以 xx 开头，结果值为 1，表示值为 true，满足条件。</p>
<p><strong>$ 字符</strong></p>
<p>匹配字符串的结束位置，如 <code>X$</code> 表示以字母 X 结尾的字符串。</p>
<p><strong>. 字符</strong></p>
<p>这个字符就是英文下的点，它匹配任何一个字符，包括回车、换行等。</p>
<p><strong>* 字符</strong></p>
<p>星号匹配 0 个或多个字符，在它之前必须有内容。如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="string">&#x27;xxxyyy&#x27;</span> REGEXP <span class="string">&#x27;x*&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这个 SQL 语句，正则匹配为 true。</p>
<p><strong>+ 字符</strong></p>
<p>加号匹配 1 个或多个字符，在它之前也必须有内容。加号跟星号的用法类似，只是星号允许出现 0 次，加号则必须至少出现一次。</p>
<p><strong>? 字符</strong></p>
<p>问号匹配 0 次或 1 次。</p>
<p><strong>实例:</strong><br>
查询找到所有的名字以 st 开头：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> person_tbl <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;^st&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询找到所有的名字以 ok 结尾：</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> person_tbl <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;ok$&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询找到所有的名字包函 mar 的字符串：</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> person_tbl <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;mar&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询找到所有名称以元音开始和 ok 结束的：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> person_tbl <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;^[aeiou]|ok$&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>一个正则表达式中的可以使用以下保留字。</p>
<p><strong>^</strong><br>
所匹配的字符串以后面的字符串开头：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;fonfo&quot; REGEXP &quot;^fo$&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span>（表示不匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;fofo&quot; REGEXP &quot;^fo&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配）</span><br></pre></td></tr></table></figure>
<p><strong>$</strong><br>
所匹配的字符串以前面的字符串结尾：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;fono&quot; REGEXP &quot;^fono$&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;fono&quot; REGEXP &quot;^fo$&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span>（表示不匹配） </span><br></pre></td></tr></table></figure>
<p><strong>.</strong><br>
匹配任何字符（包括新行）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;fofo&quot; REGEXP &quot;^f.*&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;fonfo&quot; REGEXP &quot;^f.*&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配）</span><br></pre></td></tr></table></figure>
<p><strong>a</strong>*<br>
匹配任意多个 a（包括空串)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;Ban&quot; REGEXP &quot;^Ba*n&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;Baaan&quot; REGEXP &quot;^Ba*n&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;Bn&quot; REGEXP &quot;^Ba*n&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配）</span><br></pre></td></tr></table></figure>
<p><strong>a+</strong><br>
匹配任意多个 a（不包括空串)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;Ban&quot; REGEXP &quot;^Ba+n&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;Bn&quot; REGEXP &quot;^Ba+n&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span>（表示不匹配）</span><br></pre></td></tr></table></figure>
<p><strong>a?</strong><br>
匹配一个或零个 a：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;Bn&quot; REGEXP &quot;^Ba?n&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;Ban&quot; REGEXP &quot;^Ba?n&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;Baan&quot; REGEXP &quot;^Ba?n&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span>（表示不匹配）</span><br></pre></td></tr></table></figure>
<p><strong>de|abc</strong><br>
匹配 de 或 abc：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;pi&quot; REGEXP &quot;pi|apa&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;axe&quot; REGEXP &quot;pi|apa&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span>（表示不匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;apa&quot; REGEXP &quot;pi|apa&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;apa&quot; REGEXP &quot;^(pi|apa)$&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;pi&quot; REGEXP &quot;^(pi|apa)$&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;pix&quot; REGEXP &quot;^(pi|apa)$&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span>（表示不匹配）</span><br></pre></td></tr></table></figure>
<p><strong>(abc)</strong>*<br>
匹配任意多个abc（包括空串)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;pi&quot; REGEXP &quot;^(pi)*$&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;pip&quot; REGEXP &quot;^(pi)*$&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span>（表示不匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;pipi&quot; REGEXP &quot;^(pi)*$&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配）</span><br></pre></td></tr></table></figure>
<p><strong>{1}</strong><br>
<strong>{2,3}</strong><br>
这是一个更全面的方法，它可以实现前面好几种保留字的功能。<br>
<strong>a</strong>* 可以写成 <code>a&#123;0,&#125;</code>。<br>
<strong>a+</strong> 可以写成 <code>a&#123;1,&#125;</code>。<br>
<strong>a?</strong> 可以写成 <code>a&#123;0,1&#125;</code>。</p>
<p>在 {} 内只有一个整型参数 i，表示字符只能出现 i 次；在 {} 内有一个整型参数 i，后面跟一个 ,，表示字符可以出现 i 次或 i 次以上；在 {} 内只有一个整型参数 i，后面跟一个 ,，再跟一个整型参数 j, 表示字符只能出现 i 次以上，j 次以下（包括 i 次和 j 次）。其中的整型参数必须大于等于 0，小于等于 RE_DUP_MAX（默认是 255）。 如果有两个参数，第二个必须大于等于第一个。</p>
<p><strong>[a-dX]</strong> 匹配 <code>“a”、“b”、“c”、“d”</code> 或 <code>“X”</code>。<br>
<strong>[^a-dX]</strong> 匹配除 <code>“a”、“b”、“c”、“d”、“X”</code> 以外的任何字符。</p>
<p>**“[”、“]”**必须成对使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;aXbc&quot; REGEXP &quot;[a-dXYZ]&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;aXbc&quot; REGEXP &quot;^[a-dXYZ]$&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span>（表示不匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;aXbc&quot; REGEXP &quot;^[a-dXYZ]+$&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;aXbc&quot; REGEXP &quot;^[^a-dXYZ]+$&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span>（表示不匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;gheis&quot; REGEXP &quot;^[^a-dXYZ]+$&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span>（表示匹配） </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> &quot;gheisa&quot; REGEXP &quot;^[^a-dXYZ]+$&quot;; <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span>（表示不匹配）</span><br></pre></td></tr></table></figure>
<h2 id="SQL-IN-操作符">SQL IN 操作符</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
IN 操作符允许您在 WHERE 子句中规定多个值。</p>
<p><strong>SQL IN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1,value2,...);</span><br></pre></td></tr></table></figure>
<h2 id="SQL-BETWEEN-操作符">SQL BETWEEN 操作符</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
BETWEEN 操作符选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。</p>
<p><strong>SQL BETWEEN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">BETWEEN</span> value1 <span class="keyword">AND</span> value2;</span><br></pre></td></tr></table></figure>
<h2 id="SQL-别名">SQL 别名</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
通过使用 SQL，可以为表名称或列名称指定别名。基本上，创建别名是为了让列名称的可读性更强。</p>
<p><strong>列的 SQL 别名语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<p><strong>表的 SQL 别名语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name <span class="keyword">AS</span> alias_name;</span><br></pre></td></tr></table></figure>
<h2 id="SQL-JOIN">SQL JOIN</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。</p>
<p><code>INNER JOIN</code>：如果表中有至少一个匹配，则返回行<br>
<code>LEFT JOIN</code>：即使右表中没有匹配，也从左表返回所有的行<br>
<code>RIGHT JOIN</code>：即使左表中没有匹配，也从右表返回所有的行<br>
<code>FULL JOIN</code>：只要其中一个表中存在匹配，则返回行</p>
<p><img src="http://pic.colliexyy.com/16566670388548.jpg" alt=""></p>
<h3 id="SQL-INNER-JOIN-关键字">SQL INNER JOIN 关键字</h3>
<p>INNER JOIN 关键字在表中存在至少一个匹配时返回行。</p>
<p><strong>SQL INNER JOIN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name<span class="operator">=</span>table2.column_name;</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name<span class="operator">=</span>table2.column_name;</span><br></pre></td></tr></table></figure>
<p><img src="http://pic.colliexyy.com/16566670388568.jpg" alt=""></p>
<p><strong>注释</strong>：INNER JOIN 与 JOIN 是相同的。</p>
<h3 id="SQL-LEFT-JOIN-关键字">SQL LEFT JOIN 关键字</h3>
<p>LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。</p>
<p><strong>SQL LEFT JOIN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name<span class="operator">=</span>table2.column_name;</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name<span class="operator">=</span>table2.column_name;</span><br></pre></td></tr></table></figure>
<p><img src="http://pic.colliexyy.com/16566670388582.jpg" alt=""></p>
<p><strong>注释</strong>：在某些数据库中，LEFT JOIN 称为 LEFT OUTER JOIN。<br>
<strong>注释</strong>：LEFT JOIN 关键字从左表（Websites）返回所有的行，即使右表（access_log）中没有匹配。</p>
<h3 id="SQL-RIGHT-JOIN-关键字">SQL RIGHT JOIN 关键字</h3>
<p>RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。</p>
<p><strong>SQL RIGHT JOIN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name<span class="operator">=</span>table2.column_name;</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name<span class="operator">=</span>table2.column_name;</span><br></pre></td></tr></table></figure>
<p><img src="http://pic.colliexyy.com/16566670388597.jpg" alt=""></p>
<p><strong>注释</strong>：在某些数据库中，RIGHT JOIN 称为 RIGHT OUTER JOIN。<br>
<strong>注释</strong>：RIGHT JOIN 关键字从右表（Websites）返回所有的行，即使左表（access_log）中没有匹配。</p>
<h3 id="SQL-FULL-OUTER-JOIN-关键字">SQL FULL OUTER JOIN 关键字</h3>
<p>FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行。</p>
<p>FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。</p>
<p><strong>SQL FULL OUTER JOIN 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name<span class="operator">=</span>table2.column_name;</span><br></pre></td></tr></table></figure>
<p><img src="http://pic.colliexyy.com/16566670388611.jpg" alt=""></p>
<p><strong>注释</strong>：FULL OUTER JOIN 关键字返回左表（Websites）和右表（access_log）中所有的行。如果 “Websites” 表中的行在 “access_log” 中没有匹配或者 “access_log” 表中的行在 “Websites” 表中没有匹配，也会列出这些行。<br>
<strong>注释</strong>：MySQL中不支持 FULL OUTER JOIN</p>
<h2 id="SQL-UNION-操作符">SQL UNION 操作符</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>
<p>请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</p>
<p><strong>SQL UNION 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</p>
<p><strong>SQL UNION ALL 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>：UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</p>
<h2 id="SQL-INSERT-INTO-SELECT-语句">SQL INSERT INTO SELECT 语句</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
通过 SQL，您可以从一个表复制信息到另一个表。<br>
INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。</p>
<p><strong>SQL INSERT INTO SELECT 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>我们可以从一个表中复制所有的列插入到另一个已存在的表中：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table2</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>或者我们可以只复制希望的列插入到另一个已存在的表中：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table2</span><br><span class="line">(column_name(s))</span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table1;</span><br></pre></td></tr></table></figure>
<h2 id="MySQL-复制表-MySQL的SELECT-INTO-FROM-语句">MySQL 复制表(MySQL的SELECT INTO FROM 语句)</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
<strong>复制表结构及其数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name_new <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name_old</span><br></pre></td></tr></table></figure>
<p><strong>只复制表结构：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name_new <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name_old <span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>或者：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name_new <span class="keyword">LIKE</span> table_name_old</span><br></pre></td></tr></table></figure>
<p><strong>只复制表数据：</strong></p>
<ul>
<li>如果两个表结构一样：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name_new <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name_old</span><br></pre></td></tr></table></figure>
<ul>
<li>如果两个表结构不一样：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name_new(column1,column2...) <span class="keyword">SELECT</span> column1,column2... <span class="keyword">FROM</span> table_name_old</span><br></pre></td></tr></table></figure>
<p><strong>SELECT INTO FROM 和 INSERT INTO SELECT 的区别：</strong></p>
<p>主要区别：SELECT INTO FROM 要求目标表不存在，因为在插入时会自动创建；INSERT INTO SELECT FROM 要求目标表存在。</p>
<p><strong>SELECT INTO FROM</strong> ：将查询出来的数据整理到一张新表中保存，表结构与查询结构一致。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>（查询出来的结果） <span class="keyword">INTO</span> newtable（新的表名）<span class="keyword">FROM</span> <span class="keyword">WHERE</span> （后续条件）</span><br></pre></td></tr></table></figure>
<p>即，查询出来结果—&gt;复制一张同结构的空表—&gt;将数据拷贝进去。</p>
<p><strong>INSERT INTO SELECT</strong> ：为已经存在的表批量添加新数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>  (准备好的表) <span class="keyword">SELECT</span> <span class="operator">*</span>（或者取用自己想要的结构）<span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 各种条件</span><br></pre></td></tr></table></figure>
<p>即，指定一张想要插入数据的表格—&gt;对数据进行加工筛选—&gt;填入一张准备好的表格。</p>
<h2 id="SQL-约束（Constraints）">SQL 约束（Constraints）</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。</p>
<p>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</p>
<p><strong>SQL CREATE TABLE + CONSTRAINT 语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">column_name1 data_type(size) constraint_name,</span><br><span class="line">column_name2 data_type(size) constraint_name,</span><br><span class="line">column_name3 data_type(size) constraint_name,</span><br><span class="line">....</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在 SQL 中，我们有如下约束：</p>
<ul>
<li><code>NOT NULL</code> - 指示某列不能存储 NULL 值。</li>
<li><code>UNIQUE</code> - 保证某列的每行必须有唯一的值。</li>
<li><code>PRIMARY KEY</code> - (<code>NOT NULL</code> 和 <code>UNIQUE</code> 的结合)。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>
<li><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>
<li><code>CHECK</code> - 保证列中的值符合指定的条件。</li>
<li><code>DEFAULT</code> - 规定没有给列赋值时的默认值。</li>
</ul>
<h2 id="SQL-ALTER-TABLE-语句">SQL ALTER TABLE 语句</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
ALTER TABLE 语句用于在已有的表中添加、删除或修改列。</p>
<p><strong>SQL ALTER TABLE 语法：</strong></p>
<p>如需在表中添加列，请使用下面的语法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> column_name datatype</span><br></pre></td></tr></table></figure>
<p>如需删除表中的列，请使用下面的语法（请注意，某些数据库系统不允许这种在数据库表中删除列的方式）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name</span><br></pre></td></tr></table></figure>
<p>要改变表中列的数据类型，请使用下面的语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> column_name datatype</span><br></pre></td></tr></table></figure>
<h2 id="SQL-AUTO-INCREMENT-字段">SQL AUTO INCREMENT 字段</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
AUTO-INCREMENT 会在新记录插入表中时生成一个唯一的数字。</p>
<p><strong>AUTO INCREMENT 字段</strong><br>
我们通常希望在每次插入新记录时，自动地创建主键字段的值。</p>
<h2 id="SQL-CREATE-VIEW-语句">SQL CREATE VIEW 语句</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p>
<p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。</p>
<p>您可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。</p>
<p><strong>SQL CREATE VIEW 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure>
<p>**注释：**视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。</p>
<h2 id="SQL-撤销视图">SQL 撤销视图</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
您可以通过 DROP VIEW 命令来删除视图。</p>
<p><strong>SQL DROP VIEW 语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name</span><br></pre></td></tr></table></figure>
<h2 id="MySQL中修改表名，表属性名等操作">MySQL中修改表名，表属性名等操作</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 原列名 新列名  类型； <span class="comment">--修改表的列属性名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 列名 类型 ；  <span class="comment">--修改表的类类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 列名；  <span class="comment">--删除表的某一列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span>  列名 类型；<span class="comment">--添加某一列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME 新表名； <span class="comment">--修改表名</span></span><br></pre></td></tr></table></figure>
<h2 id="其他的问题">其他的问题</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<h3 id="mysql清空表数据后如何让自增ID仍从1开始">mysql清空表数据后如何让自增ID仍从1开始?</h3>
<blockquote>
<p>也就是说如何重排 auto_increment</p>
</blockquote>
<p><strong>两种方法：</strong></p>
<p>**1、**清空表时使用<code>truncate</code>命令，而不用<code>delete</code>命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name ;</span><br></pre></td></tr></table></figure>
<p>使用<code>truncate</code>命令的好处：</p>
<blockquote>
<p>1）、速度快<br>
2）、可以对自增 ID 进行重排，使自增 ID 仍从1开始计算</p>
</blockquote>
<p>**2、**清空表数据后，使用alter修改表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="mysql-建立索引">mysql 建立索引</h3>
<p>INDEX <code>idx_interface_name</code> ( <code>interface_name</code> ) USING BTREE 建立B树索引</p>
<h3 id="mysql-插入数据">mysql 插入数据</h3>
<p>如果对应元素有默认值，则可以，在 INSERT 时为空，不然会报错。</p>
<h3 id="mysql-时间戳设置">mysql 时间戳设置</h3>
<p>DEFAULT CURRENT_TIMESTAMP 表示当插入数据的时候，该字段默认值为当前时间<br>
ON UPDATE CURRENT_TIMESTAMP 在数据库数据有更新的时候UPDATE_TIME的时间会自动更新</p>
<h3 id="mysql-主键自增设置">mysql 主键自增设置</h3>
<p>AUTO_INCREMENT 用于主键自动增长</p>
<h1>Python</h1>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<h2 id="python-读取-Excel-文档">python 读取 Excel 文档</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_excel</span>(<span class="params">self, path</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">&quot;begin read %s&quot;</span> % path)</span><br><span class="line">        <span class="comment"># 读取 Excel 预处理动作↓，使用 xlrd 包将 Excel 文件读入 book 中</span></span><br><span class="line">        book = xlrd.open_workbook(path,encoding_override=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        data = <span class="built_in">dict</span>()</span><br><span class="line">        sheets = book.sheets()</span><br><span class="line">        <span class="keyword">for</span> cur <span class="keyword">in</span> sheets:</span><br><span class="line">            sheet_name = cur.name</span><br><span class="line">            nrows = cur.nrows</span><br><span class="line">            ncols = cur.ncols</span><br><span class="line">            logger.info(<span class="string">&quot;nrows=%d,ncols=%d&quot;</span> % (nrows, ncols))</span><br><span class="line">            sheet_val = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, nrows):</span><br><span class="line">                line = cur.row_values(idx)</span><br><span class="line">                <span class="comment"># sheet_val 为对应该页面每行数据的 list 数据</span></span><br><span class="line">                sheet_val.append(line)</span><br><span class="line">            <span class="comment"># data 为整个 Excel 文件每一张 sheet 的 Map 数据</span></span><br><span class="line">            data[sheet_name] = sheet_val</span><br><span class="line">        logger.info(<span class="string">&quot;read end, sheet=%d&quot;</span> % <span class="built_in">len</span>(data))</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.info(<span class="string">&quot;read %s fail, err=%s&quot;</span> % (path, <span class="built_in">str</span>(e)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h2 id="python-Excel-数据处理">python Excel 数据处理</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
<strong>Excel 转换成 SQL 语句</strong></p>
<p>单独拉出一列，在首行传入该函数后，复制到每一行，可拉取对应列的数据，并转换为 sql 语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=CONCATENATE(&quot;INSERT INTO table_name (list_1,list_2,list_3) VALUES (&#x27;&quot;,A1,&quot;&#x27;,&#x27;&quot;,B1,&quot;&#x27;,&#x27;&quot;,C1,&quot;&#x27;);&quot;)</span><br></pre></td></tr></table></figure>
<p><strong>Python 批量处理 Excel</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">连接数据库</span></span><br><span class="line"><span class="string">args：db_name（数据库名称）</span></span><br><span class="line"><span class="string">returns:db</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mysql_link</span>(<span class="params">db_name</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        db = pymysql.connect(host=<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>,</span><br><span class="line">                             port=xxxx,</span><br><span class="line">                             user=<span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">                             passwd=<span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">                             db=db_name,</span><br><span class="line">                             charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;could not connect to mysql server&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">读取excel函数</span></span><br><span class="line"><span class="string">args：excel_file（excel文件，目录在py文件同目录）</span></span><br><span class="line"><span class="string">returns：book</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">open_excel</span>(<span class="params">excel_file</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        book = xlrd.open_workbook(excel_file)  <span class="comment"># 文件名，把文件与py文件放在同一目录下</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;open excel file failed!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> book</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">执行插入操作</span></span><br><span class="line"><span class="string">args:db_name（数据库名称）</span></span><br><span class="line"><span class="string">table_name(表名称）</span></span><br><span class="line"><span class="string">excel_file（excel文件名，把文件与py文件放在同一目录下）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store_to</span>(<span class="params">db_name: <span class="built_in">object</span>, table_name: <span class="built_in">object</span>, excel_file: <span class="built_in">object</span></span>) -&gt; <span class="built_in">object</span>:</span><br><span class="line">    db = mysql_link(db_name)  <span class="comment"># 打开数据库连接</span></span><br><span class="line">    cursor = db.cursor()  <span class="comment"># 使用 cursor() 方法创建一个游标对象 cursor</span></span><br><span class="line">    book = open_excel(excel_file)  <span class="comment"># 打开excel文件</span></span><br><span class="line">    sheets = book.sheet_names()  <span class="comment"># 获取所有sheet表名</span></span><br><span class="line">    <span class="keyword">for</span> sheet <span class="keyword">in</span> sheets:</span><br><span class="line">        sh = book.sheet_by_name(sheet)  <span class="comment"># 打开每一张表</span></span><br><span class="line">        row_num = sh.nrows</span><br><span class="line">        <span class="keyword">if</span> row_num != <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(row_num - <span class="number">1</span>)</span><br><span class="line">        data_list = []  <span class="comment"># 定义列表用来存放数据</span></span><br><span class="line">        num = <span class="number">0</span>  <span class="comment"># 用来控制每次插入的数量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, row_num):  <span class="comment"># 第一行是标题名，对应表中的字段名所以应该从第二行开始，计算机以0开始计数，所以值是1</span></span><br><span class="line">            row_data = sh.row_values(i)  <span class="comment"># 按行获取excel的值</span></span><br><span class="line">            value = (</span><br><span class="line">                row_data[<span class="number">0</span>], row_data[<span class="number">1</span>], row_data[<span class="number">2</span>], row_data[<span class="number">3</span>], row_data[<span class="number">4</span>], row_data[<span class="number">5</span>], row_data[<span class="number">6</span>], row_data[<span class="number">7</span>],</span><br><span class="line">                row_data[<span class="number">8</span>])</span><br><span class="line">            sql = <span class="string">&quot;INSERT INTO &quot;</span> + <span class="built_in">str</span>(table_name) + <span class="string">&quot;(brand,sub_model_name,v8_10,`year`,trans_code,oe_code,std_name,&quot;</span> \</span><br><span class="line">                                                     <span class="string">&quot;`level`,specification,creator,updator) VALUES(%s,%s,%s,%s,%s,&quot;</span> \</span><br><span class="line">                                                     <span class="string">&quot;%s,%s,%s,%s,\&quot;xing.liuxing1218\&quot;,\&quot;xing.liuxing1218\&quot;) &quot;</span></span><br><span class="line">            data_list.append(value)  <span class="comment"># 将数据暂存在列表</span></span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">1000</span>:  <span class="comment"># 每一千条数据执行一次插入</span></span><br><span class="line">                cursor.executemany(sql, data_list)  <span class="comment"># 执行sql语句</span></span><br><span class="line">                data_list.clear()  <span class="comment"># 清空list</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;worksheets: &quot;</span> + sheet + <span class="string">&quot; has been inserted 1000 data!&quot;</span>)</span><br><span class="line">                num = <span class="number">0</span>  <span class="comment"># 计数归零</span></span><br><span class="line">        cursor.executemany(sql, data_list)  <span class="comment"># 执行sql语句</span></span><br><span class="line">        data_list.clear()  <span class="comment"># 清空list</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;worksheets: &quot;</span> + sheet + <span class="string">&quot; has been inserted &quot;</span> + <span class="built_in">str</span>(num) + <span class="string">&quot; data!&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> row_num != <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Success: worksheets: &quot;</span> + sheet + <span class="string">&quot; has been inserted &quot;</span> + <span class="built_in">str</span>(row_num - <span class="number">1</span>) + <span class="string">&quot; data!&quot;</span>)</span><br><span class="line">    db.commit()  <span class="comment"># 提交</span></span><br><span class="line">    cursor.close()  <span class="comment"># 关闭连接</span></span><br><span class="line">    db.close()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    store_to(<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;xxx.xls&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="python-复制文件">python 复制文件</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">shutil.copy(src, dst)</span><br></pre></td></tr></table></figure>
<h2 id="python-字符串处理">python 字符串处理</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将变量转化成字符串类型</span></span><br><span class="line"><span class="built_in">str</span>(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串全大写/全小写</span></span><br><span class="line">name = name.upper()</span><br><span class="line">name = name.lower()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类 C 语言中的字符串格式化语言，python 中用 % 处理变量转化</span></span><br><span class="line">ftp_name = <span class="string">&quot;%s_%s&quot;</span>%(xx_id, sec[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># strip()去掉字符串首位多余字符，为空时去掉多余空格</span></span><br><span class="line"><span class="comment"># split()将字符串通过参数中的字符，分割成若干字符串存在数组中</span></span><br><span class="line">plist = pic_advantage.strip().split(<span class="string">&quot;，&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># re模块处理正则表达式，以下为将 code 转化为[^a-zA-Z0-9]字符的函数</span></span><br><span class="line">pattern_code_trim = re.<span class="built_in">compile</span>(<span class="string">&quot;[^a-zA-Z0-9]&quot;</span>)</span><br><span class="line">src_code_trim = pattern_code_trim.sub(<span class="string">&#x27;&#x27;</span>, code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python中没有自增</span></span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="python-字典的遍历">python 字典的遍历</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># keys() 该方法会返回字典的所有的key</span></span><br><span class="line"><span class="comment"># 该方法会返回一个序列，序列中保存有字典的所有的键</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.keys())</span><br><span class="line"><span class="comment"># 通过遍历keys()来获取所有的键</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d.keys() :</span><br><span class="line">    <span class="built_in">print</span>(k , d[k])</span><br><span class="line"></span><br><span class="line"><span class="comment"># values()</span></span><br><span class="line"><span class="comment"># 该方法会返回一个序列，序列中保存有字典的所有的值</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> d.values():</span><br><span class="line">    <span class="built_in">print</span>(v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># items()</span></span><br><span class="line"><span class="comment"># 该方法会返回字典中所有的项</span></span><br><span class="line"><span class="comment"># 它会返回一个序列，序列中包含有双值子序列</span></span><br><span class="line"><span class="comment"># 双值分别是，字典中的key和value</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.items())</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(k, <span class="string">&#x27;=&#x27;</span>, v)</span><br></pre></td></tr></table></figure>
<h2 id="python解析json字符串">python解析json字符串</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = json.loads(req.text)</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;element&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;element_parent&#x27;</span>][<span class="string">&#x27;element_child&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(item[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> item[<span class="number">1</span>][<span class="string">&#x27;element1&#x27;</span>] == <span class="string">&#x27;xx&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span> item[<span class="number">1</span>][<span class="string">&#x27;element2&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="python常用的去重方式">python常用的去重方式</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<h3 id="对列表去重">对列表去重</h3>
<p>**1.**用循环查找的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">news_li = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> li:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> news_li:</span><br><span class="line">        news_li.append(i)</span><br><span class="line"><span class="built_in">print</span> (news_li)</span><br></pre></td></tr></table></figure>
<p>**2.**用集合的特性set()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">new_li1 = <span class="built_in">list</span>(<span class="built_in">set</span>(li1))</span><br></pre></td></tr></table></figure>
<p>**3.**使用itertools模块的grouby方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">li2 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">li2.sort() <span class="comment"># 排序</span></span><br><span class="line">it = itertools.groupby(li2)</span><br><span class="line"><span class="keyword">for</span> k, g <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span> (k)</span><br></pre></td></tr></table></figure>
<p>**4.**运用while循环遍历的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quchong</span>(<span class="params">lb</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> lb:</span><br><span class="line">        <span class="keyword">while</span> lb.count(x)&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">del</span> lb[lb.index(x)]</span><br><span class="line">    <span class="keyword">return</span> lb</span><br><span class="line">li3 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">quchong(li3)</span><br></pre></td></tr></table></figure>
<p>**5.**使用keys()方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li4 = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">5</span>]</span><br><span class="line">formatli = <span class="built_in">list</span>(&#123;&#125;.fromkeys(li4).keys())</span><br><span class="line"><span class="built_in">print</span> (formatli)</span><br></pre></td></tr></table></figure>
<h3 id="对数据框去重">对数据框去重</h3>
<p>**1.**用unique()对单属性列去重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;<span class="string">&#x27;id&#x27;</span>:[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;A&#x27;</span>],<span class="string">&#x27;age&#x27;</span>:[<span class="number">18</span>,<span class="number">20</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">14</span>,<span class="number">65</span>,<span class="number">14</span>,<span class="number">98</span>]&#125;</span><br><span class="line">data = pd.DataFrame(data)</span><br><span class="line">data.<span class="built_in">id</span>.unique()</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.unique(data.<span class="built_in">id</span>)</span><br></pre></td></tr></table></figure>
<p>**2.**用frame.drop_duplicates()对单属性列去重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.drop_duplicates([<span class="string">&#x27;id&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>**3.**用frame.drop_duplicates()对多属性列去重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.drop_duplicates([<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>**4.**用frame.duplicated()对多属性列去重</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isduplicated = data.duplicated([<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;age&#x27;</span>],keep=<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">data.loc[~isduplicated,:]</span><br></pre></td></tr></table></figure>
<h2 id="python-查找列表中重复元素以及重复元素的次数">python 查找列表中重复元素以及重复元素的次数</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&quot;奔奔&quot;</span>, <span class="string">&quot;benben&quot;</span>, <span class="string">&quot;奔奔&quot;</span>]</span><br><span class="line">b = <span class="built_in">dict</span>(Counter(a))</span><br><span class="line"><span class="comment"># 只展示重复元素</span></span><br><span class="line"><span class="built_in">print</span> ([key <span class="keyword">for</span> key,value <span class="keyword">in</span> b.items() <span class="keyword">if</span> value &gt; <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 展现重复元素和重复次数</span></span><br><span class="line"><span class="built_in">print</span> (&#123;key:value <span class="keyword">for</span> key,value <span class="keyword">in</span> b.items()<span class="keyword">if</span> value &gt; <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>方法一：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">myset = <span class="built_in">set</span>(mylist)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> myset:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the %d has found %d&quot;</span> %(item,mylist.count(item)))</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">the 1 has found 1</span><br><span class="line">the 2 has found 4</span><br><span class="line">the 3 has found 3</span><br><span class="line">the 4 has found 4</span><br></pre></td></tr></table></figure>
<p><strong>方法二：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">Counter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Counter(&#123;2: 4, 4: 4, 3: 3, 1: 1&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>方法三：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">a = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="type">List</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="type">List</span>.count(i) &gt; <span class="number">1</span>:</span><br><span class="line">        a[i] = <span class="type">List</span>.count(i)</span><br><span class="line"><span class="built_in">print</span> (a)</span><br></pre></td></tr></table></figure>
<h2 id="python-print-格式化输出">python print 格式化输出</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<h3 id="动态指定长度的实现">动态指定长度的实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print %s固定长度格式输出：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%10s, %20s&quot;</span> % (A, B))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果长度不定，以变量len代替：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%*s&quot;</span> % (<span class="built_in">len</span>, A))</span><br></pre></td></tr></table></figure>
<h3 id="以指定宽度格式化输出（format）">以指定宽度格式化输出（format）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mat = <span class="string">&quot;&#123;:20&#125;\t&#123;:28&#125;\t&#123;:32&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mat.<span class="built_in">format</span>(<span class="string">&quot;占4个长度&quot;</span>,<span class="string">&quot;占8个长度&quot;</span>, <span class="string">&quot;占12长度&quot;</span>))</span><br><span class="line"><span class="comment"># 如果需要居中输出在宽度前面加一个^</span></span><br><span class="line">mat = <span class="string">&quot;&#123;:^20&#125;\t&#123;:^28&#125;\t&#123;:^32&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mat.<span class="built_in">format</span>(<span class="string">&quot;占4个长度&quot;</span>,<span class="string">&quot;占8个长度&quot;</span>, <span class="string">&quot;占12长度&quot;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="python-Set-集合-相关函数操作">python Set(集合)相关函数操作</h2>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
<strong>python</strong>的<code>set</code>和其他语言类似, 是一个无序不重复元素集。基本功能包括关系测试和消除重复元素。集合对象还支持<code>union(联合)</code>, <code>intersection(交)</code>, <code>difference(差)</code>和<code>sysmmetric difference(对称差集)</code>等数学运算。</p>
<p><code>set</code> 支持 <code>x in set</code>, <code>len(set)</code>, 和 <code>for x in set</code>。作为一个无序的集合，<code>set</code>不记录元素位置或者插入点。因此，<code>set</code>不支持 <code>indexing</code>,<code> slicing</code>, 或其它类序列<code>sequence-like</code>的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>(s) </span><br><span class="line"><span class="comment"># set 的长度</span></span><br><span class="line"></span><br><span class="line">x <span class="keyword">in</span> s </span><br><span class="line"><span class="comment"># 测试 x 是否是 s 的成员</span></span><br><span class="line"></span><br><span class="line">x <span class="keyword">not</span> <span class="keyword">in</span> s </span><br><span class="line"><span class="comment"># 测试 x 是否不是 s 的成员</span></span><br><span class="line"></span><br><span class="line">s.issubset(t) s &lt;= t </span><br><span class="line"><span class="comment"># 测试是否 s 中的每一个元素都在 t 中</span></span><br><span class="line"></span><br><span class="line">s.issuperset(t) s &gt;= t </span><br><span class="line"><span class="comment"># 测试是否 t 中的每一个元素都在 s 中</span></span><br><span class="line"></span><br><span class="line">s.union(t) s | t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 和 t 中的每一个元素</span></span><br><span class="line"></span><br><span class="line">s.intersection(t) s &amp; t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 和 t 中的公共元素</span></span><br><span class="line"></span><br><span class="line">s.difference(t) s - t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 中有但是 t 中没有的元素</span></span><br><span class="line"></span><br><span class="line">s.symmetric_difference(t) s ^ t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 和 t 中不重复的元素</span></span><br><span class="line"></span><br><span class="line">s.copy() </span><br><span class="line"><span class="comment"># 返回 set “s”的一个浅复制</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">hash</span>(s)</span><br><span class="line"><span class="comment"># 返回 s 的 hash 值</span></span><br><span class="line"></span><br><span class="line">s.update(t)</span><br><span class="line">s |= t</span><br><span class="line"><span class="comment"># 返回增加了 set “t”中元素后的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.intersection_update(t)</span><br><span class="line">s &amp;= t</span><br><span class="line"><span class="comment"># 返回只保留含有 set “t”中元素的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.difference_update(t)</span><br><span class="line">s -= t</span><br><span class="line"><span class="comment"># 返回删除了 set “t”中含有的元素后的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.symmetric_difference_update(t)</span><br><span class="line">s ^= t</span><br><span class="line"><span class="comment"># 返回含有 set “t”或者 set “s”中有而不是两者都有的元素的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.add(x)</span><br><span class="line"><span class="comment"># 向 set “s”中增加元素 x</span></span><br><span class="line"></span><br><span class="line">s.remove(x)</span><br><span class="line"><span class="comment"># 从 set “s”中删除元素 x, 如果不存在则引发 KeyError</span></span><br><span class="line"></span><br><span class="line">s.discard(x)</span><br><span class="line"><span class="comment"># 如果在 set “s”中存在元素 x, 则删除</span></span><br><span class="line"></span><br><span class="line">s.pop()</span><br><span class="line"><span class="comment"># 删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyError</span></span><br><span class="line"></span><br><span class="line">s.clear()</span><br><span class="line"><span class="comment"># 删除 set “s”中的所有元素</span></span><br></pre></td></tr></table></figure>
<h1>Markdown 技能分享</h1>
<p><a href="#toc">&lt;返回目录&gt;</a><br>
<strong>Markdown是一种轻量级的「标记语言」</strong></p>
<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”</p>
<blockquote>
<p>Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如<s>Pandoc</s>，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p>
</blockquote>
<p><img src="media/16566671925678.png" alt="Pandao editor.md" title="Pandao editor.md"></p>
<h2 id="Markdown的功能列表演示">Markdown的功能列表演示</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 标题H1</span><br></pre></td></tr></table></figure>
<h1>标题H1</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 标题H2</span><br></pre></td></tr></table></figure>
<h2 id="标题H2">标题H2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 标题H3</span><br></pre></td></tr></table></figure>
<h3 id="标题H3">标题H3</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#### 标题H4</span><br></pre></td></tr></table></figure>
<h4 id="标题H4">标题H4</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##### 标题H5</span><br></pre></td></tr></table></figure>
<h5 id="标题H5">标题H5</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###### 标题H6</span><br></pre></td></tr></table></figure>
<h6 id="标题H6">标题H6</h6>
<h3 id="字符效果和横线等">字符效果和横线等</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~删除线~~ &lt;s&gt;删除线（开启识别HTML标签时）&lt;/s&gt;</span><br></pre></td></tr></table></figure>
<p><s>删除线</s> <s>删除线（开启识别HTML标签时）</s></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*斜体字*      _斜体字_</span><br></pre></td></tr></table></figure>
<p><em>斜体字</em>      <em>斜体字</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**粗体**  __粗体__</span><br></pre></td></tr></table></figure>
<p><strong>粗体</strong>  <strong>粗体</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***粗斜体*** ___粗斜体___</span><br></pre></td></tr></table></figure>
<p><em><strong>粗斜体</strong></em> <em><strong>粗斜体</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上标：X&lt;sub&gt;2&lt;/sub&gt;，下标：O&lt;sup&gt;2&lt;/sup&gt;</span><br></pre></td></tr></table></figure>
<p>上标：X<sub>2</sub>，下标：O<sup>2</sup></p>
<p><strong>缩写(同HTML的abbr标签)</strong></p>
<blockquote>
<p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The &lt;abbr title=&quot;Hyper Text Markup Language&quot;&gt;HTML&lt;/abbr&gt; specification is maintained by the &lt;abbr title=&quot;World Wide Web Consortium&quot;&gt;W3C&lt;/abbr&gt;.</span><br></pre></td></tr></table></figure>
<p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p>
<h3 id="引用-Blockquotes">引用 Blockquotes</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 引用文本 Blockquotes</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用文本 Blockquotes</p>
</blockquote>
<p>引用的行内混合 Blockquotes</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 引用：如果想要插入空白换行`即&lt;br /&gt;标签`，在插入处先键入两个以上的空格然后回车即可，[普通链接](https://www.mdeditor.com/)。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用：如果想要插入空白换行<code>即&lt;br /&gt;标签</code>，在插入处先键入两个以上的空格然后回车即可，<a href="https://www.mdeditor.com/">普通链接</a>。</p>
</blockquote>
<h3 id="锚点与链接-Links">锚点与链接 Links</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[普通链接](https://www.mdeditor.com/)</span><br><span class="line">[普通链接带标题](https://www.mdeditor.com/ &quot;普通链接带标题&quot;)</span><br><span class="line">直接链接：&lt;https://www.mdeditor.com&gt;</span><br><span class="line">[锚点链接][anchor-id]</span><br><span class="line">[anchor-id]: https://www.mdeditor.com/</span><br><span class="line">[mailto:test.test@gmail.com](mailto:test.test@gmail.com)</span><br><span class="line">GFM a-tail link @pandao</span><br><span class="line">邮箱地址自动链接 test.test@gmail.com  www@vip.qq.com</span><br><span class="line">&gt; @pandao</span><br></pre></td></tr></table></figure>
<p><a href="https://www.mdeditor.com/">普通链接</a><br>
<a href="https://www.mdeditor.com/" title="普通链接带标题">普通链接带标题</a><br>
直接链接：<a href="https://www.mdeditor.com">https://www.mdeditor.com</a><br>
[锚点链接][anchor-id]<br>
[anchor-id]: <a href="https://www.mdeditor.com/">https://www.mdeditor.com/</a><br>
<a href="mailto:test.test@gmail.com">mailto:test.test@gmail.com</a><br>
GFM a-tail link @pandao<br>
邮箱地址自动链接 <a href="mailto:test.test@gmail.com">test.test@gmail.com</a>  <a href="mailto:www@vip.qq.com">www@vip.qq.com</a></p>
<blockquote>
<p>@pandao</p>
</blockquote>
<h3 id="多语言代码高亮-Codes">多语言代码高亮 Codes</h3>
<h4 id="行内代码-Inline-code">行内代码 Inline code</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行命令：`npm install marked`</span><br></pre></td></tr></table></figure>
<p>执行命令：<code>npm install marked</code></p>
<h4 id="缩进风格">缩进风格</h4>
<p>即缩进四个空格，也做为实现类似 <code>&lt;pre&gt;</code> 预格式化文本 ( Preformatted Text ) 的功能。</p>
<pre><code>&lt;?php
    echo &quot;Hello world!&quot;;
?&gt;
</code></pre>
<p>预格式化文本：</p>
<pre><code>| First Header  | Second Header |
| ------------- | ------------- |
| Content Cell  | Content Cell  |
| Content Cell  | Content Cell  |
</code></pre>
<h4 id="JS代码">JS代码</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HTML-代码-HTML-codes">HTML 代码 HTML codes</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Editor.md, Markdown, Editor&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;<span class="attribute">color</span>:<span class="number">#444</span>;<span class="attribute">font-family</span>: <span class="string">&quot;Microsoft Yahei&quot;</span>, Tahoma, <span class="string">&quot;Hiragino Sans GB&quot;</span>, Arial;<span class="attribute">background</span>:<span class="number">#fff</span>;&#125;</span></span><br><span class="line"><span class="language-css">            <span class="selector-tag">ul</span>&#123;<span class="attribute">list-style</span>: none;&#125;</span></span><br><span class="line"><span class="language-css">            <span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:none;<span class="attribute">vertical-align</span>: middle;&#125;</span></span><br><span class="line"><span class="language-css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;text-xxl&quot;</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text-green&quot;</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="图片-Images">图片 Images</h3>
<p>图片加链接 (Image + Link)：</p>
<blockquote>
<p>Follow your heart.</p>
</blockquote>
<hr>
<h3 id="列表-Lists">列表 Lists</h3>
<h4 id="无序列表（减号）Unordered-Lists">无序列表（减号）Unordered Lists (-)</h4>
<ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="无序列表（星号）Unordered-Lists">无序列表（星号）Unordered Lists (*)</h4>
<ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
<h4 id="无序列表（加号和嵌套）Unordered-Lists">无序列表（加号和嵌套）Unordered Lists (+)</h4>
<ul>
<li>列表一</li>
<li>列表二
<ul>
<li>列表二-1</li>
<li>列表二-2</li>
<li>列表二-3</li>
</ul>
</li>
<li>列表三
<ul>
<li>列表一</li>
<li>列表二</li>
<li>列表三</li>
</ul>
</li>
</ul>
<h4 id="有序列表-Ordered-Lists">有序列表 Ordered Lists (-)</h4>
<ol>
<li>第一行</li>
<li>第二行</li>
<li>第三行</li>
</ol>
<h4 id="GFM-task-list">GFM task list</h4>
<ul>
<li>[x] GFM task list 1</li>
<li>[x] GFM task list 2</li>
<li>[ ] GFM task list 3
<ul>
<li>[ ] GFM task list 3-1</li>
<li>[ ] GFM task list 3-2</li>
<li>[ ] GFM task list 3-3</li>
</ul>
</li>
<li>[ ] GFM task list 4
<ul>
<li>[ ] GFM task list 4-1</li>
<li>[ ] GFM task list 4-2</li>
</ul>
</li>
</ul>
<hr>
<h3 id="绘制表格-Tables">绘制表格 Tables</h3>
<table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算机</td>
<td style="text-align:right">$1600</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align:right">$12</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>管线</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Function name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>help()</code></td>
<td>Display the help window.</td>
</tr>
<tr>
<td><code>destroy()</code></td>
<td><strong>Destroy your computer!</strong></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">Left-Aligned</th>
<th style="text-align:center">Center Aligned</th>
<th style="text-align:right">Right Aligned</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">col 3 is</td>
<td style="text-align:center">some wordy text</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td style="text-align:left">col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td style="text-align:left">zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Item</th>
<th style="text-align:right">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Computer</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>Phone</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>Pipe</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="特殊符号-HTML-Entities-Codes">特殊符号 HTML Entities Codes</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;copy; &amp;  &amp;uml; &amp;trade; &amp;iexcl; &amp;pound;</span><br><span class="line"></span><br><span class="line">&amp;amp; &amp;lt; &amp;gt; &amp;yen; &amp;euro; &amp;reg; </span><br><span class="line"></span><br><span class="line">&amp;plusmn; &amp;para; &amp;sect; &amp;brvbar; &amp;macr; &amp;laquo; &amp;middot;</span><br><span class="line"></span><br><span class="line">X&amp;sup2; Y&amp;sup3; &amp;frac34; &amp;frac14;  &amp;times;  &amp;divide;   &amp;raquo;</span><br><span class="line"></span><br><span class="line">18&amp;ordm;C  &amp;quot;  &amp;apos;</span><br></pre></td></tr></table></figure>
<p>© &amp;  ¨ ™ ¡ £</p>
<p>&amp; &lt; &gt; ¥ € ®</p>
<p>± ¶ § ¦ ¯ « ·</p>
<p>X² Y³ ¾ ¼  ×  ÷   »</p>
<p>18ºC  &quot;  '</p>
<hr>
<h3 id="Emoji表情-smiley">Emoji表情 :smiley:</h3>
<blockquote>
<p>Blockquotes :star:</p>
</blockquote>
<h4 id="GFM-task-lists-Emoji-fontAwesome-icon-emoji-editormd-logo-emoji-editormd-logo-5x">GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:</h4>
<ul>
<li>[x] :smiley: @mentions, :smiley: #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> supported :editormd-logo:;</li>
<li>[x] list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li>
<li>[x] [ ] :smiley: this is a complete item :smiley:;</li>
<li>[ ] []this is an incomplete item <a href="#">test link</a> :fa-star: @pandao;</li>
<li>[ ] [ ]this is an incomplete item :fa-star: :fa-gear:;
<ul>
<li>[ ] :smiley: this is an incomplete item <a href="#">test link</a> :fa-star: :fa-gear:;</li>
<li>[ ] :smiley: this is  :fa-star: :fa-gear: an incomplete item <a href="#">test link</a>;</li>
</ul>
</li>
</ul>
<h4 id="反斜杠-Escape">反斜杠 Escape</h4>
<p>*literal asterisks*</p>
<hr>
<h3 id="科学公式-TeX-KaTeX">科学公式 TeX(KaTeX)</h3>
<p>$$E=mc^2$$</p>
<p>行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。</p>
<p>$$x &gt; y$$</p>
<p>$$(\sqrt{3x-1}+(1+x)^2)$$</p>
<p>$$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$</p>
<p>多行公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n a\_k b\_k \right)^2</span><br><span class="line">\leq</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n a\_k^2 \right)</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n b\_k^2 \right)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">    \frac&#123;1&#125;&#123;</span><br><span class="line">        \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;</span><br><span class="line">        \frac25 \pi&#125;&#125; = 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;</span><br><span class="line">        1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span><br><span class="line">        &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125;</span><br><span class="line">         &#123;1+\cdots&#125; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">f(x) = <span class="keyword">\int</span><span class="built_in">_</span>&#123;-<span class="keyword">\infty</span>&#125;<span class="built_in">^</span><span class="keyword">\infty</span></span><br><span class="line">    <span class="keyword">\hat</span> f(<span class="keyword">\xi</span>)<span class="keyword">\,</span>e<span class="built_in">^</span>&#123;2 <span class="keyword">\pi</span> i <span class="keyword">\xi</span> x&#125;</span><br><span class="line">    <span class="keyword">\,</span>d<span class="keyword">\xi</span></span><br></pre></td></tr></table></figure>
<h3 id="分页符-Page-break">分页符 Page break</h3>
<blockquote>
<p>Print Test: Ctrl + P</p>
</blockquote>
<hr>
<h3 id="绘制流程图-Flowchart">绘制流程图 Flowchart</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 用户登陆</span><br><span class="line">op=&gt;operation: 登陆操作</span><br><span class="line">cond=&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e=&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="绘制序列图-Sequence-Diagram">绘制序列图 Sequence Diagram</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span><br><span class="line">Note right of China: China thinks\nabout it</span><br><span class="line">China--&gt;Andrew: How are you?</span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></table></figure>
<h3 id="End">End</h3>
<h1>git</h1>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git 免重复输入密码</span></span><br><span class="line">git config --global credential.helper store</span><br><span class="line"></span><br><span class="line"><span class="comment"># zsh gi 模块，自动生产.gitignore 文件</span></span><br><span class="line">gi python &gt; .gitignore</span><br><span class="line"></span><br><span class="line"><span class="comment"># git 从本地连接远端仓库(非 git clone 下来的代码)</span></span><br><span class="line">git remote add origin &lt;url&gt;</span><br><span class="line">git pull --rebase origin master</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># git 强制拉取最新代码</span></span><br><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/&lt;develop&gt;</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<h2 id="git-撤销命令详解">git 撤销命令详解</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<h3 id="修改最后一次commit的内容">修改最后一次commit的内容</h3>
<p>文件修改后<code>git add</code>了，也<code>git commit</code>了，发现哪里错了或者是漏<code>add</code>了一个文件，可以先<code>git add file</code>后，再<code>git commit –amend</code>这样只会记录一次<code>commit</code>（相当于将两次<code>commit</code>合并成了一次<code>commit</code>）。</p>
<h3 id="取消加入暂存区的文件">取消加入暂存区的文件</h3>
<p>不小心用了<code>git add .</code>将所有文件加入了暂存区或者是<code>add</code>多了文件，可以使用<code>git reset HEAD &lt;file&gt;</code>将文件拉回到已修改但是未提交到暂存区的状态。（在<code>add</code>后，通过<code>git status</code>可以看到相应提示，教你如何撤销提交）</p>
<h3 id="取消对当前目录下文件的修改">取消对当前目录下文件的修改</h3>
<p>不小心将文件改崩了，或者发现文件根本没必要修改，可以用<code>git checkout — &lt;file&gt;</code>取消工作区的文件的修改。（同样的，在修改文件后，通过<code>git status</code>可以看到相应提示）</p>
<h3 id="reset-命令的3种模式">reset 命令的3种模式</h3>
<p><code>git reset –option &lt;commitid&gt;</code>是回滚命令，option 有三个参数可选：</p>
<ol>
<li><code>git reset –mixed</code>，这也是默认方式（即不带参数默认是这种），回退暂存区和版本库信息，工作区的源码不会变化，可以重新add，重新commit。</li>
<li><code>git reset –soft</code>，回退版本库信息，暂存区和工作区都不会变化，如果还要提交，直接commit即可。</li>
<li><code>git reset –hard</code>，彻底回退，3个区都回退到历史某个版本。</li>
</ol>
<h3 id="回滚某个文件">回滚某个文件</h3>
<ol>
<li><code>git log –pretty=oneline &lt;file&gt;</code>可以查看某个文件的修改历史。</li>
<li><code>git show commit_id &lt;file&gt;</code>可以查看对应某个<code>commit</code>时期<code>file</code>的内容。</li>
<li><code>git reset commit_id &lt;file&gt;</code>可以将<code>file</code>回退到某个版本</li>
<li>执行完第3步后提示：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Unstaged changes after reset:</span><br><span class="line">M       README.md</span><br></pre></td></tr></table></figure>
<p>执行<code>git status</code>，提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br></pre></td></tr></table></figure>
<p>执行<code>git checkout — &lt;file&gt;</code>后，README.md成功回滚到指定版本。</p>
<h2 id="git-去掉多余的commit">git 去掉多余的commit</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i &lt;commit_ID&gt;</span><br><span class="line">git rebase -i master</span><br><span class="line">git rebase -i HEAD~&lt;num&gt;</span><br><span class="line"></span><br><span class="line">// squash：将这一行的 commit 与上一个 commit 进行合并</span><br><span class="line">// fixup：与 squash 相同，只是不会保留这行 commit 的提交 message 信息</span><br><span class="line"></span><br><span class="line">// 修改上一次 commit 提交的 message</span><br><span class="line">git commit --amend</span><br><span class="line">// 不过只能修正上一次的 commit。如果很多个 commit 之前就有 message 写错，就得用上我们之前说的 git rebase 了</span><br><span class="line"></span><br><span class="line">// 自动标记这一次的 commit 为上一个 commit 的 fix</span><br><span class="line">git commit --fixup &lt;commit&gt;</span><br><span class="line">// 自动组织合并两个 commit</span><br><span class="line">git rebase -i --autosquash</span><br><span class="line"></span><br><span class="line">// 撤销过去的 commit 重建一个新的</span><br><span class="line">git reset HEAD~2</span><br><span class="line">git add .</span><br><span class="line">git commit -am <span class="string">&quot;This is the new feature&quot;</span></span><br><span class="line">git push --force</span><br></pre></td></tr></table></figure>
<h2 id="git-commit-技巧">git commit 技巧</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -s -m  </span><br><span class="line">// 在git <span class="built_in">log</span> 的时候会多展示 signed-off-by  行</span><br><span class="line"></span><br><span class="line">git commit -a -m </span><br><span class="line">// 用于提交跟踪过的文件 ；会自动把修改的文件，先暂存，然后直接commit </span><br><span class="line">// 相当于git add . 与git commit –m “本次提交描述”两句操作合并为一句进行使用。</span><br></pre></td></tr></table></figure>
<h1>linux/Unix</h1>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<h2 id="访问本机接口">访问本机接口</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --location --request POST <span class="string">&#x27;http://本机IP/接口&#x27;</span> --header <span class="string">&#x27;Content-Type: application/x-www-form-urlencoded&#x27;</span> --data-urlencode <span class="string">&#x27;data=[&#123;&quot;type&quot;:1,&quot;brand&quot;:&quot;GE&quot;,&quot;ae_oe_code&quot;:&quot;9261317&quot;&#125;]&#x27;</span></span><br><span class="line"></span><br><span class="line">curl --location --request GET <span class="string">&#x27;http://127.0.0.1:18016/honda/oe_by_std_name?vin=LVHRM1836D5019492&amp;std_name=%E6%B3%A2%E7%AE%B1%E6%B2%B9&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="查看-log-技巧">查看 log 技巧</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f &lt;file&gt; i//自动刷新查看文件，适用于查看日志，相对于<span class="built_in">cat</span>的优点在于不用全部打开，只会看最新的几行，看大文件时不会那么容易卡死</span><br><span class="line"></span><br><span class="line">//查看nginx日志，并进行过滤</span><br><span class="line"><span class="built_in">tail</span> -f /var/log/nginx/access.log | grep XXX </span><br></pre></td></tr></table></figure>
<h2 id="vim-常用快捷键">vim 常用快捷键</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ </span><br><span class="line">// 光标移动到最后一个字符</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> </span><br><span class="line">// 光标移动到首位</span><br><span class="line"></span><br><span class="line">ZZ </span><br><span class="line">// 保存退出</span><br><span class="line"></span><br><span class="line">dt<span class="symbol">&lt;character&gt;</span></span><br><span class="line">// 删除到该字符</span><br><span class="line"></span><br><span class="line"><span class="keyword">f</span><span class="symbol">&lt;character&gt;</span></span><br><span class="line">// 将光标移动到，从光标当前位置开始第一个该字符的位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="homebrew">homebrew</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<h3 id="brew-相关命令">brew 相关命令</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">更新：brew update</span><br><span class="line">查看版本：brew -v</span><br><span class="line">帮助信息：brew -h</span><br><span class="line"></span><br><span class="line">查询软件的详细信息：brew info &lt;软件名&gt;</span><br><span class="line">查看安装列表：brew list</span><br><span class="line"></span><br><span class="line">安装软件包：brew install &lt;软件名&gt;</span><br><span class="line">卸载软件包：brew uninstall &lt;软件名&gt;</span><br><span class="line">彻底卸载指定软件，包括旧版本：brew uninstall --force &lt;软件名&gt;</span><br><span class="line"></span><br><span class="line">搜索软件：brew search &lt;正则表达式/软件名&gt;</span><br><span class="line">更新所有软件包：brew upgrade &lt;软件名&gt;</span><br><span class="line">查询有更新版本的软件：brew outdated</span><br><span class="line">清理指定软件的过时包：brew cleanup &lt;软件名&gt;</span><br><span class="line">清理所有的过时软件：brew cleanup</span><br><span class="line">列出需要清理的内容：brew cleanup -n</span><br><span class="line"></span><br><span class="line">用浏览器打开相关包的页面：brew home &lt;软件名&gt;</span><br><span class="line">显示包依赖：brew deps &lt;软件名&gt;</span><br><span class="line">锁定某个包：brew pin $FORMULA</span><br><span class="line">取消锁定：brew unpin $FORMULA</span><br><span class="line">查看已安装的包的依赖，树形显示：brew deps --installed --tree </span><br></pre></td></tr></table></figure>
<h3 id="brew-应用包">brew 应用包</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tree</span><br><span class="line">// 显示目录层级关系</span><br><span class="line"></span><br><span class="line">youtube-dl</span><br><span class="line">// 下载youtube视频</span><br><span class="line"></span><br><span class="line">ncdu</span><br><span class="line">// 查看磁盘占用情况</span><br><span class="line"></span><br><span class="line">ffmpeg</span><br><span class="line">// 音视频格式转换转码</span><br><span class="line"></span><br><span class="line">you-get</span><br><span class="line">// 下载爬取视频</span><br><span class="line"></span><br><span class="line">thefuck</span><br><span class="line">// 自动重输正确的建议命令</span><br></pre></td></tr></table></figure>
<h2 id="oh-my-zsh">oh-my-zsh</h2>
<p><a href="#toc">&lt;返回目录&gt;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git</span><br><span class="line">// git 快捷指令 由↓查看快捷指令</span><br><span class="line">// <span class="built_in">cat</span> ~/.oh-my-zsh/plugins/git/git.plugin.zsh</span><br><span class="line"></span><br><span class="line">gitignore</span><br><span class="line">// 自动生成gitignore文件</span><br><span class="line">// gi &lt;c/c++/python/...&gt; &gt; .gitignore</span><br><span class="line"></span><br><span class="line">zsh_reload</span><br><span class="line">// src 重载zsh</span><br><span class="line"></span><br><span class="line">git-open</span><br><span class="line">// 在任何一个git目录，输入git-open 就可以打开github对应的页面</span><br><span class="line"></span><br><span class="line">safe-paste</span><br><span class="line">// 当你往 zsh 粘贴脚本时，它不会被立刻运行</span><br><span class="line"></span><br><span class="line">extract</span><br><span class="line">// 万能解压命令</span><br><span class="line"></span><br><span class="line">gh-md-toc</span><br><span class="line">// md目录生成工具，<span class="built_in">alias</span> -&gt; mdtoc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>项目经历</category>
      </categories>
  </entry>
  <entry>
    <title>MQTT</title>
    <url>/2019/07/12/project_experience/MQTT/</url>
    <content><![CDATA[<h1>MQTT 协议</h1>
<blockquote>
<p>相关技术栈：linux、http/https、web</p>
</blockquote>
<h2 id="MQTT-协议的概念">MQTT 协议的概念</h2>
<p>MQTT协议，全称 Message Queue Telemetry Transport 消息队列遥测传输协议 ，是一种<strong>基于发布/订阅的轻量级通讯协议</strong>。</p>
<p><strong>适用于条件较差的网络环境</strong>，如：网络延迟高、带宽低、通信讯号不稳定等情况。</p>
<h2 id="MQTT协议的特点">MQTT协议的特点</h2>
<ul>
<li><strong>构建于 TCP/IP 协议之上</strong></li>
</ul>
<blockquote>
<p>TCP/IP参考模型可分为四层：<strong>应用层、传输层、网络层、链路层</strong>。TCP、UDP 协议均属于传输层，MQTT 运行与 TCP 之上，属于<strong>应用层协议</strong>，只要支持 TCP/IP 协议栈的地方都可应用 MQTT。</p>
</blockquote>
<ul>
<li><strong>基于 C-S 架构</strong>的消息发布/订阅，提供一对多的消息发布，作为客户端之间的中间介质，解除应用程序的耦合。</li>
<li><strong>对负载内容屏蔽</strong>的消息传输</li>
<li>使用 <strong>TCP</strong> 连接进行数据推送</li>
<li>三种消息发布 QoS</li>
</ul>
<span id="more"></span>
<blockquote>
<p>QoS 0：<strong>至多一次</strong>。服务器只推送1次，至于客户端是否收到，收到的消息是否正确，数据是否有所丢失，都不管。<br>
QoS 1：<strong>至少一次</strong>。客户端收到服务器的推送后要回复一个PUBACK告诉服务器已收到，否则服务器会认为Client未收到推送，隔一段时间后重新发送，直到对方回复PUBACK。<br>
QoS 2：<strong>只发一次</strong>。保证数据包到达目的地，且不会出现重复。服务器发送数据包，客户端接收后回复PUBREC（收到发布消息）报文，服务器存储PUBREC中的报文标识符，发送PUBREL（释放发布消息）。</p>
</blockquote>
<p><img src="http://pic.colliexyy.com/16566674990266.jpg" alt=""></p>
<h2 id="MQTT协议规范">MQTT协议规范</h2>
<h3 id="消息类型">消息类型</h3>
<p>表1.<strong>报文类型值</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">值</th>
<th style="text-align:left">流向</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CONNECT</td>
<td style="text-align:left">1</td>
<td style="text-align:left">C -&gt; S</td>
<td style="text-align:left">客户端连接请求</td>
</tr>
<tr>
<td style="text-align:left">CONNACK</td>
<td style="text-align:left">2</td>
<td style="text-align:left">S -&gt; C</td>
<td style="text-align:left">服务端确认连接</td>
</tr>
<tr>
<td style="text-align:left">PUBLISH</td>
<td style="text-align:left">3</td>
<td style="text-align:left">C &lt;-&gt; S</td>
<td style="text-align:left">发布消息</td>
</tr>
<tr>
<td style="text-align:left">PUBACK</td>
<td style="text-align:left">4</td>
<td style="text-align:left">C &lt;-&gt; S</td>
<td style="text-align:left">QoS1消息确认</td>
</tr>
<tr>
<td style="text-align:left">PUBREC</td>
<td style="text-align:left">5</td>
<td style="text-align:left">C &lt;-&gt; S</td>
<td style="text-align:left">QoS2收到消息（保证传输step1）</td>
</tr>
<tr>
<td style="text-align:left">PUBREL</td>
<td style="text-align:left">6</td>
<td style="text-align:left">C &lt;-&gt; S</td>
<td style="text-align:left">QoS2释放消息（保证传输step2）</td>
</tr>
<tr>
<td style="text-align:left">PUBCOMP</td>
<td style="text-align:left">7</td>
<td style="text-align:left">C &lt;-&gt; S</td>
<td style="text-align:left">QoS2完成消息（保证传输step3）</td>
</tr>
<tr>
<td style="text-align:left">SUBSCRIBE</td>
<td style="text-align:left">8</td>
<td style="text-align:left">C -&gt; S</td>
<td style="text-align:left">订阅消息</td>
</tr>
<tr>
<td style="text-align:left">SUBACK</td>
<td style="text-align:left">9</td>
<td style="text-align:left">S -&gt; C</td>
<td style="text-align:left">订阅确认</td>
</tr>
<tr>
<td style="text-align:left">UNSUBSCRIBE</td>
<td style="text-align:left">10</td>
<td style="text-align:left">C -&gt; S</td>
<td style="text-align:left">取消订阅</td>
</tr>
<tr>
<td style="text-align:left">UNSUBACK</td>
<td style="text-align:left">11</td>
<td style="text-align:left">S -&gt; C</td>
<td style="text-align:left">取消订阅确认</td>
</tr>
<tr>
<td style="text-align:left">PINGREQ</td>
<td style="text-align:left">12</td>
<td style="text-align:left">C -&gt; S</td>
<td style="text-align:left">连接保活请求</td>
</tr>
<tr>
<td style="text-align:left">PINGRESP</td>
<td style="text-align:left">13</td>
<td style="text-align:left">S -&gt; C</td>
<td style="text-align:left">保活回应</td>
</tr>
<tr>
<td style="text-align:left">DISCONNECT</td>
<td style="text-align:left">14</td>
<td style="text-align:left">C -&gt; S</td>
<td style="text-align:left">断开连接</td>
</tr>
</tbody>
</table>
<p><strong>注：</strong> 值为 0 和 15 保留</p>
<h3 id="MQTT控制报文">MQTT控制报文</h3>
<p>MQ控制报文由三部分组成：<strong>固定报头+可变报头+有效载荷</strong></p>
<p>表2.<strong>报文格式</strong></p>
<table>
<thead>
<tr>
<th>↓</th>
<th>↓</th>
</tr>
</thead>
<tbody>
<tr>
<td>固定报头</td>
<td>所有控制报文都包含</td>
</tr>
<tr>
<td>可变报头</td>
<td>部分报文包含</td>
</tr>
<tr>
<td>有效载荷</td>
<td>部分报文包含</td>
</tr>
</tbody>
</table>
<h4 id="固定报头">固定报头</h4>
<p>表3.<strong>固定报头格式</strong></p>
<table>
    <tr>
        <td>Bit</td> 
        <td>7</td>
        <td>6</td> 
        <td>5</td>
        <td>4</td>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>0</td>
   </tr>
    <tr>
        <td>Byte 1</td>
        <td colspan="4">MQTT控制报文类型</td>
        <td colspan="4">控制报文类型的标志位</td>
    </tr>
    <tr>
        <td>Byte 2</td>
        <td colspan="8" align="center">剩余长度</td>
    </tr>
</table>
<p><strong>注：</strong> 固定报头 Byte1 的高四位是表1中消息类型的值，以二进制数表示。低四位是报文类型的标志位。</p>
<h4 id="可变报头">可变报头</h4>
<p>可变报头在固定报头和负载之间。可变报头的报文标识符字段存在于在多个类型的报文里。</p>
<blockquote>
<p>很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是 QoS &gt; 0 时的 PUBLISH，PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCRIBE，UNSUBACK。SUBSCRIBE，UNSUBSCRIBE和PUBLISH（QoS大于0）控制报文必须包含一个非零的 16 位报文标识符。客户端每次发送一个新的这些类型的报文时都必须分配一个当前未使用的报文标识符。如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时，它必须使用相同的标识符。当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。发送一个 QoS 0 的PUBLISH报文时，相同的条件也适用于服务端。</p>
</blockquote>
<p>即 uuid，标识会话，当标识符一致时表示在同一会话中。</p>
<h4 id="有效载荷">有效载荷</h4>
<p>-&gt;Body.</p>
]]></content>
      <categories>
        <category>项目经历</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL_SOP</title>
    <url>/2018/12/11/project_experience/MySQL_SOP/</url>
    <content><![CDATA[<h1>MySQL 使用规范</h1>
<h2 id="一、基本规范">一、基本规范</h2>
<ol>
<li>使用 <strong>INNODB</strong> 存储引擎</li>
<li>表字符集使用 <strong>UTF8</strong>，如遇到 EMOJI 等表情符号的存储需求，可申请使用 <strong>UTF8MB4</strong> 字符集</li>
<li>所有表都需要添加<strong>注释</strong></li>
<li>单表数据量建<strong>字符类型居多</strong>的表建议控制在 <strong>3000W 以内</strong>，<strong>整型居多</strong>的表建议控制在 <strong>5000W 以内</strong></li>
<li>不在数据库中存储图⽚、文件等大数据</li>
<li>禁止在线上做数据库压力测试</li>
<li>禁⽌从测试、开发环境直连数据库</li>
</ol>
<h2 id="二、命名规范">二、命名规范</h2>
<ol>
<li>库名、表名、字段名必须有<strong>固定的命名长度</strong>，12个字符以内</li>
<li>库名、表名、字段名<strong>禁⽌使⽤ MySQL 保留字</strong>，比如订单表不要直接叫做order</li>
<li>临时库、临时表，命名必须<strong>以 tmp 为前缀，并以⽇日期为后缀</strong></li>
<li>备份库、备份表，命名必须<strong>以 bak 为前缀，并以日期为后缀</strong></li>
</ol>
<span id="more"></span>
<h2 id="三、库、表、字段设计规范">三、库、表、字段设计规范</h2>
<ol>
<li>建表<strong>默认5字段：主键、创建时间、创建人、修改时间、修改人</strong>。id、create_time、creator、update_time、updator</li>
<li>禁⽌使用分区表</li>
<li>拆分大字段和访问频率低的字段，<strong>分离冷热数据</strong></li>
<li>按日期时间分表需符合例如 table_201401、table_20140422 格式</li>
<li>采用合适的分库分表策略</li>
<li>用 <strong>DECIMAL</strong> 代替 FLOAT 和 DOUBLE 存储精确浮点数</li>
<li><strong>越简单越好</strong>：将字符转化为数字、使用 TINYINT 来代替 ENUM 类型</li>
<li>若使用 ENUM 类型，不允许修改默认值，只允许顺序添加</li>
<li>所有字段均定义为 <strong>NOT NULL</strong></li>
<li>INT类型固定占用 4 字节存储</li>
<li>使用 <strong>timestamp</strong> 存储时间</li>
<li>使用 <strong>VARBINARY</strong> 存储大小写敏感的变长字符串</li>
<li>禁止在数据库中存储明文密码，把<strong>密码加密后存储</strong></li>
<li>用好数值类型字段</li>
<li><strong>存储 ip 最好用 int</strong> 存储而非 char(15)</li>
<li><strong>避免使用 NULL</strong>， NULL 字段很难查询优化，NULL字段的索引需要额外空间，NULL字段的复合索引无效</li>
<li>少用 text/blob ， varchar 的性能会比 text 高很多，实在避免不了blob，请拆表</li>
<li>数据库中<strong>不允许存储大文件</strong>，或者照片，可以将大对象放到磁盘上，<strong>数据库中存储它的路径</strong></li>
</ol>
<h2 id="四、索引规范">四、索引规范</h2>
<p>1、索引的数量要控制：</p>
<ul>
<li>单张表中<strong>索引数量</strong>不超过 5 个</li>
<li>单个索引中的<strong>字段数</strong>不超过 5 个</li>
<li><strong>对字符串使⽤用前缀索引</strong>，前缀索引长度不超过 8 个字符</li>
<li>建议<strong>优先考虑前缀索引</strong>，必要时可<strong>添加伪列并建立索引</strong></li>
</ul>
<p>2、主键准则</p>
<ul>
<li>表必须有主键</li>
<li><strong>不使用更新频繁的列作为主键</strong></li>
<li><strong>尽量不选择字符串列作为主键</strong></li>
<li><strong>不使用 UUID MD5 HASH 这些作为主键(数值太离散了)</strong></li>
<li>默认使⽤非空的唯一键作为主键</li>
<li><strong>建议选择自增或发号器</strong></li>
</ul>
<p>3、<strong>重要的 SQL 必须被索引</strong></p>
<ul>
<li>比如：UPDATE 、 DELETE 语句的 WHERE 条件列，ORDER BY 、 GROUPBY 、 DISTINCT 的字段</li>
</ul>
<p>4、多表 JOIN 的字段注意以下</p>
<ul>
<li><strong>区分度最大的字段放在前面</strong></li>
<li>核⼼ SQL 优先考虑覆盖索引</li>
<li>避免冗余和重复索引</li>
<li><strong>索引要综合评估数据密度和分布以及考虑查询和更新比例</strong></li>
</ul>
<p>5、索引禁忌</p>
<ul>
<li><strong>不在低基数列上建立索引</strong>，例如“性别”</li>
<li><strong>不在索引列进行数学运算和函数运算</strong></li>
</ul>
<p>6、<strong>尽量不使用外键</strong></p>
<ul>
<li>外键用来保护参照完整性，可在业务端实现</li>
<li>对父表和子表的操作会相互影响，降低可用性</li>
</ul>
<p>7、索引命名：</p>
<ul>
<li>非唯一索引必须以 idx_字段1_字段2 命名，唯一所以必须以 uniq_字段1_字段2 命名，<strong>索引名称必须全部小写</strong></li>
</ul>
<p>8、新建的唯一索引必须不能和主键重复</p>
<p>9、<strong>索引字段的默认值不能为 NULL</strong> ，要改为其他的 default 或者空。 NULL 非常影响索引的查询效率</p>
<p>10、反复查看与表相关的 SQL</p>
<ul>
<li><strong>符合最左前缀的特点建立索引。</strong> 多条字段重复的语句，要修改语句条件字段的顺序，为其建立一条联合索引，减少索引数量</li>
</ul>
<p>11、<strong>能使用唯一索引就要使用唯一索引</strong>，提高查询效率</p>
<p>12、研发要经常使用 explain ，如果发现索引选择性差，必须让他们学会使用 hint</p>
<p>13、<strong>合理创建联合索引，(a，b，c)</strong> 相当于 (a) 、(a，b) 、(a，b，c)</p>
<p>14、<strong>不对过长的 VARCHAR 字段建立索引。</strong> 建议优先考虑<strong>添加 CRC32 或 MD5 伪列，并对伪列建立索引</strong>，减少索引长度，提高效率。</p>
<h1>五、SQL规范</h1>
<ol>
<li>使用 <strong>prepared statement</strong>，可以提升性能并避免 SQL 注入。</li>
<li><strong>减少与数据库交互次数</strong>，尽量采用<strong>批量提交 SQL 语句</strong><code>INSERT INTO table （column1、column2、column3） VALUES(),(),();</code>，不宜过多看字符个数 <strong>500-1000</strong> 即可。</li>
<li><strong>SQL 语句尽可能简单</strong>，大的 SQL 想办法拆成小的 SQL 语句(充分利用句QUERYCACHE 和充分利用多核 CPU)</li>
<li><strong>事务要简单</strong>，整个事务的时间长度不要太长</li>
<li>避免使用触发器、函数、存储过程</li>
<li>降低业务耦合度，为 sacle out 、 sharding 留有余地</li>
<li><strong>避免在数据库中进⾏数学运算</strong>(MySQL不擅长数学运算和逻辑判断)</li>
<li><strong>不要用 <code>SELECT *</code></strong> ，查询哪几个字段就SELECT这几个字段</li>
<li>SQL 中使用到 <strong>OR 的改写为用 IN()</strong> (OR的效率没有IN的效率高)，里面数字的<strong>个数建议控制在 1000 以内</strong>。</li>
<li>LIMIT 分页注意效率。</li>
<li><strong>使用 UNION ALL 替代 UNION</strong></li>
<li>避免使用大表的 JOIN</li>
<li>使用 GROUP BY 分组、自动排序</li>
<li><strong>对数据的更新要打散后批量更新，不要一次更新太多数据</strong></li>
<li>注意使用性能分析工具</li>
<li>SQL explain / showprofile / mySQLsla，尽量避免 extra 列出现：Using File Sort、Using Temporary。</li>
<li>SQL 语句要求所有研发，<strong>SQL 关键字全部是大写，每个词只允许有一个空格</strong>。</li>
<li>SQL 语句<strong>不可以出现隐式转换</strong>，比如<code>SELECT id FROM TABLE WHERE id='1'</code>。</li>
<li>IN 条件里面的数据数量要少，1000 个以内，要学会使用 EXIST 代替IN，EXIST 在一些场景查询会比 IN 快。</li>
<li><strong>NOT IN 能不用就不用</strong>，会把空和 NULL 给查出来。</li>
<li>在 SQL 语句中，<strong>禁止使用前缀是 % 的 LIKE</strong></li>
<li><strong>不使用负向查询</strong>，如 <code>NOT IN</code> / <code>NOT LIKE</code> / <code>!=</code> / <code>&lt; &gt;</code></li>
<li>程序里建议合理使用分页来提高查询效率。</li>
<li>使⽤预编译语句，只传参数，比传递 SQL 语句更高效；一次解析，多次使用；降低 SQL 注入概率</li>
<li><strong>禁止使 ORDER BY RAND()</strong></li>
<li><strong>禁⽌单条 SQL 语句同时更新多个表</strong></li>
<li><strong>禁止使用 % 前导查询</strong>，例如：like “%abc”，无法利用到索引。</li>
</ol>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL</title>
    <url>/2019/09/05/project_experience/OpenSSL/</url>
    <content><![CDATA[<h1>OpenSSL</h1>
<blockquote>
<p>相关技术栈：linux、http/https、web</p>
</blockquote>
<h2 id="什么是-SSL？">什么是 SSL？</h2>
<p>SSL 是一个缩写，代表的是 Secure Sockets Layer（<strong>安全套接层</strong>）。它是支持在 Internet 上进行<strong>安全通信的标准，并且将数据密码术集成到了协议之中。数据在离开您的计算机之前就已经被加密，然后只有到达它预定的目标后才被解密。</strong> 底层实现是证书和密码学算法。</p>
<p>理论上，如果加密的数据在到达目标之前被截取或窃听，那些数据是不可能被破解的。不过，由于计算机的变化一年比一年快，而且密码翻译方法有了新的发展，因此，SSL 中使用的加密协议被破解的可能性也在增大。</p>
<p><strong>可以将 SSL 和安全连接用于 Internet 上任何类型的协议</strong>，不管是 HTTP、POP3，还是 FTP。还可以用 SSL 来保护 Telnet 会话。虽然可以用 SSL 保护任何连接，但是不必对每一类连接都使用 SSL。<strong>如果连接传输敏感信息，则应使用 SSL。</strong></p>
<h2 id="什么是-OpenSSL？">什么是 OpenSSL？</h2>
<p>OpenSSL 不仅仅是 SSL。它可以实现<strong>消息摘要、文件的加密和解密、数字证书、数字签名和随机数字</strong>。</p>
<p>OpenSSL 不只是 <strong>API</strong>，它还是一个<strong>命令行工具</strong>。命令行工具可以完成与 API 同样的工作， 而且可以测试 SSL 服务器和客户机。</p>
<span id="more"></span>
<h2 id="您需要什么">您需要什么</h2>
<p>首先需要的是最新版本的 OpenSSL。查阅<a href="https://www.openssl.org/">官网</a>，以确定从哪里可以获得最新的可以自己编译的源代码，或者最新版本的二进制文件（如果您不希望花费时间来编译的话）。不过，为了安全起见，我建议您下载最新的源代码并自己编译它。二进制版本通常是由第三方而不是由 OpenSSL 的开发人员来编译和发行的。</p>
<p>一些 Linux 的发行版本附带了 OpenSSL 的二进制版本，对于学习如何使用 OpenSSL 库来说，这足够了；不过，如果您打算去做一些实际的事情，那么一定要得到最新的版本，并保持该版本一直是最新的。</p>
<p>对于以 RPM 形式安装的 Linux 发行版本（Red Hat、Mandrake 等），建议您通过从发行版本制造商那里获得 RPM 程序包来更新您的 OpenSSL 发行版本。出于安全方面的原因，建议您使用最新版本的发行版本。如果您的发行版本不能使用最新版本的 OpenSSL，那么建议您只覆盖库文件，不要覆盖可执行文件。OpenSSL 附带的 FAQ 文档中包含了有关这方面的细节。</p>
<p>还要注意的是，OpenSSL 并没有在所有的平台上都获得官方支持。虽然制造商已经尽力使其能够跨平台兼容，但仍然存在 OpenSSL 不能用于您的计算机和/或操作系统的可能。请参阅 OpenSSL 的 <a href="https://www.openssl.org/">Web 站点</a>，以获得关于哪些平台可以得到支持的信息。</p>
<p>如果想使用 OpenSSL 来生成证书请求和数字证书，那么必须创建一个配置文件。在OpenSSL 程序包的 apps 文件夹中，有一个名为 openssl.cnf 的 可用模板文件。我不会对该文件进行讨论，因为这不在本文要求范围之内。不过，该模板文件有一些非常好的注释，而且如果在 Internet 上搜索，您可以找到很多讨论修改该文件的教程。</p>
<h2 id="头文件和初始化">头文件和初始化</h2>
<p>本教程所使用的头文件只有三个：ssl.h、bio.h 和 err.h。它们都位于 openssl 子目录中，而且都是开发您的项目所必需的。要初始化 OpenSSL 库，只需要三个代码行即可。清单 1 中列出了所有内容。其他的头文件或初始化函数可能是其他一些功能所必需的。</p>
<p><strong>清单 1. 必需的头文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* OpenSSL headers */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;openssl/bio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;openssl/ssl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;openssl/err.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initializing OpenSSL */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">SSL_load_error_strings</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">ERR_load_BIO_strings</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">OpenSSL_add_all_algorithms</span>();</span><br></pre></td></tr></table></figure>
<h2 id="建立非安全连接">建立非安全连接</h2>
<p>不管连接是安全的还是不安全的，OpenSSL 都使用了一个名为 BIO 的抽象库来处理包括文件和套接字在内的各种类型的通信。您还可以将 OpenSSL 设置成为一个过滤器，比如用于 UU 或 Base64 编码的过滤器。</p>
<p>在这里对 BIO 库进行全面说明有点麻烦，所以我将根据需要一点一点地介绍它。首先，我将向您展示如何建立一个标准的套接字连接。相对于使用 BSD 套接字库，该操作需要的代码行更少一些。</p>
<p>在建立连接（无论安全与否）之前，要创建一个指向 BIO 对象的指针。这类似于在标准 C 中为文件流创建 FILE 指针。</p>
<p><strong>清单 2. 指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BIO * bio;</span><br></pre></td></tr></table></figure>
<h3 id="打开连接">打开连接</h3>
<p>创建新的连接需要调用 BIO_new_connect 。您可以在同一个调用中同时 指定主机名和端口号。也可以将其拆分为两个单独的调用：一个是创建连接并设置主机名的 BIO_new_connect 调用，另一个是设置端口号的 BIO_set_conn_port （或者 BIO_set_conn_int_port ）调用。</p>
<p>不管怎样，一旦 BIO 的主机名和端口号都已指定，该指针会尝试打开连接。没有什么可以影响它。如果创建 BIO 对象时遇到问题，指针将会是 NULL。为了确保连接成功，必须执行 BIO_do_connect 调用。</p>
<p><strong>清单 3. 创建并打开连接</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bio = <span class="built_in">BIO_new_connect</span>(<span class="string">&quot;hostname:port&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bio == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Handle the failure */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">BIO_do_connect</span>(bio) &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Handle failed connection */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，第一行代码使用指定的主机名和端口创建了一个新的 BIO 对象，并以所示风格对该对象进行格式化。例如，如果您要连接到 <a href="http://www.ibm.com">www.ibm.com</a> 的 80 端口，那么该字符串将是 <a href="http://www.ibm.com:80">www.ibm.com:80</a> 。调用 BIO_do_connect 检查连接是否成功。如果出错，则返回 0 或 -1。</p>
<h3 id="与服务器进行通信">与服务器进行通信</h3>
<p>不管 BIO 对象是套接字还是文件，对其进行的读和写操作都是通过以下两个函数来完成的： BIO_read 和 BIO_write 。很简单，对吧？精彩之处就在于它始终如此。</p>
<p>BIO_read 将尝试从服务器读取一定数目的字节。它返回读取的字节数、 0 或者 -1。在受阻塞的连接中，该函数返回 0，表示连接已经关闭，而 -1 则表示连接出现错误。在非阻塞连接的情况下，返回 0 表示没有可以获得的数据，返回 -1 表示连接出错。可以调用 BIO_should_retry 来确定是否可能重复出现该错误。</p>
<p><strong>清单 4. 从连接读取</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">BIO_read</span>(bio, buf, len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Handle closed connection */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(!<span class="built_in">BIO_should_retry</span>(bio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Handle failed read here */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Do something to handle the retry */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BIO_write 会试着将字节写入套接字。它将返回实际写入的字节数、0 或者 -1。同 BIO_read ，0 或 -1 不一定表示错误。</p>
<p>BIO_should_retry 是找出问题的途径。如果需要重试写操作，它必须使用和前一次完全相同的参数。</p>
<p><strong>清单 5. 写入到连接</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">BIO_write</span>(bio, buf, len) &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">BIO_should_retry</span>(bio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Handle failed write here */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Do something to handle the retry */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关闭连接">关闭连接</h3>
<p>关闭连接也很简单。您可以使用以下两种方式之一来关闭连接： BIO_reset 或 BIO_free_all 。如果您还需要重新使用对象，那么请使用第一种方式。 如果您不再重新使用它，则可以使用第二种方式。</p>
<p>BIO_reset 关闭连接并重新设置 BIO 对象的内部状态，以便可以重新使用连接。如果要在整个应用程序中使用同一对象，比如使用一台安全的聊天客户机，那么这样做是有益的。该函数没有返回值。</p>
<p>BIO_free_all 所做正如其所言：它释放内部结构体，并释放所有相关联的内存，其中包括关闭相关联的套接字。如果将 BIO 嵌入于一个类中，那么应该在类的析构函数中使用这个调用。</p>
<p><strong>清单 6. 关闭连接</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* To reuse the connection, use this line */</span></span><br><span class="line"><span class="built_in">BIO_reset</span>(bio);</span><br><span class="line"><span class="comment">/* To free it from memory, use this line */</span></span><br><span class="line"><span class="built_in">BIO_free_all</span>(bio);</span><br></pre></td></tr></table></figure>
<h2 id="建立安全连接">建立安全连接</h2>
<p>现在需要给出建立安全连接需要做哪些事情。唯一要改变的地方就是建立并进行连接。其他所有内容都是相同的。</p>
<p>安全连接要求在连接建立后进行握手。在握手过程中，服务器向客户机发送一个证书，然后，客户机根据一组可信任证书来核实该证书。它还将检查证书，以确保它没有过期。要 检验证书是可信任的，需要在连接建立之前提前加载一个可信任证书库。</p>
<p>只有在服务器发出请求时，客户机才会向服务器发送一个证书。该过程叫做客户机认证。使用证书，在客户机和服务器之间传递密码参数，以建立安全连接。尽管握手是在建立连接之后才进行的，但是客户机或服务器可以在任何时刻请求进行一次新的握手。</p>
<p><a href="">参考资料</a>部分中列出的 Netscasp 文章 和 RFC 2246 ，对握手以及建立安全连接的其他方面的知识进行了更详尽的论述。</p>
<h3 id="为安全连接进行设置">为安全连接进行设置</h3>
<p>为安全连接进行设置要多几行代码。同时需要有另一个类型为 SSL_CTX 的指针。该结构保存了一些 SSL 信息。您也可以利用它通过 BIO 库建立 SSL 连接。可以通过使用 SSL 方法函数调用 SSL_CTX_new 来创建这个结构，该方法函数通常是 SSLv23_client_method 。</p>
<p>还需要另一个 SSL 类型的指针来保持 SSL 连接结构（这是短时间就能完成的一些连接所必需的）。以后还可以用该 SSL 指针来检查连接信息或设置其他 SSL 参数。</p>
<p><strong>清单 7. 设置 SSL 指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SSL_CTX * ctx = <span class="built_in">SSL_CTX_new</span>(<span class="built_in">SSLv23_client_method</span>());</span><br><span class="line">SSL * ssl;</span><br></pre></td></tr></table></figure>
<h3 id="加载可信任证书库">加载可信任证书库</h3>
<p>在创建上下文结构之后，必须加载一个可信任证书库。这是成功验证每个证书所必需的。如果不能确认证书是可信任的，那么 OpenSSL 会将证书标记为无效（但连接仍可以继续）。</p>
<p>OpenSSL 附带了一组可信任证书。它们位于源文件树的 certs 目录中。 不过，每个证书都是一个独立的文件 —— 也就是说，需要单独加载每一个证书。在 certs 目录下，还有一个存放过期证书的子目录。试图加载这些证书将会出错。</p>
<p>如果您愿意，可以分别加载每一个文件，但为了简便起见，最新的 OpenSSL 发行版本的可信任证书通常存放在源代码档案文件中，这些档案文件位于名为“TrustStore.pem”的单个文件中。如果已经有了一个可信任证书库，并打算将它用于特定的项目中，那么只需使用您的文件替换清单 8 中的“TrustStore.pem”（或者使用单独的函数调用将它们全部加载）即可。</p>
<p>可以调用<code>int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile, const char *CApath);</code>来加载可信任证书库文件。这里要用到三个参数：上下文指针、可信任库文件的路径和文件名，以及证书所在目录的路径。必须指定可信任库文件或证书的目录。如果指定成功，则返回 1，如果遇到问题，则返回 0。</p>
<p><strong>清单 8. 加载信任库</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">SSL_CTX_load_verify_locations</span>(ctx, <span class="string">&quot;/path/to/TrustStore.pem&quot;</span>, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Handle failed load here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果打算使用目录存储可信任库，那么必须要以特定的方式命名文件。OpenSSL 文档清楚 地说明了应该如何去做，不过，OpenSSL 附带了一个名为 c_rehash 的工具， 它可以将文件夹配置为可用于 SSL_CTX_load_verify_locations 的路径参数。</p>
<p><strong>清单 9. 配置证书文件夹并使用它</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Use this at the command line */</span></span><br><span class="line">c_rehash /path/to/certfolder</span><br><span class="line"><span class="comment">/* then call this from within the application */</span></span><br><span class="line"><span class="keyword">if</span>(! <span class="built_in">SSL_CTX_load_verify_locations</span>(ctx, <span class="literal">NULL</span>, <span class="string">&quot;/path/to/certfolder&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Handle error here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了指定所有需要的验证证书，您可以根据需要命名任意数量的单独文件或文件夹。您还可以同时指定文件和文件夹。</p>
<h3 id="创建连接">创建连接</h3>
<p>将指向 SSL 上下文的指针作为唯一参数，使用 BIO_new_ssl_connect 创建 BIO 对象。还需要获得指向 SSL 结构的指针。在本文中，只将该指针用于 SSL_set_mode 函数。而这个函数是用来设置 SSL_MODE_AUTO_RETRY 标记的。使用这个选项进行设置，如果服务器突然希望进行一次新的握手，那么 OpenSSL 可以在后台处理它。如果没有这个选项，当服务器希望进行一次新的握手时，进行读或写操作都将返回一个错误，同时还会在该过程中设置 retry 标记。</p>
<p><strong>清单 10. 设置 BIO 对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bio = <span class="built_in">BIO_new_ssl_connect</span>(ctx);</span><br><span class="line"><span class="built_in">BIO_get_ssl</span>(bio, &amp; ssl);</span><br><span class="line"><span class="built_in">SSL_set_mode</span>(ssl, SSL_MODE_AUTO_RETRY);</span><br></pre></td></tr></table></figure>
<p>设置 SSL 上下文结构之后，就可以创建连接了。主机名是使用 BIO_set_conn_hostname 函数设置的。主机名和端口的指定格式与前面的相同。该函数还可以打开到主机的连接。为了确认已经成功打开连接，必须执行对 BIO_do_connect 的调用。该调用还将执行握手来建立安全连接。</p>
<p><strong>清单 11. 打开安全连接</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Attempt to connect */</span></span><br><span class="line">BIO_set_conn_hostname(bio, <span class="string">&quot;hostname:port&quot;</span>);</span><br><span class="line"><span class="comment">/* Verify the connection opened and perform the handshake */</span></span><br><span class="line"><span class="keyword">if</span>(BIO_do_connect(bio) &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Handle failed connection */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接建立后，必须检查证书，以确定它是否有效。实际上，OpenSSL 为我们完成了这项任务。如果证书有致命的问题（例如，哈希值无效），那么将无法建立连接。但是，如果证书的问题并不是致命的（当它已经过期或者尚不合法时），那么仍可以继续使用连接。</p>
<p>可以将 SSL 结构作为唯一参数，调用 SSL_get_verify_result 来查明证书是否通过了 OpenSSL 的检验。如果证书通过了包括信任检查在内的 OpenSSL 的内部检查，则返回 X509_V_OK。如果有地方出了问题，则返回一个错误代码，该代码被记录在命令行工具的 verify 选项下。</p>
<p>应该注意的是，验证失败并不意味着连接不能使用。是否应该使用连接取决于验证结果和安全方面的考虑。例如，失败的信任验证可能只是意味着没有可信任的证书。连接仍然可用，只是需要从思想上提高安全意识。</p>
<p><strong>清单 12. 检查证书是否有效</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(SSL_get_verify_result(ssl) != X509_V_OK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Handle the failed verification */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是所需要的全部操作。通常，与服务器进行通信都要使用 BIO_read 和 BIO_write 。并且只需调用 BIO_free_all 或 BIO_reset ，就可以关闭连接，具体调用哪一个方法取决于是否重用 BIO。</p>
<p>必须在结束应用程序之前的某个时刻释放 SSL 上下文结构。可以调用 SSL_CTX_free 来释放该结构。</p>
<p><strong>清单 13. 清除 SSL 上下文</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SSL_CTX_free(ctx);</span><br></pre></td></tr></table></figure>
<h2 id="错误检测">错误检测</h2>
<p>显然 OpenSSL 抛出了某种类型的错误。这意味着什么？首先，您需要得到错误代码本身； ERR_get_error 可以完成这项任务；然后，需要将错误代码转换为错误字符串，它是一个指向由 SSL_load_error_strings 或 ERR_load_BIO_strings 加载到内存中的永久字符串的指针。可以在一个嵌套调用中完成这项操作。</p>
<p>表 1 略述了从错误栈检索错误的方法。清单 24 展示了如何打印文本字符串中的最后一个 错误信息。</p>
<p><strong>表 1. 从栈中检索错误</strong></p>
<table>
	<tr>
		<th>ERR_reason_error_string</th>
		<th>返回一个静态字符串的指针，然后可以将字符串显示在屏幕上、写入文件，或者以任何您希望的方式进行处理</th>
	</tr>
	<tr>
		<th>ERR_lib_error_string</th>
		<th>指出错误发生在哪个库中</th>
	</tr>
	<tr>
		<th>ERR_func_error_string</th>
		<th>返回导致错误的 OpenSSL 函数</th>
	</tr>
</table>
<p><strong>清单 14. 打印出最后一个错误</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, ERR_reason_error_string(ERR_get_error()));</span><br></pre></td></tr></table></figure>
<p>您还可以让库给出预先格式化了的错误字符串。可以调用 ERR_error_string 来得到该字符串。该函数将错误代码和一个预分配的缓冲区作为参数。而这个缓冲区必须是 256 字节长。如果参数为 NULL，则 OpenSSL 会将字符串写入到一个长度为 256 字节的静态缓冲区中，并返回指向该缓冲区的 指针。否则，它将返回您给出的指针。如果您选择的是静态缓冲区选项，那么在下一次调用 ERR_error_string 时，该缓冲区会被覆盖。</p>
<p><strong>清单 15. 获得预先格式化的错误字符串</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ERR_error_string(ERR_get_error(), <span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>
<p>您还可以将整个错误队列转储到文件或 BIO 中。可以通过 ERR_print_errors 或 ERR_print_errors_fp 来实现这项操作。队列是以可读格式被转储的。第一个函数将队列发送到 BIO ，第二个函数将队列发送到 FILE 。字符串格式如下（引自 OpenSSL 文档）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[pid]:error:[error code]:[library name]:[function name]:[reason string]:[file name]:[line]:[optional text message]</span><br></pre></td></tr></table></figure>
<p>其中， [pid] 是进程 ID， [error code] 是一个 8 位十六进制代码， [file name] 是 OpenSSL 库中的源代码文件， [line]是源文件中的行号。</p>
<p><strong>清单 16. 转储错误队列</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ERR_print_errors_fp</span>(FILE *);</span><br><span class="line"><span class="built_in">ERR_print_errors</span>(BIO *);</span><br></pre></td></tr></table></figure>
<h2 id="开始做吧">开始做吧</h2>
<p>使用 OpenSSL 创建基本的连接并不困难，但是，当试着确定该如何去做时，文档可能是一个小障碍。本文向您介绍了一些基本概念，但 OpenSSL 还有很多灵活之处有待发掘，而且您还可能需要一些高级设置，以便项目能够充分利用 SSL 的功能。</p>
<p>本文中有两个样例。一个样例展示了到 <a href="http://www.verisign.com/">http://www.verisign.com/</a> 的非安全连接，另一个则展示了到 <a href="http://www.verisign.com/">http://www.verisign.com/</a> 的安全 SSL 连接。两者都是连接到服务器并下载其主页。它们没有进行任何安全检查，而且库中的所有设置都是默认值 —— 作为本文的一部分，应该只将这些用于教学目的。</p>
<p>在任何支持的平台上，源代码的编译都应该是非常容易的，不过我建议您使用最新版本的 OpenSSL。</p>
]]></content>
      <categories>
        <category>项目经历</category>
      </categories>
  </entry>
  <entry>
    <title>cJson 学习笔记</title>
    <url>/2019/08/02/project_experience/cJson%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>cJSON 的使用方法</h1>
<h2 id="JSON-格式简述">JSON 格式简述</h2>
<blockquote>
<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写，同时也易于机器解析和生成。它基于JavaScript（Standard ECMA-262 3rd Edition - December 1999）的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为理想的数据交换语言。（来自“开源中国”资料）。</p>
</blockquote>
<p>cJSON从名字可知，整个项目都是以极标准的C来写的，意思说，可以跨各种平台使用了。cJSON是一个超轻巧，携带方便，单文件，简单的可以作为ANSI-C标准的JSON解析器。</p>
<p>cJSON 开源项目位置：<a href="https://github.com/DaveGamble/cJSON">DaveGamble/cJSON</a><br>
更加详细的解释和示例请查看<a href="http://www.json.org/">主页</a>。</p>
<p>cJSON，目前来说，就只有两个文件，一个cJSON.c 一个cJSON.h文件。使用的时候，自己创建好一个main.c文件后，将头文件include进去。<br>
如果是在linux pc上，请使用以下命令进行编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc  *.c  cJSON.c    -lm</span><br></pre></td></tr></table></figure>
<p>记得编译时末尾链接libm库。</p>
<span id="more"></span>
<h2 id="JSON-结构体">JSON 结构体</h2>
<p>熟悉使用cJSON库函数可从cJSON结构体入手，cJSON结构体如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">cJSON</span> *<span class="title">next</span>,*<span class="title">prev</span>;</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">cJSON</span> *<span class="title">child</span>;</span>   </span><br><span class="line">    <span class="type">int</span>     type;   </span><br><span class="line">    <span class="type">char</span>    *valuestring;   </span><br><span class="line">    <span class="type">int</span>     valueint;  </span><br><span class="line">    <span class="type">double</span>  valuedouble;   </span><br><span class="line">    <span class="type">char</span>    *<span class="built_in">string</span>;   </span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure>
<p><strong>几点说明</strong></p>
<ol>
<li>cJOSN结构体为一个双向列表，并可通过child指针访问下一层。</li>
<li>type变量决定数据项类型（键的类型），数据项可以是字符串可以是整形，也可以是浮点型。如果是整形值的话可从valueint，如果是浮点型的话可从valuedouble取出，以此类推。</li>
<li>string可理解为节点的名称，综合此处的第2点可理解为“键”的名称。</li>
</ol>
<p>cJSON作为Json格式的解析库，其主要功能无非就是构建和解析Json格式了，用途就是一端将要发送的数据已cjson形式封装，然后发送，另一端收到此数据后，还是按cjson形式解析，就得到想要的数据了。<br>
</br></p>
<h2 id="封装">封装</h2>
<p>接下来直接通过几个例子代码，一一解析。</p>
<p>第一，创建json数据串。这数据串，可能是对象，也可能是数组，也可能是它们的各种组合，其中再加上一些键值对。有一点要先说明：它们的组合，符合父子继承格式－－这也是json数据串的特点。<br>
</br></p>
<p><strong>&lt;1&gt;</strong> 创建一个对象，并向这个对象里添加字符串和整型键值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        cJSON * usr;</span><br><span class="line">        cJSON *arry;</span><br><span class="line"> </span><br><span class="line">        usr=cJSON_CreateObject();   <span class="comment">//创建根数据对象</span></span><br><span class="line">        cJSON_AddStringToObject(usr,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;fengxin&quot;</span>);  <span class="comment">//加入键值，加字符串</span></span><br><span class="line">        cJSON_AddStringToObject(usr,<span class="string">&quot;passwd&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        cJSON_AddNumberToObject(usr,<span class="string">&quot;num&quot;</span>,<span class="number">1</span>);  <span class="comment">//加整数</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> *out = cJSON_Print(usr);   <span class="comment">//将json形式打印成正常字符串形式</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,out);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 释放内存  </span></span><br><span class="line">        cJSON_Delete(usr);  </span><br><span class="line">        <span class="built_in">free</span>(out); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;:	&quot;fengxin&quot;,</span><br><span class="line">	&quot;passwd&quot;:	&quot;123&quot;,</span><br><span class="line">	&quot;num&quot;:	1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>若干说明</strong></p>
<ol>
<li>cJSON_CreateObject函数可创建一个根数据项，之后便可向该根数据项中添加string或int等内容,返回的是一个 cJSON的指针，注意，在这个指针用完了以后，需要手工调用 cJSON_Delete(root); 进行内存回收。</li>
<li>cJSON_AddNumberToObject向节点中添加子节点，例如此处添加name节点，节点值为字符串&quot;fengxin&quot;</li>
<li>需要注意的是  json 格式的数据，虽然也是一个字符串的样子，但这个时候还是无法当成普通的字符串进行使用，需要调用 cJSON_PrintUnformatted(root) 或者 cJSON_Print(root);来将json对象转换成普通的字符串，并且都是以该json对象的根为基点。两个API的区别即是：一个是没有格式的：也就是转换出的字符串中间不会有&quot;\n&quot; &quot;\t&quot;之类的东西存在，而cJSON_Print(root);打印出来是人看起来很舒服的格式。</li>
<li>因为函数内部封装有malloc函数，所以使用free函数释放被out占用的内存空间</li>
</ol>
<p><strong>&lt;2&gt;</strong> 创建一个数组，并向数组添加一个字符串和一个数字：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">create_js</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    cJSON *root, *js_body;</span><br><span class="line">    root = cJSON_CreateArray();</span><br><span class="line">    cJSON_AddItemToArray(root, cJSON_CreateString(<span class="string">&quot;Hello world&quot;</span>));</span><br><span class="line">    cJSON_AddItemToArray(root, cJSON_CreateNumber(<span class="number">10</span>)); </span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//      char *s = cJSON_Print(root);</span></span><br><span class="line">        <span class="type">char</span> *s = cJSON_PrintUnformatted(root);</span><br><span class="line">        <span class="keyword">if</span>(s)&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot; %s \n&quot;</span>,s);</span><br><span class="line">            <span class="built_in">free</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        cJSON_Delete(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    create_js();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&quot;Hello world&quot;,10]</span><br></pre></td></tr></table></figure>
</br>
</br>
<p><strong>&lt;3&gt;</strong> 对象里面包括一个数组，数组里面包括对象，对象里面再添加一个字符串和一个数字：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">create_js</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    cJSON *root, *js_body, *js_list;</span><br><span class="line">    root = cJSON_CreateObject();</span><br><span class="line">    cJSON_AddItemToObject(root,<span class="string">&quot;body&quot;</span>, js_body = cJSON_CreateArray());</span><br><span class="line">    cJSON_AddItemToArray(js_body, js_list = cJSON_CreateObject());</span><br><span class="line">    cJSON_AddStringToObject(js_list,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;fengxin&quot;</span>);</span><br><span class="line">    cJSON_AddNumberToObject(js_list,<span class="string">&quot;status&quot;</span>,<span class="number">100</span>);</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//        char *s = cJSON_Print(root);</span></span><br><span class="line">        <span class="type">char</span> *s = cJSON_PrintUnformatted(root);</span><br><span class="line">        <span class="keyword">if</span>(s)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %s \n&quot;</span>,s);</span><br><span class="line">            <span class="built_in">free</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        cJSON_Delete(root);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    create_js();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;body&quot;:[&#123;&quot;name&quot;:&quot;fengxin&quot;,&quot;status&quot;:100&#125;]&#125;</span><br></pre></td></tr></table></figure>
<p><strong>&lt;4&gt;</strong> 其他组合就依次类推，只要搞清楚父子关系即可。随便嵌套随便玩。不再贴了。<br>
</br></p>
<h2 id="解析">解析</h2>
<p>解析数据包的过程和组装数据包的过程相反</p>
<p><strong>处理流程：</strong></p>
<p><strong>&lt;1&gt;</strong> 先将普通的json串处理成json对象，也就是所谓的创建json root的过程，只有一行代码即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cJSON *root;</span><br><span class="line">root = cJSON_Parse(js_string);</span><br></pre></td></tr></table></figure>
<p><strong>&lt;2&gt;</strong> 开始拿关键字，但如果关键字还有父层或者祖层，那就需要先从父层开拿，所谓剥洋葱是也！先说没有父层的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">out=&#123;\<span class="string">&quot;name\&quot;:\&quot;fengxin\&quot;,\&quot;passwd\&quot;:\&quot;123\&quot;,\&quot;num\&quot;:1&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="string">#include&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="string">#include&lt;string.h&gt;</span></span><br><span class="line"><span class="string">#include&quot;</span>cJSON.h<span class="string">&quot;</span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    cJSON *json,*json_name,*json_passwd,*json_num;</span></span><br><span class="line"><span class="string">    char* out=&quot;</span>&#123;\<span class="string">&quot;name\&quot;:\&quot;fengxin\&quot;,\&quot;passwd\&quot;:\&quot;123\&quot;,\&quot;num\&quot;:1&#125;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    json = cJSON_Parse(out); <span class="comment">//解析成json形式</span></span><br><span class="line">    json_name = cJSON_GetObjectItem( json , <span class="string">&quot;name&quot;</span> );  <span class="comment">//获取键值内容</span></span><br><span class="line">    json_passwd = cJSON_GetObjectItem( json , <span class="string">&quot;passwd&quot;</span> );</span><br><span class="line">    json_num = cJSON_GetObjectItem( json , <span class="string">&quot;num&quot;</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:%s,passwd:%s,num:%d\n&quot;</span>,json_name-&gt;valuestring,json_passwd-&gt;valuestring,json_num-&gt;valueint);</span><br><span class="line"> </span><br><span class="line">    cJSON_Delete(json);  <span class="comment">//释放内存 </span></span><br><span class="line">    <span class="built_in">free</span>(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>显示结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name:fengxin,passwd:123,num:1</span><br></pre></td></tr></table></figure>
<p>需要注意的是： 上面的type 已经在cJSON.h里面定义好了，有自己的意义。如果是在严格的场所，应该先判定该 item的type，然后再考虑去拿值。而如果有父层的话，无非就是接着向下拿就是了。</p>
<p><strong>&lt;3&gt;</strong> 处理这串数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">out=&#123;\<span class="string">&quot;list\&quot;:&#123;\&quot;name\&quot;:\&quot;xiao hong\&quot;,\&quot;age\&quot;:10&#125;,\&quot;other\&quot;:&#123;\&quot;name\&quot;:\&quot;hua hua\&quot;&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">char *s = &quot;</span>&#123;\<span class="string">&quot;list\&quot;:&#123;\&quot;name\&quot;:\&quot;xiao hong\&quot;,\&quot;age\&quot;:10&#125;,\&quot;other\&quot;:&#123;\&quot;name\&quot;:\&quot;hua hua\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">cJSON *root = cJSON_Parse(s);</span><br><span class="line"><span class="keyword">if</span>(!root) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get root faild !\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> cJSON *js_list = cJSON_GetObjectItem(root, <span class="string">&quot;list&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_list) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no list!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;list type is %d\n&quot;</span>,js_list-&gt;type);</span><br><span class="line"></span><br><span class="line">cJSON *name = cJSON_GetObjectItem(js_list, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!name) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No name !\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name type is %d\n&quot;</span>,name-&gt;type);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name is %s\n&quot;</span>,name-&gt;valuestring);</span><br><span class="line"></span><br><span class="line">cJSON *age = cJSON_GetObjectItem(js_list, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!age) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no age!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;age type is %d\n&quot;</span>, age-&gt;type);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;age is %d\n&quot;</span>,age-&gt;valueint);</span><br><span class="line"></span><br><span class="line">cJSON *js_other = cJSON_GetObjectItem(root, <span class="string">&quot;other&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no list!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;list type is %d\n&quot;</span>,js_other-&gt;type);</span><br><span class="line"></span><br><span class="line">cJSON *js_name = cJSON_GetObjectItem(js_other, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_name) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No name !\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name type is %d\n&quot;</span>,js_name-&gt;type);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name is %s\n&quot;</span>,js_name-&gt;valuestring);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(root) &#123;</span><br><span class="line">    cJSON_Delete(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>打印结果:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list type is 6</span><br><span class="line">name type is 4</span><br><span class="line">name is xiao hong</span><br><span class="line">age type is 3</span><br><span class="line">age is 10</span><br><span class="line">list type is 6</span><br><span class="line">name type is 4</span><br><span class="line">name is hua hua</span><br></pre></td></tr></table></figure>
<p>所谓子子孙孙无穷尽也，按照上面那个方法推下去即可。</p>
<p><strong>&lt;4&gt;</strong> json里数组怎么取？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;\<span class="string">&quot;list\&quot;:[\&quot;name1\&quot;,\&quot;name2\&quot;]&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main(int argc, char **argv)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">char *s = &quot;</span>&#123;\<span class="string">&quot;list\&quot;:[\&quot;name1\&quot;,\&quot;name2\&quot;]&#125;&quot;</span>;</span><br><span class="line">cJSON *root = cJSON_Parse(s);</span><br><span class="line"><span class="keyword">if</span>(!root) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get root faild !\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cJSON *js_list = cJSON_GetObjectItem(root, <span class="string">&quot;list&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_list)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no list!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> array_size = cJSON_GetArraySize(js_list);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array size is %d\n&quot;</span>,array_size);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">cJSON *item;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; array_size; i++) &#123;</span><br><span class="line">    item = cJSON_GetArrayItem(js_list, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;item type is %d\n&quot;</span>,item-&gt;type);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,item-&gt;valuestring);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(root)</span><br><span class="line">    cJSON_Delete(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>&lt;5&gt;</strong> 如果json数组里面又搞了对象怎么办？</p>
<p>不怕搞对象，就怕这样搞对象？ 无他，就是稍微复杂了一点，全是体力活儿：</p>
<ol>
<li>既然是数组里面，那肯定要先测量数组的大小，然后根据大小循环拿；</li>
<li>拿到一个数组项，然后把这个项先转化成普通的json字符串，也就是 char *s 能接受的。</li>
<li>再次将这个json字符串，转化成一个json对象。</li>
<li>按照拿普通对象中的东西那样开干就行了。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;\<span class="string">&quot;list\&quot;:[&#123;\&quot;name\&quot;:\&quot;xiao hong\&quot;,\&quot;age\&quot;:10&#125;,&#123;\&quot;name\&quot;:\&quot;hua hua\&quot;,\&quot;age\&quot;:11&#125;]&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">list 是一个数组，数组里面有两个对象，那么代码如下</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main(int argc, char **argv)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">char *s = &quot;</span>&#123;\<span class="string">&quot;list\&quot;:[&#123;\&quot;name\&quot;:\&quot;xiao hong\&quot;,\&quot;age\&quot;:10&#125;,&#123;\&quot;name\&quot;:\&quot;hua hua\&quot;,\&quot;age\&quot;:11&#125;]&#125;&quot;</span>;</span><br><span class="line">cJSON *root = cJSON_Parse(s);</span><br><span class="line"><span class="keyword">if</span>(!root) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get root faild !\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cJSON *js_list = cJSON_GetObjectItem(root, <span class="string">&quot;list&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!js_list)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no list!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> array_size = cJSON_GetArraySize(js_list);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array size is %d\n&quot;</span>,array_size);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">cJSON *item,*it, *js_name, *js_age;</span><br><span class="line"><span class="type">char</span> *p  = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; array_size; i++) &#123;</span><br><span class="line">    item = cJSON_GetArrayItem(js_list, i);</span><br><span class="line">    <span class="keyword">if</span>(!item) &#123;</span><br><span class="line">        <span class="comment">//TODO...</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = cJSON_PrintUnformatted(item);</span><br><span class="line">    it = cJSON_Parse(p);</span><br><span class="line">    <span class="keyword">if</span>(!it)</span><br><span class="line">        <span class="keyword">continue</span> ;</span><br><span class="line">    js_name = cJSON_GetObjectItem(it, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name is %s\n&quot;</span>,js_name-&gt;valuestring);</span><br><span class="line">    js_age = cJSON_GetObjectItem(it, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age is %d\n&quot;</span>,js_age-&gt;valueint);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(root)</span><br><span class="line">    cJSON_Delete(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>项目经历</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake 学习笔记</title>
    <url>/2019/05/24/project_experience/cmake%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>cmake 学习笔记</h1>
<blockquote>
<ul>
<li>最大的Qt4程序群(KDE4)采用cmake作为构建系统</li>
<li>Qt4的python绑定(pyside)采用了cmake作为构建系统</li>
<li>开源的图像处理库 opencv 采用cmake 作为构建系统</li>
<li>…</li>
</ul>
</blockquote>
<p>看来不学习一下cmake是不行了，一点一点来吧，找个最简单的C程序，慢慢复杂化，试试看：</p>
<table>
<thead>
<tr>
<th style="text-align:center">example</th>
<th style="text-align:left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">例子1</td>
<td style="text-align:left">单个源文件 main.c</td>
</tr>
<tr>
<td style="text-align:center">例子2</td>
<td style="text-align:left">==&gt;分解成多个 main.c hello.h hello.c</td>
</tr>
<tr>
<td style="text-align:center">例子3</td>
<td style="text-align:left">==&gt;先生成一个静态库，链接该库</td>
</tr>
<tr>
<td style="text-align:center">例子4</td>
<td style="text-align:left">==&gt;将源文件放置到不同的目录</td>
</tr>
<tr>
<td style="text-align:center">例子5</td>
<td style="text-align:left">==&gt;控制生成的程序和库所在的目录</td>
</tr>
<tr>
<td style="text-align:center">例子6</td>
<td style="text-align:left">==&gt;使用动态库而不是静态库</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h1>例子一</h1>
<p>一个经典的C程序，如何用cmake来进行构建程序呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!/n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写一个 CMakeList.txt 文件(可看做cmake的工程文件)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line">set(SRC_LIST main.c)</span><br><span class="line">add_executable(hello $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>
<p>然后，建立一个任意目录（比如本目录下创建一个build子目录），在该build目录下调用cmake</p>
<blockquote>
<p>注意：为了简单起见，我们从一开始就采用cmake的 out-of-source 方式来构建（即生成中间产物与源代码分离），并始终坚持这种方法，这也就是此处为什么单独创建一个目录，然后在该目录下执行 cmake 的原因</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmake .. -G<span class="string">&quot;NMake Makefiles&quot;</span></span><br><span class="line">nmake</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake .. -G<span class="string">&quot;MinGW Makefiles&quot;</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>即可生成可执行程序 hello(.exe)</p>
<p>目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">| </span><br><span class="line">+--- main.c</span><br><span class="line">+--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">/--+ build/</span><br><span class="line">   |</span><br><span class="line">   +--- hello.exe</span><br></pre></td></tr></table></figure>
<p>cmake 真的不太好用哈，使用cmake的过程，本身也就是一个编程的过程，只有多练才行。</p>
<p>我们先看看：前面提到的这些都是什么呢？</p>
<h2 id="CMakeList-txt">CMakeList.txt</h2>
<p>第一行<strong>project</strong>不是强制性的，但最好始终都加上。这一行会引入两个变量</p>
<ul>
<li>HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR</li>
</ul>
<p>同时，cmake自动定义了两个等价的变量</p>
<ul>
<li>PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR</li>
</ul>
<p>因为是out-of-source方式构建，所以我们要时刻区分这两个变量对应的目录<br>
可以通过<strong>message</strong>来输出变量的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">message(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>set</strong> 命令用来设置变量<br>
<strong>add_exectuable</strong> 告诉工程生成一个可执行文件。<br>
<strong>add_library</strong> 则告诉生成一个库文件。</p>
<ul>
<li>注意：CMakeList.txt 文件中，命令名字是不区分大小写的，而参数和变量是大小写相关的。</li>
</ul>
<h2 id="cmake命令">cmake命令</h2>
<p>cmake 命令后跟一个路径(…)，用来指出 CMakeList.txt 所在的位置。</p>
<p>由于系统中可能有多套构建环境，我们可以通过-G来制定生成哪种工程文件，通过 cmake -h 可得到详细信息。</p>
<p>要显示执行构建过程中详细的信息(比如为了得到更详细的出错信息)，可以在CMakeList.txt内加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET( CMAKE_VERBOSE_MAKEFILE on )</span><br></pre></td></tr></table></figure>
<p>或者执行make时</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ make VERBOSE=1</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> VERBOSE=1</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>
<h1>例子二</h1>
<p>一个源文件的例子一似乎没什么意思，拆成3个文件再试试看：</p>
<ul>
<li>hello.h 头文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DBZHANG_HELLO_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBZHANG_HELLO_</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//DBZHANG_HELLO_</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>hello.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Hello %s!/n&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>main.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    hello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后准备好CMakeList.txt 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line">set(SRC_LIST main.c hello.c)</span><br><span class="line">add_executable(hello $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>
<p>执行cmake的过程同上，目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">| </span><br><span class="line">+--- main.c</span><br><span class="line">+--- hello.h</span><br><span class="line">+--- hello.c</span><br><span class="line">+--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">/--+ build/</span><br><span class="line">   |</span><br><span class="line">   +--- hello.exe</span><br></pre></td></tr></table></figure>
<p>例子很简单，没什么可说的。</p>
<h1>例子三</h1>
<p>接前面的例子，我们将 hello.c 生成一个库，然后再使用会怎么样？<br>
改写一下前面的CMakeList.txt文件试试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line">set(LIB_SRC hello.c)</span><br><span class="line">set(APP_SRC main.c)</span><br><span class="line">add_library(libhello $&#123;LIB_SRC&#125;)</span><br><span class="line">add_executable(hello $&#123;APP_SRC&#125;)</span><br><span class="line">target_link_libraries(hello libhello)</span><br></pre></td></tr></table></figure>
<p>和前面相比，我们添加了一个新的目标 libhello，并将其链接进hello程序<br>
然后想前面一样，运行cmake，得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">| </span><br><span class="line">+--- main.c</span><br><span class="line">+--- hello.h</span><br><span class="line">+--- hello.c</span><br><span class="line">+--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">/--+ build/</span><br><span class="line">   |</span><br><span class="line">   +--- hello.exe</span><br><span class="line">   +--- libhello.lib</span><br></pre></td></tr></table></figure>
<p>里面有一点不爽，对不？</p>
<ul>
<li>因为我的可执行程序(add_executable)占据了 hello 这个名字，所以 add_library 就不能使用这个名字了</li>
<li>然后，我们去了个libhello 的名字，这将导致生成的库为 libhello.lib(或 liblibhello.a)，很不爽</li>
<li>想生成 hello.lib(或libhello.a) 怎么办?</li>
</ul>
<p>添加一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_target_properties(libhello PROPERTIES OUTPUT_NAME &quot;hello&quot;)</span><br></pre></td></tr></table></figure>
<p>就可以了</p>
<h1>例子四</h1>
<p>在前面，我们成功地使用了库，可是源代码放在同一个路径下，还是不太正规，怎么办呢？分开放呗<br>
我们期待是这样一种结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">|</span><br><span class="line">+--- CMakeList.txt</span><br><span class="line">+--+ src/</span><br><span class="line">|  |</span><br><span class="line">|  +--- main.c</span><br><span class="line">|  /--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">+--+ libhello/</span><br><span class="line">|  |</span><br><span class="line">|  +--- hello.h</span><br><span class="line">|  +--- hello.c</span><br><span class="line">|  /--- CMakeList.txt</span><br><span class="line">|</span><br><span class="line">/--+ build/</span><br></pre></td></tr></table></figure>
<p>哇，现在需要3个CMakeList.txt 文件了，每个源文件目录都需要一个，还好,每一个都不是太复杂</p>
<ul>
<li>顶层的CMakeList.txt 文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line">add_subdirectory(src)</span><br><span class="line">add_subdirectory(libhello)</span><br></pre></td></tr></table></figure>
<ul>
<li>src 中的 CMakeList.txt 文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/libhello)</span><br><span class="line">set(APP_SRC main.c)</span><br><span class="line">add_executable(hello $&#123;APP_SRC&#125;)</span><br><span class="line">target_link_libraries(hello libhello)</span><br></pre></td></tr></table></figure>
<ul>
<li>libhello 中的 CMakeList.txt 文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(LIB_SRC hello.c)</span><br><span class="line">add_library(libhello $&#123;LIB_SRC&#125;)</span><br><span class="line">set_target_properties(libhello PROPERTIES OUTPUT_NAME &quot;hello&quot;)</span><br></pre></td></tr></table></figure>
<p>恩，和前面一样，建立一个build目录，在其内运行cmake，然后可以得到</p>
<ul>
<li>build/src/hello.exe</li>
<li>build/libhello/hello.lib</li>
</ul>
<p>回头看看，这次多了点什么，顶层的 CMakeList.txt 文件中使用 add_subdirectory 告诉cmake去子目录寻找新的CMakeList.txt 子文件<br>
在 src 的 CMakeList.txt 文件中，新增加了include_directories，用来指明头文件所在的路径。</p>
<h1>例子五</h1>
<p>前面还是有一点不爽：如果想让可执行文件在 bin 目录，库文件在 lib 目录怎么办？</p>
<p>就像下面显示的一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ build/</span><br><span class="line">|</span><br><span class="line">+--+ bin/</span><br><span class="line">|  |</span><br><span class="line">|  /--- hello.exe</span><br><span class="line">|</span><br><span class="line">/--+ lib/</span><br><span class="line">   |</span><br><span class="line">   /--- hello.lib</span><br></pre></td></tr></table></figure>
<ul>
<li>一种办法：修改顶级的 CMakeList.txt 文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line">add_subdirectory(src bin)</span><br><span class="line">add_subdirectory(libhello lib)</span><br></pre></td></tr></table></figure>
<p>不是build中的目录默认和源代码中结构一样么，我们可以指定其对应的目录在build中的名字。<br>
这样一来：build/src 就成了 build/bin 了，可是除了 hello.exe，中间产物也进来了。还不是我们最想要的。<br>
另一种方法：不修改顶级的文件，修改其他两个文件</p>
<ul>
<li>src/CMakeList.txt 文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/libhello)</span><br><span class="line">#link_directories($&#123;PROJECT_BINARY_DIR&#125;/lib)</span><br><span class="line">set(APP_SRC main.c)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)</span><br><span class="line">add_executable(hello $&#123;APP_SRC&#125;)</span><br><span class="line">target_link_libraries(hello libhello)</span><br></pre></td></tr></table></figure>
<ul>
<li>libhello/CMakeList.txt 文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(LIB_SRC hello.c)</span><br><span class="line">add_library(libhello $&#123;LIB_SRC&#125;)</span><br><span class="line">set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)</span><br><span class="line">set_target_properties(libhello PROPERTIES OUTPUT_NAME &quot;hello&quot;)</span><br></pre></td></tr></table></figure>
<h1>例子六</h1>
<p>在例子三至五中，我们始终用的静态库，那么用动态库应该更酷一点吧。 试着写一下<br>
如果不考虑windows下，这个例子应该是很简单的，只需要在上个例子的 libhello/CMakeList.txt 文件中的add_library命令中加入一个SHARED参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_library(libhello SHARED $&#123;LIB_SRC&#125;)</span><br></pre></td></tr></table></figure>
<p>可是，我们既然用cmake了，还是兼顾不同的平台吧，于是，事情有点复杂：</p>
<ul>
<li>修改 hello.h 文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DBZHANG_HELLO_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBZHANG_HELLO_</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _WIN32</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> LIBHELLO_BUILD</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> LIBHELLO_API __declspec(dllexport)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> LIBHELLO_API __declspec(dllimport)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LIBHELLO_API</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">LIBHELLO_API <span class="type">void</span> <span class="title function_">hello</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//DBZHANG_HELLO_</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改 libhello/CMakeList.txt 文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(LIB_SRC hello.c)</span><br><span class="line">add_definitions(&quot;-DLIBHELLO_BUILD&quot;)</span><br><span class="line">add_library(libhello SHARED $&#123;LIB_SRC&#125;)</span><br><span class="line">set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)</span><br><span class="line">set_target_properties(libhello PROPERTIES OUTPUT_NAME &quot;hello&quot;)</span><br></pre></td></tr></table></figure>
<p>恩，剩下来的工作就和原来一样了。</p>
]]></content>
      <categories>
        <category>项目经历</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>md5 工具使用说明</title>
    <url>/2021/02/21/project_experience/md5_mysql/</url>
    <content><![CDATA[<h1>md5 工具使用说明</h1>
<blockquote>
<p>相关技术栈：linux、mysql</p>
</blockquote>
<h2 id="STEP-1">STEP 1</h2>
<p>在车型数据库里，运行这两条sql语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `std_name_modify_record` (</span><br><span class="line">	`id` <span class="type">INT</span> ( <span class="number">11</span> ) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	`md5` <span class="type">VARCHAR</span> ( <span class="number">40</span> ) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5值&#x27;</span>,</span><br><span class="line">	`ori_std_name` <span class="type">VARCHAR</span> ( <span class="number">32</span> ) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`new_std_name` <span class="type">VARCHAR</span> ( <span class="number">32</span> ) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`creator` <span class="type">VARCHAR</span> ( <span class="number">64</span> ) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;创建者&#x27;</span>,</span><br><span class="line">	`create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">	`updator` <span class="type">VARCHAR</span> ( <span class="number">64</span> ) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;操作人&#x27;</span>,</span><br><span class="line">	`update_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY ( `id` ),</span><br><span class="line">	<span class="keyword">UNIQUE</span> KEY `uniq_md5` ( `md5` ) <span class="keyword">USING</span> BTREE,</span><br><span class="line">	KEY `idx_create_time` ( `create_time` ) <span class="keyword">USING</span> BTREE,</span><br><span class="line">KEY `idx_update_time` ( `update_time` ) <span class="keyword">USING</span> BTREE </span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8 COMMENT <span class="operator">=</span> <span class="string">&#x27;标名修改记录表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `oe2modelcatalog` <span class="keyword">ADD</span> `md5` <span class="type">VARCHAR</span> ( <span class="number">40</span> ) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5值&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>建立标名修改记录表，并在行记录表里增加md5字段。</p>
<span id="more"></span>
<h2 id="STEP-2">STEP 2</h2>
<p>在使用标名md5工具之前要确保oe2modelcatalog表内，有md5字段，但是不能有索引。</p>
<p><img src="http://pic.colliexyy.com/16566674396390.jpg" alt=""></p>
<p>如果有索引，需要运行这条sql语句来确保索引被删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `oe2modelcatalog` <span class="keyword">DROP</span> INDEX `idx_md5`</span><br></pre></td></tr></table></figure>
<h2 id="STEP-3">STEP 3</h2>
<p>修改md5工具的配置</p>
<p><img src="http://pic.colliexyy.com/16566674396440.jpg" alt=""></p>
<ul>
<li>[ ] 1. 修改成你要计算md5的数据库信息，例如10.118.50.50,加上密码信息</li>
<li>[ ] 2. 修改成你要跑的表，例如vehicle_mazda(可省略该步骤)</li>
<li>[ ] 3. 修改成你要跑的品牌，例如BENZ</li>
<li>[ ] 4. 修改两个值为0，即为全表刷新，重新计算。不用修改</li>
</ul>
<h2 id="STEP-4">STEP 4</h2>
<p>运行md5工具</p>
<p>保证md5.exe文件和config.json文件在同一文件夹下，双击即可运行，或者在cmd命令行中，调用该exe文件也可，推荐使用cmd方式。</p>
<p><img src="http://pic.colliexyy.com/16566674396465.jpg" alt=""></p>
<p><img src="http://pic.colliexyy.com/16566674396490.jpg" alt=""></p>
<p>log文件是自动生成的，不用管。</p>
<h2 id="STEP-5">STEP 5</h2>
<p>加索引</p>
<p>md5生成完毕后要加回该字段的索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `oe2modelcatalog` <span class="keyword">ADD</span> INDEX   idx_md5 ( `md5` );</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>项目经历</category>
      </categories>
  </entry>
  <entry>
    <title>koala 学习笔记</title>
    <url>/2018/12/11/project_experience/koala/</url>
    <content><![CDATA[<h1>koala 学习笔记</h1>
<blockquote>
<p>相关技术栈：linux、golang</p>
</blockquote>
<h2 id="编写IDL">编写IDL</h2>
<p>在业务项目目录下创建helloworld目录，进入该目录，然后创建编辑hello.thrift，该文件用来生成基本框架。输入以下内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Result &#123;      <span class="comment">//定义了一个Result结构体，为接口返回的结构体数据</span></span><br><span class="line">    <span class="number">1</span>: <span class="type">string</span> response,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service HelloService &#123;    <span class="comment">//定义了一个服务，只有一个接口↓</span></span><br><span class="line">    Result HelloWorld(<span class="number">1</span>:<span class="type">string</span> name);  <span class="comment">//HelloWorld,该接口接收一个string参数，返回一个Result结构体，见上。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成框架代码">生成框架代码</h2>
<p>键入如下命令生成框架代码，请下载最新版本的<a href="http://micode.be.xiaomi.com/soa/soa_tools">thrift工具</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/path/to/soa_tools/thrift --gen go --packagePath micode.be.xiaomi.com/systech/helloworld hello.thrift</span><br></pre></td></tr></table></figure>
<h2 id="编译执行">编译执行</h2>
<p>执行 ./build.sh 进行编译，编译成功后，生成的程序在bin目录下。</p>
<span id="more"></span>
<h2 id="自动构建">自动构建</h2>
<p>启动自动构建程序(auto_build.sh)，自动构建程序会实时检测项目目录下源码的是否变更，如果有变更将自动进行编译、重启程序。</p>
<h2 id="了解框架代码结构">了解框架代码结构</h2>
<p>生成的框架代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── auto_build.sh                           //自动构建脚本</span><br><span class="line">├── bin</span><br><span class="line">│   └── HelloService</span><br><span class="line">├── build.sh                                //编译脚本</span><br><span class="line">├── config</span><br><span class="line">│   ├── scm_config.ini                      </span><br><span class="line">│   ├── scm_config.ini.online.env           //线上配置</span><br><span class="line">│   └── scm_config.ini.test.env             //测试环境配置</span><br><span class="line">├── hello.thrift                            //接口描述文件</span><br><span class="line">├── package.sh                              //编译打包脚本，使用请参考：http://mis.n.mi.com/koala/publish/package.html</span><br><span class="line">├── README</span><br><span class="line">├── run                                     //启动脚本</span><br><span class="line">├── run.sh                                  //带supervise的启动脚本</span><br><span class="line">├── framework                               //框架基础代码（无需更改）</span><br><span class="line">│   └── app</span><br><span class="line">│       ├── app.go</span><br><span class="line">│       ├── config.go</span><br><span class="line">│       ├── generate.go</span><br><span class="line">│       ├── global.go</span><br><span class="line">│       ├── initDb.go</span><br><span class="line">│       ├── initRabbitmq.go</span><br><span class="line">│       ├── initRedis.go</span><br><span class="line">│       ├── initRedisMock.go</span><br><span class="line">│       ├── initSqlMock.go</span><br><span class="line">│       ├── manager.go</span><br><span class="line">│       ├── plugin.go</span><br><span class="line">│       ├── register.go</span><br><span class="line">│       ├── rpc.go</span><br><span class="line">│       └── user_config.go</span><br><span class="line">├── hello                                   //网络相关基础代码，无需更改</span><br><span class="line">│   ├── constants.go</span><br><span class="line">│   ├── helloservice.go</span><br><span class="line">│   ├── helloservice_host_wrapper.go</span><br><span class="line">│   ├── hello_service-remote</span><br><span class="line">│   │   └── hello_service-remote.go</span><br><span class="line">│   ├── helloservice_wrapper.go</span><br><span class="line">│   └── ttypes.go</span><br><span class="line">├── main</span><br><span class="line">│   ├── HelloService.go</span><br><span class="line">│   ├── HelloWorld_handler.go               //HelloWorld的入口文件，需要业务实现</span><br><span class="line">│   ├── hook.go                             //框架各个阶段的回调接口，可以实现自定义功能</span><br><span class="line">│   └── main.go</span><br><span class="line">└── model                                   //业务model层</span><br><span class="line">└── supervise</span><br><span class="line">    └── supervise</span><br><span class="line">└── glide.yaml                              // 依赖说明文件</span><br><span class="line">└── glide.lock                              // 依赖版本锁文件</span><br></pre></td></tr></table></figure>
<p>对于 thrift IDL 中定义的每一个接口，会在 main 目录单独一个代码文件，并在接口名后面加上_handler后缀。 例如，对于 hello.thrift 定义的 HelloWorld 接口，生成的实现文件为 main/HelloWorld_handler.go。</p>
<h2 id="实现-HelloWorld-接口">实现 HelloWorld 接口</h2>
<p>打开 main/HelloWorld_handler.go文件，框架生成的源代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;micode.be.xiaomi.com/systech/helloworld/hello&quot;</span></span><br><span class="line">    <span class="string">&quot;micode.be.xiaomi.com/systech/soa/context&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//ctx 用来记录请求在框架运行中当中的上下文，比如traceid以及appid等公共信息</span></span><br><span class="line"><span class="comment">//name 也就是我们IDL中定义的参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloServiceHandler)</span></span> HelloWorld(ctx *context.XContext, name <span class="type">string</span>) (r *hello.Result_, errRet <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口返回一个hello.Result结构，以及若有错误产生，返回一个errRet。<br>
我们记得，hello.Result_结构体的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Result_ <span class="keyword">struct</span> &#123;</span><br><span class="line">    Response <span class="type">string</span> <span class="string">`thrift:&quot;response,1&quot; json:&quot;response&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当处理正常时，返回一个Response字符串。因此，我们的HelloWorld接口非常简单，实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;micode.be.xiaomi.com/systech/helloworld/hello&quot;</span></span><br><span class="line">    <span class="string">&quot;micode.be.xiaomi.com/systech/soa/context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HelloServiceHandler)</span></span> HelloWorld(context *context.XContext, name <span class="type">string</span>) (r *hello.Result_, err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">    r = &amp;hello.Result_&#123;&#125;</span><br><span class="line">    r.Response = fmt.Sprintf(<span class="string">&quot;hello world,%s&quot;</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置组名和服务名">配置组名和服务名</h2>
<p>启动服务之前必须先在 config/scm_config.ini 中配置组名和服务名。<br>
打开 config/scm_config.ini，在group和service两个字段，填入相应的信息。如下所示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">;基础配置</span><br><span class="line">[xbase]</span><br><span class="line">config_type=<span class="built_in">local</span> <span class="comment">#local or etcd</span></span><br><span class="line">config_addr=http://etcd.test.mi.com <span class="comment">#配置中心地址</span></span><br><span class="line">;项目所在的小组名,一定要配置，不配置将会panic，详情请参见mis.n.mi.com</span><br><span class="line">group=systech</span><br><span class="line">;项目的服务名，一定要配置，不配置将会panic，详情请参见mis.n.mi.com </span><br><span class="line">service=hello</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>(注)服务名：服务开发完了之后，通过SOA平台进行注册，注册服务的时候会分配一个唯一的服务名。</p>
<h2 id="启动服务HelloService">启动服务HelloService</h2>
<p>使用如下命令进行启动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./bin/HelloService</span><br></pre></td></tr></table></figure>
<h1>调用和测试</h1>
<h2 id="生成SDK">生成SDK</h2>
<p>通过以下命令，生成Golang的SDK：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/path/to/soa_tools/thrift --gen go --packagePath micode.be.xiaomi.com/your/project ./hello.thrift</span><br></pre></td></tr></table></figure>
<p>生成的SDK在当前目录sdk/v3/目录下。</p>
<p><strong>如果基于 koala v3 开发的项目需要生成 sdk 给 koala v1 或 v2 的项目使用，请使用命令：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/path/to/soa_tools/thrift --gen go --v1 ./hello.thrift</span><br><span class="line">/path/to/soa_tools/thrift --gen go --v2 ./hello.thrift</span><br></pre></td></tr></table></figure>
<p><strong>生成的 SDK 在 sdk/v1/ sdk/v2 目录下。</strong></p>
<h2 id="编写测试代码">编写测试代码</h2>
<p>golang版rpc包括两种调用方式：</p>
<ul>
<li>通过IP调用：一般在开发过程，为了简化调用流程，我们可以直接指定后端服务ip和port进行调用。 在项目目录下(位置任意，只要import了…/helloworld/sdk/v3/hello包即可)新建main.go文件，编辑以下代码：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;micode.be.xiaomi.com/systech/helloworld/sdk/v3/hello&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	client:=hello.NewHelloServiceClientHostWrapper(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">12508</span>,<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">	fmt.Println(client.HelloWorld(<span class="string">&quot;xiaoming&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们代码依赖koala基础库，为了简化编译步骤，我们采用脚本进行编译运行，在当前目录下 <a href="http://xn--run-282fu0m.sh">打开run.sh</a>，输入以下内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">curdir=`<span class="built_in">pwd</span>`</span><br><span class="line">glide init &amp;&amp; glide up</span><br><span class="line">go run <span class="variable">$curdir</span>/main.go</span><br></pre></td></tr></table></figure>
<p><a href="http://xn--run-bs7ij42a.sh">运行run.sh</a>，即可看到程序运行结果。</p>
<ul>
<li>通过服务名调用：在测试或线上环境中，我们需要在SOA平台上进行订阅xm_ip_service，然后通过服务名进行调用。 调用代码如下，保存为main.go：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;micode.be.xiaomi.com/your/project/sdk/v3/ip&quot;</span></span><br><span class="line">    <span class="string">&quot;micode.be.xiaomi.com/systech/soa/xrpc&quot;</span></span><br><span class="line">    <span class="string">&quot;micode.be.xiaomi.com/systech/soa/thrift&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化rpc组件,必须要到平台上订阅xm_ip_service服务</span></span><br><span class="line">    <span class="comment">//在本例中，xm_ip_service_client已经订阅了xm_ip_service服务，所以能够调用成功</span></span><br><span class="line">    <span class="comment">//参数1：group 订阅者所在的组名</span></span><br><span class="line">    <span class="comment">//参数2：service 订阅者所在的服务名（项目名）</span></span><br><span class="line">    <span class="comment">//参数3：etcd_host etcd地址，</span></span><br><span class="line">             <span class="number">1.</span> 测试环境为http:<span class="comment">//etcd.test.mi.com </span></span><br><span class="line">             <span class="number">1.</span> 线上环境为http:<span class="comment">//soa01.etcd.b2c.srv:4001</span></span><br><span class="line">    _, err := xrpc.NewXRpcDefault(<span class="string">&quot;misite&quot;</span>, <span class="string">&quot;xm_ip_service_client&quot;</span>, <span class="string">&quot;http://etcd.test.mi.com&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">nil</span>) &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数1：serviceName 调用方的服务名</span></span><br><span class="line">    <span class="comment">//参数2：logid 用来标识一次请求，一般从上游获取，没有可以自己随机生成</span></span><br><span class="line">    <span class="comment">//参数3：rpcId 填0即可</span></span><br><span class="line">    context := thrift.NewXContext(<span class="string">&quot;xm_ip_service_client&quot;</span>, <span class="number">1000</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 参数1：serviceName 服务提供方的服务名</span></span><br><span class="line">    <span class="comment">//2. 参数2：ctx 调用上下文</span></span><br><span class="line">    client := ip.NewIPServiceClientWrapper2(<span class="string">&quot;xm_ip_service&quot;</span>, context)</span><br><span class="line"></span><br><span class="line">    ipList := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    ipList = <span class="built_in">append</span>(ipList, <span class="string">&quot;100.200.39.4&quot;</span>)</span><br><span class="line">    fmt.Println(client.QueryGeoInfoByIP(ipList))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行测试程序">运行测试程序</h2>
<p>正常情况下，将会返回类似如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Result_(&#123;Response:hello world,liuxing1&#125;) &lt;nil&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>项目经历</category>
      </categories>
  </entry>
  <entry>
    <title>moments 项目</title>
    <url>/2018/12/11/project_experience/moments%20%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1>moment项目需求</h1>
<blockquote>
<p>相关技术栈：redis、golang、MySQL、linux</p>
</blockquote>
<p>做一个看板任务(照着微信朋友圈来,不过所有用户全部看成朋友即可)</p>
<blockquote>
<ol>
<li>用户可以登录,可以保持登录状态</li>
<li>用户可以发布一个想法,包含一段文字,0-4张图片(保存图片链接即可)</li>
<li>用户可以查看大家发布的说说,按时间顺序从新展示,需分页,一页20个</li>
<li>用户可以评论想法,也可以删除自己的评论</li>
<li>用户可以点赞/取消点赞想法</li>
<li>消息通知,点赞回复要通知所有和说说相关的人</li>
</ol>
</blockquote>
<blockquote>
<p>不做界面,规划好接口,数据库,且完成即可<br>
数据库尽可能满足 一对一  一对多  多对多 关系,不要求字段冗余<br>
使用HTTP协议,框架自选(iris,beego等都行)</p>
</blockquote>
<p>进度安排:</p>
<ol>
<li>设计好数据库</li>
<li>规划好接口</li>
<li>做好登录认证</li>
<li>完成接口</li>
</ol>
<span id="more"></span>
<h1>数据库实现</h1>
<p><a href="https://jingyan.baidu.com/article/624e745961c6a134e9ba5a40.html">数据库E-R图怎么画？</a></p>
<blockquote>
<p>实体，属性，关系；实体就是一个个对象，比如猫；属性就是实体所有的某个属性，比如猫的性别；关系就是实体和实体之间或者实体内部之间的关系。<br>
在ER图中，<strong>矩形代表实体，椭圆代表属性，菱形代表关系</strong>，各个形状之间用线段连接。</p>
</blockquote>
<p>在本项目中，实体有</p>
<ol>
<li>内容发布者</li>
<li>朋友圈发布项</li>
<li>朋友圈的评论项</li>
</ol>
<p>内容发布者对应属性：</p>
<ul>
<li>用户ID（系统内部）（主键）</li>
<li>用户姓名（界面展示）</li>
<li>用户密码</li>
</ul>
<p>朋友圈标志属性：</p>
<ul>
<li>发布ID(每个发布者发布朋友圈时调用，自增1，本身具有时间顺序特性)（主键）</li>
<li>发布者用户ID（外键）</li>
<li>创建时间（显示在朋友圈下方）</li>
<li>照片列：照片url;照片url;照片url;照片url</li>
<li>配文字符串</li>
</ul>
<p>评论属性：（评论归属于单个用户，并且此用户为接收者，而不是发布者）</p>
<ul>
<li>用户ID（评论创建者，用来检索对应的用户名，以展示用户评论）（外键）</li>
<li>所属朋友圈，即发布ID（和用户ID组合作为主键）（外键）</li>
<li>评论创建时间（按时间顺序显示评论）</li>
<li>评论内容字符串</li>
<li>点赞与否</li>
</ul>
<h2 id="数据库设计思路">数据库设计思路</h2>
<blockquote>
<p>做一个看板任务(照着微信朋友圈来,不过所有用户全部看成朋友即可)</p>
<ol>
<li>用户可以登录,可以保持登录状态</li>
<li>用户可以发布一个想法,包含一段文字,0-4张图片(保存图片链接即可)</li>
<li>用户可以查看大家发布的说说,按时间顺序从新展示,需分页,一页20个</li>
<li>用户可以评论想法,也可以删除自己的评论</li>
<li>用户可以点赞/取消点赞想法</li>
<li>消息通知,点赞回复要通知所有和说说相关的人</li>
</ol>
</blockquote>
<p>不做界面,规划好接口,数据库,且完成即可<br>
数据库尽可能满足 一对一 一对多 多对多 关系,不要求字段冗余<br>
使用HTTP协议,框架自选(iris,beego等都行)</p>
<p><strong>微信朋友圈设计架构</strong></p>
<p>微信朋友圈的数据有四个核心的表：</p>
<ol>
<li>发布表，发布表记录了来自所有用户的所有<a href="http://www.woshipm.com/marketing/1023818.html">Feed</a>，比如一个用户发布了几张图片，每张图片的URL，图片在<a href="https://www.cnblogs.com/tinywan/p/6067126.html">CDN</a>里的URL，它有哪些元属性，谁可以看，谁不可以看等等。</li>
<li>相册，相册是每个用户独立的，记录了该用户所发布的所有内容，包括了与图片相关的文字，和无配图文字。</li>
<li>评论， 评论就是针对某个具体发布的朋友评论和点赞操作。</li>
<li>时间线，所谓“刷朋友圈”，就是刷时间线，就是一个用户所有的朋友的发布内容。</li>
</ol>
<p><strong>微信朋友圈的工作流程概述</strong></p>
<ol>
<li>
<p>比如有两个用户A和B， A和B各自都有各自的相册（可以理解为A和B各自的朋友圈内容），可能在同一台服务器上，也可能在不同服务器上。现在A上传了一张图片到自己的朋友圈。上传图片不经过微信服务器，而是直接上传到最近的CDN节点去，所以非常快。图片上传到CDN后，小王的微信客户端会通知，这里有一个新的发布（比如叫K2），这个发布的图片CDN URL是什么，谁能看这张图片等等此类的元数据。来把这些数据写入发布表中。</p>
</li>
<li>
<p>在发布表写完之后，会把K2的发布索引到A的相册表中，所以相册表记录得就是每个内容索引指针，相册表写好后会触发一个批处理动作，这个动作就是去跟A的每个好友说，A有一个新的发布，请把这个发布插入到每个好友的时间线里去。</p>
</li>
<li>
<p>现在B上朋友圈了，而B是A的一个好友，B拉自己的时间线的时候，时间线会获得K2的新发布通知，然后B的微信客户端就会取根据K2的元数据去获取发布表中的一些信息比如：CDN URL，把图片拉到本地。</p>
</li>
</ol>
<blockquote>
<p>在这个过程中，发布是很重要的，因为一方面要写一个自己的数据副本，并写入自己的时间线，还要把这个副本的指针插到所有好友的时间线里面去，如果一个用户有几百个好友的话，这个过程会比较慢一些。这是一个单数据副本写扩散的过程。但是相对应的，读取就很简单。每个用户只需要读取自己的时间线这一个动作就行，不需要去遍历所有的好友相册表。这个是否有一定得数据冗余？？</p>
</blockquote>
<p>参考文献：</p>
<ol>
<li><a href="https://blog.csdn.net/u011035407/article/details/78592787">朋友圈的设计及实现</a></li>
<li><a href="https://blog.csdn.net/u012244016/article/details/70664959">微信与朋友圈后台架构</a></li>
<li><a href="https://www.zhihu.com/question/21909660">微信朋友圈数据库模式如何设计的？</a></li>
<li><a href="https://www.2cto.com/kf/201603/496529.html">微信与朋友圈后台架构的讲解</a></li>
<li><a href="https://blog.csdn.net/sinat_27564919/article/details/70946319">控制朋友圈好友状态可见性的数据表设计</a></li>
</ol>
<h2 id="数据交互逻辑">数据交互逻辑</h2>
<h3 id="用户登录">用户登录</h3>
<blockquote>
<p>匹配password字段—&gt;若成功，登录操作（http协议）进入看板界面，推送Feed流信息，若失败，拒绝访问，“密码错误，请重新输入密码”，超时锁定。</p>
</blockquote>
<h3 id="刷朋友圈">刷朋友圈</h3>
<p>登录成功—&gt;推送publish，按publish_id从大到小排列，展示publish_id最大的20个publish。<br>
刷朋友圈的行为即为刷取多个朋友圈信息（publish）对于单个publish:</p>
<ul>
<li>获取创建时间—&gt;拉取create_time在左下方显示；</li>
<li>获取照片—&gt;拉取picture表中，publish_id对应的pic_url；</li>
<li>获取朋友圈文字—&gt;拉取caption；</li>
<li>获取评论—&gt;拉取comment表中，publish_id对应的comment，根据comment_id进行从大到小排序，根据usr_id，检索出usr_name(即评论人)，拉取comments,和comment create_time（整体显示情况即为：评论人，评论，评论创建的时间)；</li>
<li>获取点赞信息—&gt;拉取like表中，publish_id对应的like项，并根据like_id,从大到小排序（整体显示情况即为：点赞人A，点赞人B，点赞人C…）</li>
</ul>
<h3 id="发布朋友圈">发布朋友圈</h3>
<p>创建一个新的publish表项，publish_id自增1，根据当前用户，填入当前usr_id,录入当前时间到create_time，将朋友圈文字信息，录入到caption字段中；</p>
<p>若有照片，每个照片创建一个picture表项，录入pic_url和当前publish_id，pic_id自增1</p>
<h3 id="评论朋友圈">评论朋友圈</h3>
<p>创建一个新的comment表项，comment_id自增1，根据当前用户，填入当前usr_id,录入当前时间到create_time，将评论文字信息，录入到comments字段中，并录入当前评论的publish_id；</p>
<p>创建Notice，根据当前评论的publish_id，检索，当前Notice表中，具有同样publish_id的Notice，查看其中的from_id和to_id，即为所有相关的用户，创建对应的Notice，notice_id自增1，publish_id即为当前评论的publish_id，type为0（0为评论，1为点赞），from_id为当前评论的用户，to_id依次为检索到的所有用户ID，status为0（0未读，1已读）；</p>
<h3 id="点赞朋友圈">点赞朋友圈</h3>
<p>创建一个新的like表项，like_id自增1，根据当前用户，填入当前usr_id，填入当前点赞的publish_id；<br>
创建Notice，根据当前评论的publish_id，检索，当前Notice表中，具有同样publish_id的Notice，查看其中的from_id和to_id，即为所有相关的用户，创建对应的Notice，notice_id自增1，publish_id即为当前评论的publish_id，type为1（0为评论，1为点赞），from_id为当前评论的用户，to_id依次为检索到的所有用户ID，status为0（0未读，1已读）；</p>
<h3 id="推送评论通知基本逻辑">推送评论通知基本逻辑</h3>
<ul>
<li><em>接收通知的用户，通知详情需要主动获取</em></li>
<li><em>通知的主动推送，本质为当前用户定时，每秒查看，有多少条未读通知</em> (*)</li>
<li>根据Notice表，主动获取通知，定时获取to_id与当前用户usr_id相符，且status字段为0（未读）的Notice。通知格式为“您有N条消息未读”。并同时存储这些Notice的notice_id</li>
<li>当用户点击通知，读取通知时，检索存储的notice_id，将这些Notice的status字段置为1，并根据type获知通知类型，若type=0为评论，则查找comment表项，查找对应publish_id中<code>usr_id=from_id</code>的comments字段，获取评论详情(from_id+comments)，上方要同时拉取对应publish_id的朋友圈详情(usr_id+pic+caption+create_time)；若type=1为点赞，则拉取对应publish_id的朋友圈详情，并显示，“(from_id) like this”，上方要同时拉取对应publish_id的朋友圈详情(usr_id+pic+caption+create_time)</li>
</ul>
<h3 id="通知的几种特殊情况的考虑">通知的几种特殊情况的考虑</h3>
<ul>
<li>(未评论用户)取消点赞后，需要去掉该用户的Notice</li>
<li>(未点赞用户)删除评论后，需要去掉该用户的Notice</li>
<li>阅读过通知后，通知需要保留，将状态置为已读，当后续还有人评论时，可以根据Notice表自动维护之后的通知。</li>
<li>每一次的通知都可以直接通过上一次通知进行维护更新。第一步，找到对应的publish_id中notice_id的最大的一项，找出对应的from_id，即找出了，本朋友圈上一次的通知，是从from_id，通知到了此用户的所有to_id。即所有最新的相关用户群，则更新的Notice为，from_id=当前usr_id，to_id=上一次的from_id+上一次的所有的to_id。</li>
<li><em>初次生成的通知会被立刻调用，所以也可以直接在生成的时候，直接推送。</em> （*）</li>
</ul>
<h2 id="MySQL设计规范"><a href="/2018/12/11/MySQL%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83/">MySQL设计规范</a></h2>
<blockquote>
<p>详情，点击标题跳转页面↑</p>
</blockquote>
<hr>
<h1>接口设计</h1>
<h2 id="接口基础函数">接口基础函数</h2>
<h3 id="Prepare">Prepare</h3>
<blockquote>
<p>Beego框架中，Controller的Prepare函数都会自动在调用其之前先被调用。<br>
所以Prepare函数，被我用来写验证相关的代码。</p>
</blockquote>
<p>①假如当前是在进行非登录操作，则需要验证，session_id，若为空，则未登录，跳转到登录操作页面<br>
②若不为空，则在redis中进行比对，看是否存在当前用户的session_id，K-VOUSMEVOYEZ结构为“K:session_id,VOUSMEVOYEZ:usr_name”，若查找当前session_id，得到的用户为空，则未登录，跳转到登录操作页面；得到的用户名非空，还需要验证一下用户表中是否存在该用户，不存在则显示为仿冒用户<br>
③若不存在session_id的问题，执行完Prepare函数仍未被跳转到登录页面，则继续执行Controller</p>
<h3 id="History">History</h3>
<p>一个跳转函数，用来控制，当出现错误或者验证安全的问题时，及时做出反馈，当出现系统性错误时，停止系统的运行，当出现验证问题时，及时跳转到所需页面，如登录页面等。<br>
<strong>msg</strong>：用来描述当前问题，并写入到跳转页面<br>
<strong>url</strong>：用来描述跳转链接，当为空时，停止运行当前controller</p>
<h3 id="Finish">Finish</h3>
<blockquote>
<p>Beego框架中，任何Controller的Finish函数都会自动在调用后，最后时刻被调用，所以Finish函数，被我用来写Session的控制。</p>
</blockquote>
<p>①假如当前是在进行非登录登出操作，需要验证后，为当前Session_id，续期30分钟<br>
②假如是登录操作，需要为当前用户创建一个session_id,存到redis中，并发送给客户端</p>
<hr>
<h2 id="登录接口">登录接口</h2>
<h3 id="Login">Login</h3>
<p><strong>路由</strong>：“/admin/login”<br>
用户登录输入用户名密码，以Json格式发送至客户端，若存在Session，且和服务器内Session_id相符，则直接验证通过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UsrInfo 用户评价时提交的表单</span></span><br><span class="line"><span class="keyword">type</span> UsrInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	UsrName  <span class="type">string</span> <span class="string">`form:&quot;usr_name&quot;`</span></span><br><span class="line">	Password <span class="type">string</span> <span class="string">`form:&quot;password&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入</strong>：Body包含用户名密码的Json格式文档，或其他包含Session_id的Json格式文档<br>
通过解析Json，解析出用户名，密码，和Session_id：<br>
①假如Session_id非空，且在Redis中存在，则更新Redis，直接进入下一步；<br>
②假如Session_id非空，但在Redis中不存在，则登录超时，要求重新登录，进入登录界面<br>
③假如Session_id为空，则进入登录界面，解析客户端发送过来的用户名密码，若用户名密码匹配，则登录成功，并生成一个Session记录，保存在Redis，同时将Session_id作为输出发送给客户端。否则直接返回“用户名或密码错误”，要求重新登录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LoginResult 传递登录结果</span></span><br><span class="line"><span class="keyword">type</span> LoginResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	Result    <span class="type">bool</span>   <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">	UsrID     <span class="type">int</span>    <span class="string">`json:&quot;usr_id&quot;`</span></span><br><span class="line">	SessionID <span class="type">string</span> <span class="string">`json:&quot;session_id&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：验证结果（true/false）+ session_id + usr_id(给客户端保存)</p>
<h3 id="Logout">Logout</h3>
<p><strong>路由</strong>：“/admin/login”<br>
用户退出登录的时候，需要清除掉当前用户的Session_id。然后跳转到登录页面。</p>
<p><strong>输入</strong>：session_id</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LogoutFeedback 退出登录反馈信息</span></span><br><span class="line"><span class="keyword">type</span> LogoutFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	Result <span class="type">bool</span>   <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">	Info   <span class="type">string</span> <span class="string">`json:&quot;info&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：返回到登录界面</p>
<hr>
<h2 id="朋友圈接口">朋友圈接口</h2>
<h3 id="PostMoment-发布朋友圈">PostMoment(发布朋友圈)</h3>
<blockquote>
<p>分析：客户端发布朋友圈，通过表单发送给后台，返回一个publish_id,和发布结果；发布朋友圈时，所需要的信息是，用户名，文字信息，和图片，由此构建表单结构体</p>
</blockquote>
<p><strong>路由</strong>：“/feed/post”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PushMoment is 发送朋友圈时提交的表单</span></span><br><span class="line"><span class="keyword">type</span> PushMoment <span class="keyword">struct</span> &#123;</span><br><span class="line">	UserName <span class="type">string</span>   <span class="string">`form:&quot;usr_name&quot;`</span></span><br><span class="line">	Caption  <span class="type">string</span>   <span class="string">`form:&quot;caption&quot;`</span></span><br><span class="line">	PicList  []<span class="type">string</span> <span class="string">`form:&quot;pic_list&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入</strong>：朋友圈所需信息的表单。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PostResult 发布朋友圈后的反馈结果</span></span><br><span class="line"><span class="keyword">type</span> PostResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	Result    <span class="type">bool</span>  <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">	PublishID <span class="type">int64</span> <span class="string">`json:&quot;publish_id&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：true or false 若为true 还需要返回一个当前创建成功后，数据库中publish表的publish_id,方便后期加评价和删除朋友圈。</p>
<h3 id="ReadMoment-刷朋友圈">ReadMoment(刷朋友圈)</h3>
<blockquote>
<p>分析：由于本需求中，所有人都为朋友，所以所有人的展示结果只跟发送展示请求的时间有关（当做一个锚点），读取朋友圈时，不要读取最新的朋友圈信息，即只刷取，锚点以前，请求时的当前数据库数据。如若不然，会导致分页重复，刷新朋友圈为动态操作（和刷朋友圈区分开，刷朋友圈是静态操作）。最新的朋友圈和评论产生时，只轮询读取到通知，而不拉取最新的朋友圈信息。当用户主动刷新的时候，再读取最新的信息。</p>
</blockquote>
<p><strong>路由</strong>：“/feed/circle”<br>
用户登录成功跳转至朋友圈界面，查询当前publish列表，记录此时最新的publish（即为Publish_id最大值），记录为publishAnchor，通过锚点进行分页展示。<br>
通过publish_id排列，查找20个最新的朋友圈，将所有的数据打包发送出去。</p>
<p><strong>输入</strong>：publish_index（数据类型int，读取朋友圈信息时publish_id的开始处）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MomentFeed 朋友圈数据流</span></span><br><span class="line"><span class="keyword">type</span> MomentFeed <span class="keyword">struct</span> &#123;</span><br><span class="line">	Moments   []models.OneMoment <span class="string">`json:&quot;Moments&quot;`</span></span><br><span class="line">	PublishID <span class="type">int</span>                <span class="string">`json:&quot;publish_id&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OneMoment is 单个朋友圈的Json格式</span></span><br><span class="line"><span class="keyword">type</span> OneMoment <span class="keyword">struct</span> &#123;</span><br><span class="line">	PublishID  <span class="type">int</span>         <span class="string">`json:&quot;publish_id&quot;`</span></span><br><span class="line">	UserName   <span class="type">string</span>      <span class="string">`json:&quot;usr_name&quot;`</span></span><br><span class="line">	Caption    <span class="type">string</span>      <span class="string">`json:&quot;caption&quot;`</span></span><br><span class="line">	PicList    []<span class="type">string</span>    <span class="string">`json:&quot;pic_list&quot;`</span></span><br><span class="line">	CreateTime <span class="type">string</span>      <span class="string">`json:&quot;create_time&quot;`</span></span><br><span class="line">	LikeList   []<span class="type">string</span>    <span class="string">`json:&quot;like_list&quot;`</span></span><br><span class="line">	Comments   CommentList <span class="string">`json:&quot;comments&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OneComment is 单个评论传输时的Json格式</span></span><br><span class="line"><span class="keyword">type</span> OneComment <span class="keyword">struct</span> &#123;</span><br><span class="line">	CommentID      <span class="type">int</span>    <span class="string">`json:&quot;comment_id&quot;`</span></span><br><span class="line">	UsrName        <span class="type">string</span> <span class="string">`json:&quot;usr_name&quot;`</span></span><br><span class="line">	CommentCaption <span class="type">string</span> <span class="string">`json:&quot;comment_caption&quot;`</span></span><br><span class="line">	CreateTime     <span class="type">string</span> <span class="string">`json:&quot;create_time&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CommentList is 评论列表，Json格式</span></span><br><span class="line"><span class="keyword">type</span> CommentList []OneComment</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：锚点后的20条朋友圈信息（JSON）。创建一个朋友圈整体信息的结构体。</p>
<h3 id="DelMoment-删除朋友圈">DelMoment(删除朋友圈)</h3>
<p>根据前端发送来的pubish_id，进行对当前朋友圈的一系列删除，包括，相册表，评论表，点赞表和通知表。<br>
<strong>路由</strong>：“/feed/del”</p>
<p><strong>输入</strong>：publish_id</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DelFeedInfo 删除朋友圈后的反馈信息</span></span><br><span class="line"><span class="keyword">type</span> DelFeedInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	Result <span class="type">bool</span>   <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">	Info   <span class="type">string</span> <span class="string">`json:&quot;info&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：反馈信息，true or false</p>
<hr>
<h2 id="评论接口">评论接口</h2>
<h3 id="CreateComment-发布评论接口">CreateComment(发布评论接口)</h3>
<p>根据前端发送来的评论信息，建立数据库信息，因为前段发来的评论信息，要有，评论相关文字，评论所属对象，和评论所属朋友圈，故建立表单信息进行接收。</p>
<p><strong>路由</strong>：“/feed/comment/create”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OneComment 用户评价时提交的表单</span></span><br><span class="line"><span class="keyword">type</span> OneComment <span class="keyword">struct</span> &#123;</span><br><span class="line">	UsrID          <span class="type">int</span>    <span class="string">`form:&quot;usr_id&quot;`</span></span><br><span class="line">	UsrName        <span class="type">string</span> <span class="string">`form:&quot;usr_name&quot;`</span></span><br><span class="line">	CommentCaption <span class="type">string</span> <span class="string">`form:&quot;comment_caption&quot;`</span></span><br><span class="line">	PublishID      <span class="type">int</span>    <span class="string">`form:&quot;publish_id&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入</strong>：form</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CreateCommentFeedback 评论创建反馈</span></span><br><span class="line"><span class="keyword">type</span> CreateCommentFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	CommentID    <span class="type">int64</span> <span class="string">`json:&quot;comment_id&quot;`</span></span><br><span class="line">	CreateResult <span class="type">bool</span>  <span class="string">`json:&quot;create_result&quot;`</span></span><br><span class="line">	NoticeStatus <span class="type">bool</span>  <span class="string">`json:&quot;notice_status&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：反馈信息，返回告诉客户端，该评论的comment_id，以及评论成功与否，通知是否已经建立等确认信息。</p>
<h3 id="DelComment-删除评论接口">DelComment(删除评论接口)</h3>
<p>给出对应的comment_id，删除所有的相关信息。改动涉及：comment表和notice表</p>
<p><strong>路由</strong>：“/feed/comment/del”</p>
<p><strong>输入</strong>：comment_id</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DelCommentFeedback 评论创建反馈</span></span><br><span class="line"><span class="keyword">type</span> DelCommentFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	DelResult       <span class="type">bool</span>   <span class="string">`json:&quot;del_result&quot;`</span></span><br><span class="line">	DelNoticeResult <span class="type">bool</span>   <span class="string">`json:&quot;del_notice_status&quot;`</span></span><br><span class="line">	Info            <span class="type">string</span> <span class="string">`json:&quot;info&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：反馈信息，返回告诉客户端，评论删除与否，评论涉及的通知信息删除与否。</p>
<hr>
<h2 id="点赞接口">点赞接口</h2>
<h3 id="LIke（点赞）">LIke（点赞）</h3>
<p>点赞过程中，需要在点赞表中建立一条新信息，相应的，点赞通知的建立，需要通过CreateNotice遍历的在Notice表中建立多条信息。所以需要usr_id ,usr_name ，publish_id 三个信息，以上信息以表单形式传递。</p>
<p><strong>路由</strong>：&quot;/feed/like/create</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Like is 前端大赞操作发送来的表单</span></span><br><span class="line"><span class="keyword">type</span> Like <span class="keyword">struct</span> &#123;</span><br><span class="line">	UsrID     <span class="type">int</span>    <span class="string">`form:&quot;usr_id&quot;`</span></span><br><span class="line">	UsrName   <span class="type">string</span> <span class="string">`form:&quot;usr_name&quot;`</span></span><br><span class="line">	PublishID <span class="type">int</span>    <span class="string">`form:&quot;publish_id&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入</strong>：点赞表单：Like结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CreateLikeFeedback 创建点赞后给出的反馈信息</span></span><br><span class="line"><span class="keyword">type</span> CreateLikeFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	LikeID       <span class="type">int</span>  <span class="string">`json:&quot;like_id&quot;`</span></span><br><span class="line">	CreateResult <span class="type">bool</span> <span class="string">`json:&quot;create_result&quot;`</span></span><br><span class="line">	NoticeStatus <span class="type">bool</span> <span class="string">`json:&quot;notice_status&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：反馈信息，返回告诉客户端，创建的点赞的ID是多少，创建结果如何，通知是否创建成果的信息。</p>
<h3 id="CancelLike-取消点赞">CancelLike(取消点赞)</h3>
<p>取消点赞，得到取消点赞的对应like_id即可，删除like表中对应的信息，并同时删除对应的通知信息。</p>
<p><strong>路由</strong>：&quot;/feed/like/cancel</p>
<p><strong>输入</strong>：like_id</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CancelLikeFeedback 取消点赞反馈</span></span><br><span class="line"><span class="keyword">type</span> CancelLikeFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	CancelResult    <span class="type">bool</span>   <span class="string">`json:&quot;cancel_result&quot;`</span></span><br><span class="line">	DelNoticeResult <span class="type">bool</span>   <span class="string">`json:&quot;del_notice_result&quot;`</span></span><br><span class="line">	Info            <span class="type">string</span> <span class="string">`json:&quot;info&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：取消的结果，删除通知的结果，以及相关的反馈信息。以便后期对应做出维护。</p>
<hr>
<h2 id="通知接口">通知接口</h2>
<blockquote>
<p>通知被设计成，创建通知，删除通知为基本函数，穿插在点赞和评论的基本操作当中，并非一个单独的接口，而获取通知被设计成一个接口，目的就是能够随时获得最新的通知，能随时调用这个接口，读取操作可以作为常用接口，而增删通知则不开放为一个接口来调用。</p>
</blockquote>
<h3 id="GetNotice（获得通知）">GetNotice（获得通知）</h3>
<p>获得通知时无需发送多余的信息，直接通过Session即可<br>
<strong>路由</strong>：feed/notice<br>
<strong>输入</strong>：session_id （从redis中获得usr_name）<br>
<strong>输出</strong>：通知信息。通知信息所需要的基本信息可以分析，通知信息的前端展示：<br>
①朋友圈有更新的通知：如果有新的朋友圈，一个红点，如果没有，则没有红点；<br>
②自己的朋友圈被评论的通知：XX(usr_name)评价了您的“XXX”(某条朋友圈的部分文字信息)；<br>
③自己参与的别人的朋友圈被其他人评论的通知：XX(usr_name)评价了“XXX”(某条朋友圈的部分文字信息)；<br>
④自己的朋友圈被点赞的通知：XX(usr_name)点赞了您的“XXX”(某条朋友圈的部分文字信息)；<br>
⑤自己参与的别人的朋友圈被其他人点赞的通知：XX(usr_name)点赞了“XXX”(某条朋友圈的部分文字信息)；<br>
前端展示如上五种通知，则需要知道的信息有：</p>
<ol>
<li>该条通知，是通知有新的朋友圈还是新的评论还是有新的点赞？</li>
<li>publish表单是否有新的内容</li>
<li>评论时，是谁评论了哪条朋友圈</li>
<li>点赞时，是谁点赞了哪条朋友圈</li>
</ol>
<p>即为，publish_id,from_id,notice_type至于这条朋友圈的所属者是不是通知对象本身，可以由客户端自行判断。<br>
因为通知的结构体如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OneNotice 单个通知信息</span></span><br><span class="line"><span class="keyword">type</span> OneNotice <span class="keyword">struct</span> &#123;</span><br><span class="line">	NoticeID     <span class="type">int</span>    <span class="string">`json:&quot;notice_id&quot;`</span></span><br><span class="line">	PublishID    <span class="type">int</span>    <span class="string">`json:&quot;publish_id&quot;`</span><span class="comment">//指向对应的朋友圈</span></span><br><span class="line">	NoticeType   <span class="type">int</span>    <span class="string">`json:&quot;notice_type&quot;`</span><span class="comment">//0为评论，1为点赞</span></span><br><span class="line">	CommentID    <span class="type">int</span>    <span class="string">`json:&quot;comment_id&quot;`</span></span><br><span class="line">	LikeID       <span class="type">int</span>    <span class="string">`json:&quot;like_id&quot;`</span></span><br><span class="line">	FromUserName <span class="type">string</span> <span class="string">`json:&quot;from_user_name&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当客户端接收到的publish_id为0时，该条Notice意思是：有新的朋友圈信息。<br>
当客户端接收到的publish_id不为0时，(如23)，from_user_name:liuxing1，notice_type:1，该条信息的意思是：23号朋友圈有来自liuxing1的点赞<br>
当客户端接收到的publish_id不为0时，(如23)，from_user_name:liuxing1，notice_type:0，该条信息的意思是：23号朋友圈有来自liuxing1的评论</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NoticeList 发送给用户的通知信息</span></span><br><span class="line"><span class="keyword">type</span> NoticeList <span class="keyword">struct</span> &#123;</span><br><span class="line">	Notices []OneNotice <span class="string">`json:&quot;notices&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>故，以上通知列，可以告知用户一切相关的通知信息，点击这些信息的时候，再调取具体的通知信息给用户呈现。</p>
<h3 id="GetInfo-根据通知，来获取相关信息的更新">GetInfo(根据通知，来获取相关信息的更新)</h3>
<p><strong>路由</strong>：feed/getinfo<br>
以上五种通知，通知1不会单独呈现，只需要用小红点告知用户有最新动态，刷新朋友圈即可。通知2，3，4，5则会单独呈现，2，3点选的时候，会在上方展示相关朋友圈，下方会显示所有的点赞评论信息，即，将当前发生最新动态的朋友圈的最新状态整个从服务端拉取过来。点赞信息的更新类似。</p>
<p><strong>输入</strong>：通过“session_id”可以得知usr_id,usr_name。只需要publish_id即可进行信息的更新。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NewMoment 回传的最新单条朋友圈详情</span></span><br><span class="line"><span class="keyword">type</span> NewMoment OneMoment</span><br><span class="line"></span><br><span class="line"><span class="comment">//OneMoment is 单个朋友圈的Json格式</span></span><br><span class="line"><span class="keyword">type</span> OneMoment <span class="keyword">struct</span> &#123;</span><br><span class="line">	PublishID  <span class="type">int</span>         <span class="string">`json:&quot;publish_id&quot;`</span></span><br><span class="line">	UserName   <span class="type">string</span>      <span class="string">`json:&quot;usr_name&quot;`</span></span><br><span class="line">	Caption    <span class="type">string</span>      <span class="string">`json:&quot;caption&quot;`</span></span><br><span class="line">	PicList    []<span class="type">string</span>    <span class="string">`json:&quot;pic_list&quot;`</span></span><br><span class="line">	CreateTime <span class="type">string</span>      <span class="string">`json:&quot;create_time&quot;`</span></span><br><span class="line">	LikeList   []<span class="type">string</span>    <span class="string">`json:&quot;like_list&quot;`</span></span><br><span class="line">	Comments   CommentList <span class="string">`json:&quot;comments&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CommentList is 评论列表，Json格式</span></span><br><span class="line"><span class="keyword">type</span> CommentList []OneComment</span><br><span class="line"></span><br><span class="line"><span class="comment">//OneComment 用户评价时提交的表单</span></span><br><span class="line"><span class="keyword">type</span> OneComment <span class="keyword">struct</span> &#123;</span><br><span class="line">	UsrName        <span class="type">string</span> <span class="string">`json:&quot;usr_name&quot;`</span></span><br><span class="line">	CommentCaption <span class="type">string</span> <span class="string">`form:&quot;comment_caption&quot; json:&quot;comment_caption&quot;`</span></span><br><span class="line">	PublishID      <span class="type">int</span>    <span class="string">`form:&quot;publish_id&quot; json:&quot;-&quot;`</span></span><br><span class="line">	CommentID      <span class="type">int</span>    <span class="string">`json:&quot;comment_id&quot;`</span></span><br><span class="line">	CreateTime     <span class="type">string</span> <span class="string">`json:&quot;create_time&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：单条朋友圈的最新状态。</p>
<h1>实现所需知识树</h1>
<h2 id="Beego框架的使用"><a href="https://beego.me/docs/quickstart/">Beego框架的使用</a></h2>
<p><strong>实例</strong><br>
<a href="https://github.com/beego/samples/tree/master/WebIM">samples/WebIM at master · beego/samples · GitHub</a></p>
<h2 id="Session">Session</h2>
<p>由于需要保持登录状态，所以这里需要用到Session控制<br>
<a href="https://studygolang.com/articles/15822?fr=sidebar">Go基础学习记录之如何在Golang中使用Session  - Go语言中文网 - Golang中文社区</a><br>
<a href="https://beego.me/docs/mvc/controller/session.md">Session control - beego: simple &amp; powerful Go app framework</a></p>
<h2 id="Redis"><a href="https://redis.io">Redis</a></h2>
<p><a href="/2018/12/11/Redis%E6%95%99%E7%A8%8B/">Redis 教程</a></p>
<h1>遇到的坑</h1>
<p>Json解析首字母一定要大写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CreateCommentFeedback 评论创建反馈</span></span><br><span class="line"><span class="keyword">type</span> CreateCommentFeedback <span class="keyword">struct</span> &#123;</span><br><span class="line">	CommentID    <span class="type">int64</span> <span class="string">`json:&quot;comment_id&quot;`</span></span><br><span class="line">	CreateResult <span class="type">bool</span>  <span class="string">`json:&quot;create_result&quot;`</span></span><br><span class="line">	NoticeStatus <span class="type">bool</span>  <span class="string">`json:&quot;notice_status&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编码JSON的时候，json:&quot;-&quot;可以让其不参与编码，不然还是会编码，不过不会更名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">PublishID      <span class="type">int</span>    <span class="string">`form:&quot;publish_id&quot; json:&quot;-&quot;`</span></span><br></pre></td></tr></table></figure>
<p>若为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">PublishID      <span class="type">int</span>    <span class="string">`form:&quot;publish_id&quot;`</span></span><br></pre></td></tr></table></figure>
<p>编码的时候，还是会有这个字段，并且，显示的是，PublishID:XXX</p>
<p>redis的操作问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Cli.Set(<span class="string">&quot;liuxing1&quot;</span>, <span class="string">&quot;aaaaa&quot;</span>, <span class="number">30</span>*time.Minute)</span><br><span class="line">	a := Cli.Get(<span class="string">&quot;liuxing1&quot;</span>)</span><br><span class="line">	fmt.Println(a.Val())</span><br><span class="line">	fmt.Println(a.String())</span><br><span class="line">	b := Cli.Del(<span class="string">&quot;liuxing&quot;</span>)</span><br><span class="line">	fmt.Println(b.Val())</span><br><span class="line">	c := Cli.Get(<span class="string">&quot;liuxing1&quot;</span>)</span><br><span class="line">	fmt.Println(c.Val())</span><br><span class="line">	fmt.Println(c.Val()==<span class="string">&quot;&quot;</span>)</span><br><span class="line">	fmt.Println(c.Err())</span><br><span class="line">	b = Cli.Del(<span class="string">&quot;liuxing1&quot;</span>)</span><br><span class="line">	fmt.Println(b.Val())</span><br><span class="line">	c = Cli.Get(<span class="string">&quot;liuxing1&quot;</span>)</span><br><span class="line">	fmt.Println(c.Val())</span><br><span class="line">	fmt.Println(c.Val()==<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaaaa</span><br><span class="line">get liuxing1: aaaaa</span><br><span class="line">0</span><br><span class="line">aaaaa</span><br><span class="line">false</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">true</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>项目经历</category>
      </categories>
  </entry>
  <entry>
    <title>odbc 的配置</title>
    <url>/2020/07/20/project_experience/odbc/</url>
    <content><![CDATA[<h1>odbc 的配置</h1>
<blockquote>
<p>相关技术栈：linux、mysql</p>
</blockquote>
<p>在<strong>安装</strong>配置之前，需要先大概了解一下 MyODBC 的架构，MyODBC 体系结构建立在 5 个组件上，如下图所示：</p>
<p><img src="http://pic.colliexyy.com/16566671925562.jpg" alt=""></p>
<p><strong>Driver Manager</strong><br>
负责管理应用程序和驱动程序间的通信，主要功能包括：解析 DSN (数据源名称，ODBC 的数据源名称在 odbc.ini 文件中配置)，加载和卸载驱动程序，处理 ODBC 调用，将其传递给驱动程序。</p>
<p><strong>ODBC.INI</strong><br>
odbc.ini 是 ODBC 配置文件，记录了连接到服务器所需的驱动信息和数据库信息xxxxxx。Driver Manager 将使用它来确定加载哪个驱动程序（使用数据源名 DSN ）。驱动程序将根据指定的DSN来读取连接参数。</p>
<p><strong>Connector/ODBC(MyODBC驱动程序)</strong><br>
实现 ODBC API 所提供的功能，它负责处理 ODBC 函数调用，将 SQL 请求提交给 MySQL 服务器，并将结果返回给应用程序。</p>
<p>在 Linux 下配置 mysql ODBC 需要有以下步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 安装 Driver Manager，本案例使用 unixODBC 来作为 Driver Manager。</span><br><span class="line">2. 安装 MySQL 驱动程序，本案例使用 Connector/ODBC。</span><br><span class="line">3. 配置 ODBC.INI</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="第一步：下载安装包">第一步：下载安装包</h2>
<p>需要下载两个安装包 <code>unixODBC 2.3.0</code> 和 <code>mysql Connector/ODBC 3.51</code><br>
unixODBC 源码包：<code>ftp://ftp.unixodbc.org/pub/unixODBC/unixODBC-2.3.0.tar.gz</code><br>
mysql Connector/ODBC 源码包：<code>http://dev.mysql.com/downloads/connector/odbc/3.51.html%23downloads</code><br>
选择</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">版本：5.1.11</span><br><span class="line">平台：Oracle&amp;Red Hat Linux6</span><br><span class="line">下载：mysql-connector-odbc-5.1.11-linux-el6-x86-64bit.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="第二步：安装-unixODBC">第二步：安装 unixODBC</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf unixODBC-2.3.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> unixODBC-2.3.4</span><br><span class="line">./configure --prefix=/usr/local/unixODBC-2.3.4 --includedir=/usr/include --libdir=/usr/local/lib -bindir=/usr/bin --sysconfdir=/usr/local/etc</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装完成后,可以在/usr/bin目录下有下面的文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root      75312 Nov 1 16:22 odbcinst</span><br><span class="line">-rwxr-xr-x 1 root root      10922 Nov 1 16:22 odbc_config</span><br><span class="line">-rwxr-xr-x 1 root root      37650 Nov 1 16:22 iusql</span><br><span class="line">-rwxr-xr-x 1 root root      44400 Nov 1 16:22 isql</span><br><span class="line">-rwxr-xr-x 1 root root      95903 Nov 1 16:22 dltest</span><br></pre></td></tr></table></figure>
<p>在/usr/local/lib目录下面有这些文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root 422955 Nov 1 16:22 libodbcinst.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     20 Nov 1 16:22 libodbcinst.so.1 -&gt; libodbcinst.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     20 Nov 1 16:22 libodbcinst.so -&gt; libodbcinst.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    981 Nov 1 16:22 libodbcinst.la</span><br><span class="line">-rwxr-xr-x 1 root root 169157 Nov 1 16:22 libodbc.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Nov 1 16:22 libodbc.so.1 -&gt; libodbc.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Nov 1 16:22 libodbc.so -&gt; libodbc.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    957 Nov 1 16:22 libodbc.la</span><br><span class="line">-rwxr-xr-x 1 root root 489405 Nov 1 16:22 libodbccr.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     18 Nov 1 16:22 libodbccr.so.1 -&gt; libodbccr.so.1.0.0</span><br><span class="line">lrwxrwxrwx 1 root root     18 Nov 1 16:22 libodbccr.so -&gt; libodbccr.so.1.0.0</span><br><span class="line">-rwxr-xr-x 1 root root    969 Nov 1 16:22 libodbccr.la</span><br></pre></td></tr></table></figure>
<h2 id="第三步：安装-mysql-Connector-ODBC">第三步：安装 mysql Connector/ODBC</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf mysql-connector-odbc-5.1.11-linux-el6-x86-64bit.tar.gz</span><br><span class="line"><span class="built_in">cd</span> mysql-connector-odbc-5.1.11-linux-el6-x86-64bit/lib</span><br><span class="line"><span class="built_in">cp</span> libmyodbc5.so /usr/local/lib</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> bin</span><br></pre></td></tr></table></figure>
<p><strong>注册驱动</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./myodbc-installer -d -a -n <span class="string">&quot;MySQL ODBC 5.1 Driver&quot;</span> -t <span class="string">&quot;DRIVER=/usr/local/lib/libmyodbc5.so;SETUP=/usr/local/lib/libmyodbc5.so&quot;</span></span><br><span class="line"></span><br><span class="line">//odbc 5.3及以上是libmyodbc5a.so和libmyodbc5w.so。其中c5a是Ansi版，c5w是Unicode版</span><br></pre></td></tr></table></figure>
<p>假如注册的时候报错找不到libodbc.so.2,但是之前确实装成功了unixodbc,可能是因为系统找不到/usr/local/lib库目录，需要添加系统搜索库目录路径：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line">//将/usr/local/lib直接添加在配置文件里</span><br><span class="line"></span><br><span class="line">ldconfig</span><br><span class="line"></span><br><span class="line">//重新缓存配置文件(为了加快程序执行时对共享库的定位速度，避免使用搜索路径查找共享库的低效率，所以是直接读取库列表文件/etc/ld.so.cache缓存文件并从中进行搜索的)</span><br></pre></td></tr></table></figure>
<h2 id="第四步：配置-ODBC-INI">第四步：配置 ODBC.INI</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">odbcinst -j</span><br><span class="line"></span><br><span class="line">unixODBC 2.3.1</span><br><span class="line">DRIVERS............: /etc/odbcinst.ini</span><br><span class="line">SYSTEM DATA SOURCES: /etc/odbc.ini</span><br><span class="line">FILE DATA SOURCES..: /etc/ODBCDataSources</span><br><span class="line">USER DATA SOURCES..: /root/.odbc.ini</span><br><span class="line">SQLULEN Size.......: 8</span><br><span class="line">SQLLEN Size........: 8</span><br><span class="line">SQLSETPOSIROW Size.: 8</span><br></pre></td></tr></table></figure>
<p>编辑文件<code>/etc/odbc.ini</code>，把下面的内容加上去。不同版本<code>mysql</code>驱动的配置方法，有细微差异。此处使用的版本是<code>mysql Connector 3.51</code>。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqlDSN]</span></span><br><span class="line"><span class="attr">Driver</span>      = /usr/local/lib/libmyodbc5.so</span><br><span class="line"><span class="attr">Description</span> = MyODBC <span class="number">5</span> Driver DSN</span><br><span class="line"><span class="attr">SERVER</span>      = <span class="number">172.31</span>.<span class="number">108.133</span></span><br><span class="line"><span class="attr">PORT</span>        = <span class="number">3306</span></span><br><span class="line"><span class="attr">USER</span>        = root</span><br><span class="line"><span class="attr">Password</span>    = <span class="number">123456</span></span><br><span class="line"><span class="attr">Database</span>    = PM</span><br><span class="line"><span class="attr">OPTION</span>      = <span class="number">3</span></span><br><span class="line"><span class="attr">charset</span>     = UTF8</span><br></pre></td></tr></table></figure>
<h2 id="第五步：设置环境变量">第五步：设置环境变量</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DBCINI=/usr/local/etc/odbc.ini</span><br><span class="line"><span class="built_in">export</span> DBCSYSINI=/usr/local/etc</span><br></pre></td></tr></table></figure>
<h2 id="第六步：重启电脑">第六步：重启电脑</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<h2 id="第七步：测试ODBC配置是否成功">第七步：测试ODBC配置是否成功</h2>
<p>isql 是 unixODBC 带的一个 ODBC 客户端访问工具，使用<code>isql +数据源名</code>来访问目标数据库。如果 ODBC 配置正确，会显示下面的界面。在<code>SQL&gt;</code>提示符下输入 SQL 语句查询数据库。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">isql mysqlDSN</span><br><span class="line"></span><br><span class="line">+---------------------------------------+</span><br><span class="line">| Connected!                           |</span><br><span class="line">|                                      |</span><br><span class="line">| sql-statement                        |</span><br><span class="line">| <span class="built_in">help</span> [tablename]                     |</span><br><span class="line">| quit                                 |</span><br><span class="line">|                                      |</span><br><span class="line">+---------------------------------------+</span><br></pre></td></tr></table></figure>
<h2 id="遇到的问题：">遇到的问题：</h2>
<p>1、在第三步安装 mysql connector/ODBC 中的注册驱动中，我总是会出现<code>./myodbc-installer: error while loading shared libraries: libodbc.so.2: cannot open shared object file: No such file or directory.</code>这种错误，后来发现错误有两点：</p>
<ol>
<li>我下载的是 mysql-connector-5.3.6 ，可能版本比较高，而我初次下载用的是unixODBC-2.3.0，版本较低，里面没有 libodbc.so.2 这个库文件（可以用<code>find / -name libodbc.so.2</code>来查）。后来下载了一个 unixODBC-2.3.4 就好了。</li>
<li>改了版本之后，我发现还是有这个错误，在网上查了下，说是程序查找默认路径为 /lib 和 /usr/lib，而我的 <a href="http://libmyodbc5w.so">libmyodbc5w.so</a> 和 <a href="http://libmmyodbc5a.so">libmmyodbc5a.so</a> 都在 /usr/local/lib 中，所以查不到，所以需要设置一下共享库路径，以下我贴一下网上查的内容：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/ld.so.conf</span><br><span class="line">include ld.so.conf.d/*.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/usr/local/lib&quot;</span> &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>
<p>2、如果共享库文件安装到了其它&quot;非 /lib 或 /usr/lib &quot; 目录下，但是又不想在 /etc/ld.so.conf 中加路径(或者是没有权限加路径)。那可以 export 一个全局变量 LD_LIBRARY_PATH ，然后运行程序的时候就会去这个目录中找共享库。</p>
<p>LD_LIBRARY_PATH 的意思是告诉 loader 在哪些目录中可以找到共享库。</p>
<p>可以设置多个搜索目录，这些目录之间用冒号分隔开。</p>
<p>比如：</p>
<p>安装了一个 mysql 到 /usr/local/mysql 目录下，其中有一大堆库文件在 /usr/local/mysql/lib 下面，则可以在 .bashrc 或 .bash_profile 或 shell 里加入以下语句即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/local/mysql/lib:<span class="variable">$LD_LIBRARY_PATH</span>    </span><br></pre></td></tr></table></figure>
<p>一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。</p>
<p>3、如果程序需要的库文件比系统目前存在的村文件版本低，可以做一个链接<br>
比如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libncurses.so.4: cannot open shared</span><br><span class="line">object file: No such file or directory</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /usr/lib/libncu*</span><br><span class="line">/usr/lib/libncurses.a   /usr/lib/libncurses.so.5</span><br><span class="line">/usr/lib/libncurses.so  /usr/lib/libncurses.so.5.3</span><br></pre></td></tr></table></figure>
<p>可见虽然没有 libncurses.so.4，但有 libncurses.so.5，是可以向下兼容的<br>
建一个链接就好了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s  /usr/lib/libncurses.so.5.3  /usr/lib/libncurses.so.4</span><br></pre></td></tr></table></figure>
<p>4、isql 连接数据库失败，重新注册驱动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/bin/myodbc-installer  -d -a -n <span class="string">&quot;MySQL_UNICODE&quot;</span>  -t <span class="string">&quot;DRIVER=/usr/lib64/libmyodbc8w.so;SETUP=/usr/lib64/libmyodbc8w.so&quot;</span></span><br><span class="line">/usr/bin/myodbc-installer  -d -a -n <span class="string">&quot;MySQL_ANSI&quot;</span>  -t <span class="string">&quot;DRIVER=/usr/lib64/libmyodbc8a.so;SETUP=/usr/lib64/libmyodbc8a.so&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用 rpm 命令查看 rpm 包的内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -qpl xxx.rpm</span><br></pre></td></tr></table></figure>
<p>可以看到<code>mysql-connector-odbc-8.0.20-1.el7.x86_64.rpm</code>的包内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">warning: mysql-connector-odbc-8.0.20-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">/usr/bin/myodbc-installer</span><br><span class="line">/usr/lib64/libmyodbc8a.so</span><br><span class="line">/usr/lib64/libmyodbc8w.so</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/ChangeLog</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/INFO_BIN</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/INFO_SRC</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/LICENSE.txt</span><br><span class="line">/usr/share/doc/mysql-connector-odbc-8.0.20/README.txt</span><br></pre></td></tr></table></figure>
<p>可以知道 rpm 包 安装的时候各个基础件的安装位置。</p>
]]></content>
      <categories>
        <category>项目经历</category>
      </categories>
  </entry>
  <entry>
    <title>spawn-fcgi 学习笔记</title>
    <url>/2020/08/29/project_experience/spawn-fcgi/</url>
    <content><![CDATA[<h1>spawn-fcgi 用法了解</h1>
<p>spawn-fcgi 是一个小程序，作用是管理 fast-cgi 进程。</p>
<p>用 spawn 启动 FCGI 程序的方式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./spawn-fcgi -a 127.0.0.1 -p 8080 -F <span class="variable">$&#123;count&#125;</span> -f <span class="variable">$&#123;webroot&#125;</span>/bin/demo.fcgi</span><br></pre></td></tr></table></figure>
<p>这样就会启动 count 个 demo.fcgi 程序，他们共同监听同一个 listen 端口 8080，从而提供服务。</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./spawn_fcgi -h</span><br><span class="line">Usage: spawn-fcgi [options] [-- &lt;fcgiapp&gt; [fcgi app arguments]]</span><br><span class="line"></span><br><span class="line">spawn-fcgi v1.6.5 - spawns FastCGI processes</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -f &lt;path&gt;      filename of the fcgi-application (deprecated; ignored <span class="keyword">if</span></span><br><span class="line">                &lt;fcgiapp&gt; is given; needs /bin/sh)</span><br><span class="line"> -d &lt;directory&gt; <span class="built_in">chdir</span> to directory before spawning</span><br><span class="line"> -a &lt;address&gt;   <span class="built_in">bind</span> to IPv4/IPv6 address (defaults to 0.0.0.0)</span><br><span class="line"> -p &lt;port&gt;      <span class="built_in">bind</span> to TCP-port</span><br><span class="line"> -s &lt;path&gt;      <span class="built_in">bind</span> to Unix domain socket</span><br><span class="line"> -M &lt;mode&gt;      change Unix domain socket mode (octal <span class="built_in">integer</span>, default: allow</span><br><span class="line">                <span class="built_in">read</span>+write <span class="keyword">for</span> user and group as far as <span class="built_in">umask</span> allows it)</span><br><span class="line"> -C &lt;children&gt;  (PHP only) numbers of childs to spawn (default: not setting</span><br><span class="line">                the PHP_FCGI_CHILDREN environment variable - PHP defaults to 0)</span><br><span class="line"> -F &lt;children&gt;  number of children to fork (default 1)</span><br><span class="line"> -b &lt;backlog&gt;   backlog to allow on the socket (default 1024)</span><br><span class="line"> -P &lt;path&gt;      name of PID-file <span class="keyword">for</span> spawned process (ignored <span class="keyword">in</span> no-fork mode)</span><br><span class="line"> -n             no fork (<span class="keyword">for</span> daemontools)</span><br><span class="line"> -v             show version</span><br><span class="line"> -?, -h         show this <span class="built_in">help</span></span><br><span class="line">(root only)</span><br><span class="line"> -c &lt;directory&gt; <span class="built_in">chroot</span> to directory</span><br><span class="line"> -S             create socket before <span class="built_in">chroot</span>() (default is to create the socket</span><br><span class="line">                <span class="keyword">in</span> the <span class="built_in">chroot</span>)</span><br><span class="line"> -u &lt;user&gt;      change to user-id</span><br><span class="line"> -g &lt;group&gt;     change to group-id (default: primary group of user <span class="keyword">if</span> -u</span><br><span class="line">                is given)</span><br><span class="line"> -U &lt;user&gt;      change Unix domain socket owner to user-id</span><br><span class="line"> -G &lt;group&gt;     change Unix domain socket group to group-id</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>项目经历</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>xm_ip_service</title>
    <url>/2018/01/21/project_experience/xm_ip_service/</url>
    <content><![CDATA[<h1>xm_ip_service</h1>
<blockquote>
<p>相关技术栈：golang、MySQL、PostgreSQL、linux、Web</p>
</blockquote>
<h2 id="项目需求">项目需求</h2>
<p>通过IP地址（目前仅支持IPV4），进行IP地址相关地理信息的查询，查询过程分为，国内信息查询与国际信息查询两个查询方式。</p>
<h2 id="接口定义">接口定义</h2>
<p>接口内容</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GeoInfo</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="type">string</span> ip,</span><br><span class="line">    <span class="number">2</span>: <span class="type">string</span> geoip_country_code,</span><br><span class="line">    <span class="number">3</span>: <span class="type">string</span> geoip_country_name,</span><br><span class="line">    <span class="number">4</span>: <span class="type">string</span> geoip_city_code,</span><br><span class="line">    <span class="number">5</span>: <span class="type">string</span> geoip_city_name,</span><br><span class="line">    <span class="number">6</span>: <span class="type">i32</span> error_no,</span><br><span class="line">    <span class="number">7</span>: <span class="type">string</span> geoip_province_code,</span><br><span class="line">    <span class="number">8</span>: <span class="type">string</span> geoip_province_name,</span><br><span class="line">    <span class="number">9</span>: <span class="type">string</span> geoip_carrier,</span><br><span class="line">    <span class="number">10</span>: <span class="type">string</span> error_msg,</span><br><span class="line">    <span class="number">11</span>: <span class="type">i64</span> geoip_start_ip,</span><br><span class="line">    <span class="number">12</span>: <span class="type">i64</span> geoip_end_ip</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GeoRequest</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="type">list</span>&lt;<span class="type">string</span>&gt; ipList,</span><br><span class="line">    <span class="number">2</span>: <span class="type">string</span> lang <span class="comment">// en or zh-CN</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">IPService</span> </span>&#123;</span><br><span class="line">   <span class="type">list</span>&lt;GeoInfo&gt; queryGeoInfoByIP(<span class="number">1</span>:<span class="type">list</span>&lt;<span class="type">string</span>&gt; ipList);</span><br><span class="line"></span><br><span class="line">   <span class="type">list</span>&lt;GeoInfo&gt; queryGeoInfo(<span class="number">1</span>:GeoRequest req);</span><br><span class="line"></span><br><span class="line">   <span class="type">list</span>&lt;GeoInfo&gt; queryI18nGeoInfoByIP(<span class="number">1</span>:<span class="type">list</span>&lt;<span class="type">string</span>&gt; ipList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="业务逻辑说明">业务逻辑说明</h2>
<h3 id="hook-go">hook.go</h3>
<p><strong>描述：</strong></p>
<blockquote>
<p>定义并初始化了IP相关地理信息的原始数据结构体，并从文件当中读取所需地理信息数据，给其赋值，该结构体作为IP地理信息参照表，亦或查询表。</p>
</blockquote>
<p><strong>流程：</strong></p>
<blockquote>
<p>在加载配置文件之后，服务正式运行之前，通过New函数初始化该地理信息结构体；<br>
然后，通过Open函数，读取配置里的路径信息，将该路径下文件里的地理信息通过信息的处理，依次读取到GeoModel的中文地理信息（cnGeos）和英文地理信息（enGeos）两个切片中，此时的GeoModel就成为了存储有完整IP相关地理信息的一张参照表；<br>
GeoI18nModel类似，不过后者用作存储国际化的全球IP地理信息，没有中英文的区分，而是利用了命名为Names的Map基本结构扩展了所有所需的语言包，所以无需特意进行语言的区分，查询时打上语言标识即可。</p>
</blockquote>
<h3 id="IPservice-go">IPservice.go</h3>
<blockquote>
<p>定义新建控制器。</p>
</blockquote>
<h3 id="main-go">main.go</h3>
<p><strong>描述：</strong></p>
<blockquote>
<p>定义并初始化了控制器及其进程，以及hook函数的定义以及运行。</p>
</blockquote>
<h3 id="Handler">Handler</h3>
<p><strong>描述：</strong></p>
<table>
<thead>
<tr>
<th>IP_Service_Handler</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>queryGeoInfo_Handler</td>
<td>通过发来的请求里包含的IP地址，参照GeoModel查询对应的地理信息；  如果查询不到或地理位置不在中国，则交给GeoI18nModel来继续查询对比相关的地理信息。  进行合适的日志处理之后，打包返回相关地理信息以及错误信息。</td>
</tr>
<tr>
<td>queryGeoInfoByIP_Handler</td>
<td>与上面不同的是，输入当中直接为IP_list，并没有相关的中英文标识，语言统一预设为中文识别， 当查询到地理信息不是中国的时候，则交给GeoI18nModel来继续查询对比相关的地理信息。</td>
</tr>
<tr>
<td>queryI18nGeoInfoByIP_Handler</td>
<td>与第二条相同，输入也直接为IP_list，不同的是，查询语言预设为英文。 并且是国际IP地理信息的查询服务，所以并不区分是否在“中国”国内。</td>
</tr>
</tbody>
</table>
<p><strong>流程：</strong></p>
<p>见Model里的业务逻辑描述。</p>
<h3 id="Model">Model</h3>
<ul>
<li>geo_model</li>
</ul>
<blockquote>
<p>定义了Geo和GeoModel结构体。及其New函数。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Geo定义了一个地区的IP区间</span></span><br><span class="line"><span class="keyword">type</span> Geo <span class="keyword">struct</span> &#123;</span><br><span class="line"> startIp      <span class="type">uint32</span></span><br><span class="line"> endIp        <span class="type">uint32</span></span><br><span class="line"> countryName  <span class="type">string</span></span><br><span class="line"> provinceName <span class="type">string</span></span><br><span class="line"> cityName     <span class="type">string</span></span><br><span class="line"> districtName <span class="type">string</span></span><br><span class="line"> carrierName  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GeoModel定义了中英文地理信息的数据整体信息，包括了数据路径以及所有中英文地理信息完整的数据切片</span></span><br><span class="line"><span class="keyword">type</span> GeoModel <span class="keyword">struct</span> &#123;</span><br><span class="line"> enDataPath <span class="type">string</span></span><br><span class="line"> cnDataPath <span class="type">string</span></span><br><span class="line"> cnGeos []*Geo</span><br><span class="line"> enGeos []*Geo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>open函数用来从文件中读取IP地理信息到geoModel结构体。该函数在hook.go中调用，用来初始化参照表GeoModel。</li>
<li>charToLong和charTolittle函数用来将IP地址转化为整数(ipValue)，好进行区间比较，以便找到IP的归属地。</li>
<li>search函数和compare函数结合起来，找到ipValue的对应区间，用来查找IP的归属地。</li>
<li>GetInfoByIP函数则整合以上代码，进行查表，将一个IP地址信息，和其语言标识，来查询对应的地理信息表单，返回一个地理信息和相关错误信息。</li>
</ul>
</blockquote>
<ul>
<li>geoi18n_model</li>
</ul>
<blockquote>
<p>定义了Geo和GeoModel结构体。及其New函数。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GeoI18nModel定义了国际IP地理信息数据包，包括了数据路劲以及所有的IP地理信息数据</span></span><br><span class="line"><span class="keyword">type</span> GeoI18nModel <span class="keyword">struct</span> &#123;</span><br><span class="line"> dataPath <span class="type">string</span></span><br><span class="line"> Data     *geoip2.Reader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>open函数用来从文件中读取IP地理信息到GeoI18nModel结构体。该函数在hook.go中调用，用来初始化参照表GeoI18nModel。</li>
<li>GetI18nInfoByIP函数，进行查表操作，查询国际IP地理信息表单，将一个IP地址信息进行解析，然后查询IP地址的所属城市信息，然后依次赋值给需要返回的单个地理信息，最好返回该地理信息和相关错误信息。</li>
</ul>
<h1>重构项目</h1>
<blockquote>
<p>对这个项目进行重构,数据存储层迁移到 PG, 功能上支持 ipv6</p>
</blockquote>
<h2 id="数据存储层迁移到PgSQL">数据存储层迁移到PgSQL</h2>
<ul>
<li>PostgreSQL数据存储设计方案</li>
</ul>
<p>此处数据存储层指的地理位置信息的参照表，原本是以<code>data</code>形式存储在代码包文件当中的，如下。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fze1gt1peoj30tp0gg42n.jpg" alt="data_en"></p>
<p>需要将该文件存储到PG中，以查表的方式来查询IP_geoInfo。</p>
<p>所以需要设计两张表来分别存储这两个文件。命名分别以ip_service_cn/en命名。</p>
<p>设计结果如下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzgnmbjb8uj30hm06r0tg.jpg" alt=""></p>
<p>其中注意</p>
<ul>
<li>PG设置自增语句：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">nextval(<span class="string">&#x27;ip_service_cn_id_seq&#x27;</span>::regclass)</span><br><span class="line">nextval(<span class="string">&#x27;ip_service_en_id_seq&#x27;</span>::regclass)</span><br></pre></td></tr></table></figure>
<ul>
<li>PG插入多个数据的语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> public.ip_service ( start_ip , end_ip , country_name , province_name , city_name , district_name , carrier_name) <span class="keyword">VALUES</span> (<span class="number">16777216</span>,<span class="number">16777471</span>,<span class="string">&#x27;澳大利亚&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>),(<span class="number">16777472</span>,<span class="number">16778239</span>,<span class="string">&#x27;中国&#x27;</span>,<span class="string">&#x27;福建&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;电信&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>PG恢复自增字段序号为1的语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> ip_service_en;</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> ip_service_cn;</span><br><span class="line"><span class="keyword">ALTER</span> SEQUENCE ip_service_cn_id_seq RESTART <span class="keyword">WITH</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">ALTER</span> SEQUENCE ip_service_en_id_seq RESTART <span class="keyword">WITH</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzgnkb78kfj30u60bntby.jpg" alt=""></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzgnklbpfqj30u60didjg.jpg" alt=""></p>
<p>因为查询IP_GEOINFO时，最主要是通过比对ip所处的区间，来得知，查询的IP属于哪一个地址范围，且，start_ip，end_ip有明显的连续性，所以可以由此建立索引。建表语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &quot;public&quot;.&quot;ip_service_en&quot;(</span><br><span class="line">  &quot;id&quot; serial8 <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  &quot;create_time&quot; timestamptz(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> now(),</span><br><span class="line">  &quot;update_time&quot; timestamptz(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> now(),</span><br><span class="line">  &quot;start_ip&quot; int8 <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">	&quot;end_ip&quot; int8 <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  &quot;country_name&quot; <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	&quot;province_name&quot; <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	&quot;city_name&quot; <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	&quot;district_name&quot; <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	&quot;carrier_name&quot; <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX &quot;idx_iprange_en&quot; <span class="keyword">ON</span> &quot;public&quot;.&quot;ip_service_en&quot; (start_ip,end_ip);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &quot;public&quot;.&quot;ip_service_cn&quot;(</span><br><span class="line">  &quot;id&quot; serial8 <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  &quot;create_time&quot; timestamptz(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> now(),</span><br><span class="line">  &quot;update_time&quot; timestamptz(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> now(),</span><br><span class="line">  &quot;start_ip&quot; int8 <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">	&quot;end_ip&quot; int8 <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  &quot;country_name&quot; <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	&quot;province_name&quot; <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	&quot;city_name&quot; <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	&quot;district_name&quot; <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	&quot;carrier_name&quot; <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX &quot;idx_iprange_cn&quot; <span class="keyword">ON</span> &quot;public&quot;.&quot;ip_service_cn&quot; (start_ip,end_ip);</span><br></pre></td></tr></table></figure>
<ul>
<li>数据迁移</li>
</ul>
<blockquote>
<p>因为涉及到的数据量有近五百万条IP地址段，所以需要考虑插入的效率问题。于是结合了两个方案：</p>
</blockquote>
<ul>
<li>开Go程同时往中英文IP表单中插数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> NewInsert(p, <span class="string">&quot;en&quot;</span>, &amp;wg)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> NewInsert(p, <span class="string">&quot;cn&quot;</span>, &amp;wg)</span><br><span class="line">wg.Wait()</span><br><span class="line">Db.Close()</span><br></pre></td></tr></table></figure>
<ul>
<li>结合sql语句，1000条数据提交一次。（见上文PG插入多个数据的语句格式）</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInsert</span><span class="params">(p *GeoModel, tableName <span class="type">string</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> data, sql, sqlHead, sqlData, oneData <span class="type">string</span></span><br><span class="line">	sqlHead = <span class="string">&quot;INSERT INTO public.ip_service_%s ( start_ip , end_ip , country_name , province_name , city_name , district_name , carrier_name)&quot;</span></span><br><span class="line">	sqlData = <span class="string">&quot;(%v,%v,&#x27;%v&#x27;,&#x27;%v&#x27;,&#x27;%v&#x27;,&#x27;%v&#x27;,&#x27;%v&#x27;)&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tableName == <span class="string">&quot;en&quot;</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> k, vousmevoyez := <span class="keyword">range</span> p.enGeos &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> vousmevoyez.StartIP != <span class="number">0</span> &amp;&amp; vousmevoyez.EndIP != <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">				oneData = fmt.Sprintf(sqlData, v.StartIP, v.EndIP, v.CountryName, v.ProvinceName, v.CityName, v.DistrictName, v.CarrierName)</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> k%<span class="number">1000</span> != <span class="number">0</span> &amp;&amp; k &lt; <span class="built_in">len</span>(p.cnGeos) &#123;</span><br><span class="line">					data += oneData</span><br><span class="line">					data += <span class="string">&quot;,&quot;</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					data += oneData</span><br><span class="line">					sql = sqlHead + <span class="string">&quot; VALUES &quot;</span> + data</span><br><span class="line">					fmt.Println(tableName + <span class="string">&quot;***********:**********&quot;</span> + strconv.Itoa(k))</span><br><span class="line">					_, err := Db.Exec(sql)</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						fmt.Println(sql, err)</span><br><span class="line">						TableHandler(<span class="number">0</span>)</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> k%<span class="number">1000</span> == <span class="number">0</span> &#123;</span><br><span class="line">				data = <span class="string">&quot;&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//···略</span></span><br><span class="line">  &#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其间碰到的一个坑：在英文IP地理信息中，名称中有的时候有单引号如<code>Yi'an City</code>这个时候放在sql语句中就会报错，这个时候，如果想要在数据库中正确插入单引号，就要把一个单引号变成两个。所以，增加了一个排查单引号的功能，例子如下：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(tokens) &gt;= <span class="number">3</span> &#123;</span><br><span class="line">		geo.CountryName = tokens[<span class="number">2</span>]</span><br><span class="line">		<span class="keyword">if</span> strings.Contains(geo.CountryName, <span class="string">&quot;&#x27;&quot;</span>) &#123;</span><br><span class="line">			geo.CountryName = strings.Replace(geo.CountryName, <span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;&#x27;&#x27;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>内部代码修改</li>
</ul>
<p>后续只需要将源代码中关于geoModel的结构体做一次重新的适配，搜索的入口做一个重定向就行了，这里不做赘述。</p>
<h2 id="如何支持IPV6">如何支持IPV6</h2>
<p>由于Leader说了，I18N的重构暂时不需要管IPV6的模块，所以就不动，并且，现阶段只需要做出一个能用的IPV6地址查询即可，于是，我首先要下载数据源，然后做地理查询前，同样要先将数据源转移到PG，然后再以类似的逻辑做地理查询，问题的难点在于，数据如何处理，和如何转移数据，以及数据库如何设计等等。</p>
<ul>
<li>地理数据集的处理</li>
</ul>
<p>IPV6地理信息数据集的<a href="https://www.cnblogs.com/kjcy8/p/5787723.html">特性</a></p>
]]></content>
      <categories>
        <category>项目经历</category>
      </categories>
  </entry>
  <entry>
    <title>如何做数据库选型</title>
    <url>/2022/01/25/backend_dev/db_select/</url>
    <content><![CDATA[<h1>常见数据库分类</h1>
<p>在微服务设计中，数据库的选型是不可缺少的一环，后台的核心是与数据打交道，在不同的业务场景选择的数据库不一样，好的数据库选型能够解决业务的性能瓶颈，如果数据库选择不恰当，会使得服务的性能上不去，因此我们需要对一些常用的数据库有一些了解，这样才能因地制宜，发挥系统最好的性能。</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据库类型</th>
<th style="text-align:left">数据库名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">关系型数据库</td>
<td style="text-align:left">MySQL，Oracle，PostgreSQL</td>
</tr>
<tr>
<td style="text-align:left">内存数据库</td>
<td style="text-align:left">Redis，Memcache，Riak</td>
</tr>
<tr>
<td style="text-align:left">时序数据库</td>
<td style="text-align:left">Prometheus，InfluxDB，OpenTSDB</td>
</tr>
<tr>
<td style="text-align:left">文档型数据库</td>
<td style="text-align:left">MongoDB，CouchDB，RavenDB</td>
</tr>
<tr>
<td style="text-align:left">分布式数据库</td>
<td style="text-align:left">TIDB</td>
</tr>
<tr>
<td style="text-align:left">图数据库</td>
<td style="text-align:left">Neo4J，InfiniteGraph，OrientDB，Dgraph</td>
</tr>
<tr>
<td style="text-align:left">列式存储数据库</td>
<td style="text-align:left">Cassandra，HBase，ClickHouse，Elasticsearch</td>
</tr>
<tr>
<td style="text-align:left">文件存储</td>
<td style="text-align:left">EPH，GlusterFS</td>
</tr>
</tbody>
</table>
<h1>考虑角度汇总</h1>
<p><img src="http://pic.colliexyy.com/db_select.jpg" alt=""></p>
<span id="more"></span>
<h1>关系型数据库</h1>
<p>关系数据库的适用场景通常可以分为 <a href="https://baike.baidu.com/item/OLTP/5019563?fr=aladdin#7">OLTP</a> 和 <a href="https://baike.baidu.com/item/%E8%81%94%E6%9C%BA%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86/423874?fromtitle=OLAP&amp;fromid=1049009&amp;fr=aladdin">OLAP</a>。</p>
<p>其中，联机事务处理（OLTP）存储/查询业务应用中<strong>活动的数据</strong>，以支撑日常的业务活动，是每个企业不可或缺的生产交易系统。这类型应用<strong>数据量普遍不大，强调实时、快速响应、数据强一致性</strong>，比如银行存取钱，购物消费。</p>
<p>联机分析处理（OLAP）存储历史数据以支撑复杂的分析操作，侧重于<strong>决策支持</strong>，这类应用<strong>数据量大，高并行、低并发，可用性要求不高</strong>，比如客服系统，销售系统等。</p>
<p>以 MySQL 为例，这是当前最流行的开源关系型数据库，也是 OLTP 场景的首选数据库。</p>
<blockquote>
<p>优点:</p>
</blockquote>
<ul>
<li>成本低，安全，稳定，生态完善</li>
<li>使用简单，方便</li>
<li>使用者多，用来做业务开发，运维比较简单</li>
<li>对于普通业务支持性能很不错</li>
</ul>
<p>对于<strong>请求量，数据量不大</strong>的情况下，对 Mysql 做增删改查的业务性能还是很好的，并且 Mysql 提供<strong>强一致性事务</strong>的支持，<strong>支持多种事务隔离级别</strong>，并且多种存储引擎的选择，使得 Mysql 在数据库中的地位是非常之高的。但是金无足赤人无完人，在业务扩展到一定规模， Mysql 的问题就暴露出来了，主要的问题有：</p>
<blockquote>
<p>缺点:</p>
</blockquote>
<ul>
<li>Mysql 对 OLAP 类型查询支持比较弱</li>
<li>Mysql 是单机数据库，需要开发人员去实现集群部署，维护成本很大</li>
<li>单表数据规模达到亿级别性能会下降</li>
<li>大表加索引很困难，因此很难对大表进行在线优化</li>
</ul>
<p>Mysql 对一些复杂类型的查询支持是很弱的，举个例子，如果我们要做个搜索查询的功能，根据各种指标，范围去数据库中搜索数据，如果业务层通过 Mysql 去实现，前期数据量小的情况下是没多少问题的，但是如果表中数据量越来越多，或者搜索的条件组合很复杂，那么此时会很慢。因此，<strong>复杂查询业务尽量不要使用 Mysql</strong>。另外如果业务扩大到一定规模， Mysql 单表也会变得很大，这个时候性能会受到影响，如果已经不能优化，还需要做分表等扩展措施来解决业务的性能瓶颈。</p>
<p>如果遇到这些情况，目前业界的主流方案除了分区表，分库分表，通过代理中间件进行分表之外，比较热门的就是分布式数据库，分布式数据库最大的特点是能够自由扩展，不要考虑数据量瓶颈的问题。这两年比较流行的是 <a href="https://docs.pingcap.com/zh/tidb/stable/">TIDB 数据库</a>，<strong>TIDB 是一个分布式数据库，最大的优点是兼容 Mysql 协议，并且通过 Raft 协议保证数据一致性</strong>。因此 Mysql 用户可以很简单的迁移到 TIDB 来。并且 TIDB 对一般的 <strong>OLAP 查询支持也比较好</strong>，因此数据量大的情况下使用 TIDB 是一个更好的选择。</p>
<p>关系型数据最大的特点便是<strong>事务</strong>，它能保证数据始终如一的一致性，这里就不得不提及一下事务的 ACID 特性：</p>
<ul>
<li><strong>原子性</strong>：事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生，不存在只执行了其中某一个或者某几个步骤。</li>
<li><strong>一致性</strong>：事务执行后，数据库状态与其业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。</li>
<li><strong>隔离性</strong>：多个事务并发访问时，事务之间是ddddddddddd隔离的，一个事务不应该影响其它事务运行效果。</li>
<li><strong>持久性</strong>：在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，不会因为异常、宕机而造成数据错误或丢失。</li>
</ul>
<p>通用的 SQL 语言使得操作关系型数据库非常方便，支持 join 等复杂查询。</p>
<p><strong>不建议把 OLTP 和 OLAP 业务混在一起</strong>，在典型的 OLAP 处理场景就应该使用面向 OLAP 设计的数据库，而在典型的 OLTP 处理场景就使用面向 OLTP 设计的数据库，否则既达不到 OLAP 的扩展性，又无法满足 OLTP 的实时、高性能等要求。</p>
<p>需要强调的是，特别<strong>不建议基于 OLAP 去增加 TP 的能力</strong>，因为后者是实时和在线，而 AP 更多是分析，OLAP 的数据库往往无法达到性能要求，即便上线初期看似能满足要求，但随着业务量的增加，问题就会凸显出来。</p>
<p>除此之外，还要根据是否支持 JSON 格式、支持的存储模式等维度评估。</p>
<p><strong>网站业务</strong>：网站业务请求写少读多，可使用 MySQL 只读实例水平扩展读负载能力，搭配分布式数据库中间件 DDM 使用，实现自动读写分离和读负载均衡。</p>
<p><strong>移动应用</strong>：包含定位功能的移动应用可使用 Postgre SQL 数据库获得位置运算能力；对于数据庞大的移动应用，搭配 DDM 使用 RDS MySQL 数据库，轻松应对分库分表问题。</p>
<p><strong>游戏业务</strong>：爆发式增长的玩家数据存储和读写请求，可以使用 RDS 快速扩容存储，变更规格或部署新的游戏分区数据库；游戏数据存档或回退，可使用 RDS 自动备份和 PITR 特性随时闪回到任意时间点。</p>
<p><strong>电商业务</strong>：电商“秒杀”、“抢购”等高并发的数据库请求，可使用 RDS 高规格实例；业务连续性要求高的电商业务，可使用 RDS 双机热备，跨 AZ 部署获得更高可用性支持。</p>
<p><strong>金融业务</strong>：金融级业务连续性和数据可靠性要求，可使用 RDS 双机热备，跨 AZ 部署，确保服务高可用，数据多副本存储和强一致性；金融级安全合规要求，可搭配数据库安全服务 DBSS 使用，实时监测并拦截 SQL 注入，防脱敏数据泄露，审计数据库日志。</p>
<p>关系型数据库虽好，但在很多方面也有些力不从心。比如面对<strong>高并发读写需求</strong>时，<strong>多表的关联查询</strong>、<strong>复杂的数据分析类型</strong>，为了保证 ACID 特性而牺牲的性能问题就凸显出来了。</p>
<h1>内存数据库（K-V数据库）</h1>
<p>键值数据库就像在传统语言中使用的哈希表。可以通过 key 来添加、查询或者删除数据，鉴于使用主键访问，所以会获得不错的<strong>性能及扩展性</strong>。它的优势在于<strong>简单、易部署、高并发</strong>。</p>
<p>主流代表产品：Riak、Redis、Memcached</p>
<p><strong>适用场景</strong>：储存用户信息，比如会话、配置文件、参数、购物车等等，具体包括游戏场景中的角色信息、经验道具信息、好友排名，电商场景中的海量商品展示信息、购物评论信息等，这些信息一般都和 ID（键）挂钩，所以键值数据库是个很好的选择。</p>
<p>内存数据库用的多的是 Redis，大多数业务场景都是用做缓存，<strong>少部分对数据安全不敏感的场景</strong>用来做数据持久化，因为 Redis 也支持数据持久化。游戏行业以前用 Memcache 比较多，现在也逐渐向 Redis 靠拢。由于 Redis 数据都放到内存中，并且在局域网环境通信的代价也比较廉价，所以 Redis 的<strong>性能非常好</strong>，并且 Redis <strong>支持多种类型的数据结构</strong>，在不同业务使用都非常方便。</p>
<p>但是 Redis 也有着和 Mysql 相似的问题，单机的 Redis 会有性能瓶颈，理想情况下<strong>单机 Redis QPS 也只能达到 10w</strong>，如果请求量非常大的情况下会对业务造成影响，并且 Redis 是单线程的，虽然单线程能避免 context 切换的开销，但是并<strong>不能利用多核特性</strong>，这在高性能应用领域是一个致命打击。集群化部署需要在业务层做哈希来实现负载均衡，如果涉及到增删节点还需要做数据迁移，这段时间也会对业务造成影响。因此，单线程即成就了 Redis 同时也限制了 Redis，因此有不少大公司在实现多线程 Redis 的项目来解决这个问题。</p>
<h1>文档型数据库</h1>
<p><strong>文档数据库会将数据以文档的形式储存。每个文档都是自包含的数据单元</strong>，是一系列数据项的集合。每个数据项都有一个名称与对应的值，值既可以是简单的数据类型，如字符串、数字和日期等；也可以是复杂的类型，如有序列表和关联对象。<strong>数据存储的最小单位是文档</strong>，同一个表中存储的文档属性可以是不同的，数据可以使用 XML、JSON 或者 JSONB 等多种形式存储。</p>
<p>代表产品：MongoDB、CouchDB、RavenDB</p>
<p>适用场景：</p>
<ul>
<li><strong>日志</strong>：企业环境下，每个应用程序都有不同的日志信息。文档数据库并没有固定的模式，我们可以使用它储存不同的信息。</li>
<li><strong>分析</strong>：因为它的弱模式结构，所以不改变模式下就可以储存不同的度量方法以及添加新的度量。</li>
</ul>
<p><strong>备注</strong>：以 MongDB 为例，其使用场景很大程度上可以对标关系型数据库，但是比较适合处理那些<strong>没有 join、没有强一致性要求且表 Schema 会常变化的数据</strong>。</p>
<p>文档型数据库比较有名的是 MongoDB，MongoDB 是非关系型数据库，<strong>弱一致性</strong>，在 4.0 版本以上开始支持事务，提供 <a href="https://zhuanlan.zhihu.com/p/56868208">snapshot isolation</a> 的事务隔离级别，这个隔离级别和 Mysql 中的 <a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1245268672511968">repeatable read</a> 隔离级别相同。MongoDB 内部采用 <a href="https://www.runoob.com/mongodb/mongodb-gridfs.html">GridFS</a> 做数据落地，<strong>对一些文件对象支持比较友好</strong>。MongoDB 支持多种存储引擎，可以适应不同的场景，并且使用方便，对一致性要求不高的业务场景用的很多，<strong>常用来存储一些加工的中间数据，方便去展示</strong>，也有一些公司使用 MongoDB 做最终<strong>数据落地</strong>，因此，很多进行<strong>数据展示</strong>的业务可以使用使用 MongoDB，或者查询条件多样并且想提高查询速度的场景也可以使用 MongoDB 替换 Mysql。</p>
<p>MongoDB 虽然优点很多，但是也有很多场景是不适应的，刚刚提到过 Mysql 是弱一致的，因此<strong>一些重要数据为了安全性考虑，不建议用 MongoDB</strong>。并且 <strong>MongoDB 比较吃内存</strong>，如果返回大批量数据，会有内存不够直接查询失败的情况，MongoDB 对 OLAP 查询支持很弱，因此<strong>比较复杂的查询场景也不建议使用 MongoDB</strong>。</p>
<h1>列式存储数据库</h1>
<p>列存储数据库将数据储存在列族中，<strong>一个列族存储经常被一起查询的相关数据</strong>。举个例子，如果有一个 Person 类，我们通常会一起查询他们的姓名和年龄而不是薪资。这种情况下，姓名和年龄就会被放入一个列族中，而薪资则在另一个列族中。</p>
<p>代表产品：Cassandra、HBase、ClickHouse、ElasticSearch</p>
<p>适用场景：</p>
<ul>
<li><strong>日志</strong>：可以将数据储存在不同的列中，每个应用程序能够将信息写入自己的列族中。</li>
<li><strong>博客平台</strong>：储存每个信息到不同的列族中，举个例子，标签可以储存在一个列族，类别、文章也可以分别存储在不同的列族。</li>
</ul>
<p>提到列式存储数据库有必要先说一下什么是行式存储，像 Mysql 这种属于行式存储，当我们查询数据，都是以行为单位在磁盘存储，然后再内存做字段挑选返回给用户，如果表的字段很多我们<strong>只查找一部分字段</strong>这样磁盘查找的开销就会很大，在列式存储数据库中，数据存在磁盘以列为单位，我们查询某些字段只需要在对应的列上进行搜寻，这样性能就会提高。</p>
<p>列式存储比较出名的数据库是 ClickHouse，ClickHouse 是定义为 <a href="https://baike.baidu.com/item/%E8%81%94%E6%9C%BA%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86/423874?fromtitle=OLAP&amp;fromid=1049009&amp;fr=aladdin">OLAP</a> 类型的数据库，专门用来处理数据分析型业务。ClickHouse 采取了<strong>并行处理机制</strong>，所以做分析查询速度非常快，对于一些搜索，分析，数据规模大的查询性能支持非常好，所以这种业务可以采用 ClickHouse 去做。但是由于 ClickHouse 专为分析查询而生，因此<strong>对于更新删除操作支持并不是怎么好</strong>，修改删除都是采取的追加写方式，主要是为了避免随机 IO，ClickHouse 会在底层异步的去做数据合并，如果需要频繁的对数据源进行修改，那绝对不要使用 ClickHouse。如果需要写入数据，也需要采取批量写入的方式，ClickHouse 会对数据进行压缩存储，提高资源利用率。</p>
<p>列式存储另一个比较出名的是 Elasticsearch，在一些偏向搜索的场景比较用的比较多，<strong>支持倒排索引</strong>，并且<strong>支持各种聚合运算</strong>，<strong>查询性能强劲</strong>，但是成本相比ClickHouse 比较高昂，可以根据业务进行选型考虑。</p>
<h1>时序数据库</h1>
<p>时序数据库就是存放时序数据的数据库，它需要支持时序数据的<strong>快速写入、持久化、多纬度的聚合查询</strong>等基本功能。对比传统数据库仅仅记录了数据的当前值，时序数据库记录了所有的历史数据。它的查询也总是会带上时间作为过滤条件，数据以时间流的方式存在，每条记录包括时间戳。可以更加高效快速的存储大量时间序列数据并对这些数据进行实时分析。</p>
<p>代表产品：Prometheus、InfluxDB 和 OpenTSDB</p>
<p>适用场景：IoT 传感器时序数据分析；证券及加密货币交易数据；软硬件设备实时监控；都市环保数据采集等等。</p>
<p>时序数据库从字面意思理解来说是关于时间点的数据，时间序列表示的数据，一般在<strong>指标采样</strong>的场景会用到，可以很直观的看出数据随时间变化，比较著名的有 OpenTSDB，时序数据随时间增长，如果数据没有变化重复取上一个值。<strong>时序数据库适用于大批量的数据采样分析</strong>，常用在批处理，流处理后的数据落地，这些数据经过加工后直接批量写入到 OpenTSDB 中，供业务层访问，以提高查询性能。美中不足的是如果数据加工错误，纠错成本太大。OpenTSDB 底层是用的 HBase，HBase 特点是对写性能支持比较好，底层也是为了避免随机 IO 采用追加写的技术。读通过顺序读保证性能，如果是随机读性能会很差，因此 OpenTSDB 应用场景限制于<strong>按时间维度分析数据</strong>的场景。</p>
<h1>图数据库</h1>
<p>数据以图的方式储存。实体会被作为顶点，而实体之间的关系则会被作为边。比如我们有三个实体，Steve Jobs、Apple 和 Next，则会有两个“Founded by”的边将 Apple 和 Next 连接到 Steve Jobs。</p>
<p>代表产品：Neo4J、InfiniteGraph、OrientDB、Dgraph</p>
<p>适用场景：</p>
<ul>
<li>在一些<strong>关系性强的数据</strong>中，用于构建关系图谱，例如：<strong>社交网络、交通地图</strong>。</li>
<li><strong>推荐引擎</strong>：如果我们将数据以图的形式表现，会非常有益于推荐的制定。</li>
</ul>
<h1>分布式文件存储系统</h1>
<p>常用的分布式文件系统有 HDFS，Ceph，GlusterFS 等，种类非常多，不同的分布式文件存储系统适用不同的场景，每种系统适用的场景不一样，比如有些对大文件支持比较好，有些对中小文件支持比较好。基本上所有分布式文件系统都支持对象存储，块存储，文件存储中的两种以上。<strong>分布式文件存储系统常用来存储文件，比如文档，照片，电源，视频这种</strong>。不像数据库那种存储一些数据，并且分布式文件系统<strong>不支持那种维度查询</strong>，这是和数据库的最大区别。</p>
<p>分布式文件存储系统的选型要根据文件的形式，大小，用途去考虑。还需要对参数做大量的调优以得到最佳的性能。传统的本地文件系统文件都是存在磁盘中，而分布式文件系统文件需要存储在其他节点，本地进行访问时还需要经过网络中转的开销，如果文件比较大，带宽就限制了传输的速度。这个时候就需要进行将文件分片进行存储。以 GlusterFS 为例， GlusterFS 的 Distributed Volumes 属于分布式卷，如果需要保证数据安全可以做冗余，GlusterFS 支持 Replica 和纠删码两种数据冗余方式，如果做数据冗余，会影响读写性能。在做选型时，有这两方面考虑，如果追求极致的数据安全，使用 Replica Volumes，如果为了性能，也为了安全，使用纠删码的方式，如果追求极致性能，可以考虑分布式卷，但是如果出现机器宕机则会造成数据丢失。</p>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp 学习笔记</title>
    <url>/2020/08/29/backend_dev/cpp/</url>
    <content><![CDATA[<h1>Vector 遍历</h1>
<blockquote>
<p><code>vector&lt;int&gt; v1&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10&#125;;</code></p>
</blockquote>
<h2 id="通过数组下标遍历">通过数组下标遍历</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h2 id="通过迭代器遍历">通过迭代器遍历</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = v1.<span class="built_in">begin</span>(); iter != v1.<span class="built_in">end</span>(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
 <span id="more"></span>
<h2 id="auto-关键字遍历">auto 关键字遍历</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = v1.<span class="built_in">begin</span>(); iter != v1.<span class="built_in">end</span>(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v1)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h2 id="for-each-加函数">for_each 加函数</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printer</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot;; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    for_each(v1.<span class="built_in">cbegin</span>(), v1.<span class="built_in">cend</span>(), printer&lt;<span class="type">int</span>&gt;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h1>计时方法 chrono</h1>
<p><strong>传统计时方法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">clock_t</span> start = <span class="built_in">clock</span>();</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line"><span class="type">clock_t</span> end   = <span class="built_in">clock</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;花费了&quot;</span> &lt;&lt; (<span class="type">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;秒&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>此方法可以精确到毫秒，输出样例：<strong>花费了0.123秒</strong></p>
<p><strong>C++11 最佳计时方法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>   </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> start = system_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line"><span class="keyword">auto</span> end   = system_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> duration = <span class="built_in">duration_cast</span>&lt;microseconds&gt;(end - start);</span><br><span class="line">cout &lt;&lt;  <span class="string">&quot;花费了&quot;</span> &lt;&lt; <span class="built_in">double</span>(duration.<span class="built_in">count</span>()) * microseconds::period::num / microseconds::period::den &lt;&lt; <span class="string">&quot;秒&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//duration_cast&lt; &gt; 表示类型转换</span></span><br><span class="line"><span class="comment">//microseconds 表示微妙。除此之外，还有五种时间单位：hours, minutes, seconds, milliseconds, nanoseconds</span></span><br><span class="line"><span class="comment">//num 和 den分别表示分子(numerator)和分母(denominator)。在我给出的代码中，num等于1， den等于1,000,000</span></span><br><span class="line"><span class="comment">//count( ) 用来返回时间</span></span><br></pre></td></tr></table></figure>
<h1>Vector 去重</h1>
<p>使用场景上来说 vector不便于做删除操作 所以一般vector的删除需要借助别的数据结构。</p>
<p>**方法一：**使用 set</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveRepeat1</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">setVec</span><span class="params">(vec.begin(), vec.end())</span></span>;</span><br><span class="line">    vec.<span class="built_in">assign</span>(setVec.<span class="built_in">begin</span>(), setVec.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：</strong> 使用 sort + unique 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveRepeat2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// unique让所有重复的数都放到最后，返回一个迭代器</span></span><br><span class="line">    <span class="comment">// 1 2 3 4 3 就是返回3的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">unique</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">erase</span>(it, vec.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>map 插入数据的方法</h1>
<p>在构造map容器后，我们就可以往里面插入数据了。这里有三种插入数据的方法：</p>
<p><strong>方法一：</strong> 用 insert 函数插入 pair 数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStudent;</span><br><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>,“student_one”));</span><br></pre></td></tr></table></figure>
<p><strong>方法二：</strong> 用 insert 函数插入 value_type 数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStudent;</span><br><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">1</span>,<span class="string">&quot;student_one&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>方法三：</strong> 用 make_pair</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><strong>方法四：</strong> 用数组方式插入数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStudent;</span><br><span class="line">mapStudent[<span class="number">1</span>] = “student_one”;</span><br><span class="line">mapStudent[<span class="number">2</span>] = “student_two”;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mapStudent;</span><br><span class="line">string s;</span><br><span class="line">m[s]++;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong> insert 函数插入数据，在数据的插入上，涉及到集合的唯一性这个概念，即当 map 中有这个关键字时，insert 操作是不能再插入这个数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对应的值。</p>
<p><strong>PS:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line"></span><br><span class="line">    for_each(m.<span class="built_in">cbegin</span>(), m.<span class="built_in">cend</span>(), [](<span class="type">const</span> pair&lt;<span class="type">int</span>, string&gt; &amp;it)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first:&quot;</span> &lt;&lt; it.first &lt;&lt; <span class="string">&quot; second:&quot;</span> &lt;&lt; it.second &lt;&lt; endl;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lambda 中的参数列表要写成 pair 类型，因为 map 返回的是一对数据，是 pair 型的，不可只用 map&lt;int,string&gt;::iterator it 迭代器来遍历。</span></span><br></pre></td></tr></table></figure>
<h1>那些年我们总会遇到的坑</h1>
<h2 id="curl">curl</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CurlCXX <span class="title">curl</span><span class="params">(url, <span class="number">1</span>)</span></span>; <span class="comment">//1s timeout</span></span><br><span class="line">curl.<span class="built_in">post</span>(body);</span><br></pre></td></tr></table></figure>
<ul>
<li>注意学会<code>curl</code>发包的用法，并且<code>post</code>时，<code>body</code>当中要注意<code>fastcgi</code>框架当中约定了<code>post</code>数据格式为<code>x-www-form-urlencoded/form-data</code>，因此一定要注意<code>body</code>里面的数据，单个字段内不能出现容易导致解析错误的<code>'&amp;'</code>字符，若不得不包含<code>'&amp;'</code>字符，则要用转义字符<code>'\&amp;'</code>包起来，否则会导致参数错误。</li>
</ul>
 <!--more-->
<h2 id="const">const</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> CallRecord *app;</span><br><span class="line">app = <span class="built_in">app_ptr</span>();</span><br><span class="line"><span class="built_in">const_cast</span>&lt;CallRecord *&gt;(app)-&gt;<span class="built_in">reload_cache</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>注意对<code>const</code>类型的对象操作时，需要用<code>const_cast&lt;XXXXXX&gt;</code>对该对象进行强制类型转换。</li>
</ul>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>收集一些常见算法</title>
    <url>/2022/05/30/backend_dev/algorithm/</url>
    <content><![CDATA[<h1>翻转字符串</h1>
<p>以字符串中间字符为中心，遍历交换前后字符来达到翻转的目的</p>
<p>因为中英文字符所占用byte的长度不一致，一个中文字符在utf-8编码集中占用3个字节，导致len()会出现问题，故使用如下方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">str := <span class="string">&quot;hello世界&quot;</span></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">strArr := []<span class="type">rune</span>(str)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(strArr))</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">fmt.Println(utf8.RuneCountInString(str)) <span class="comment">// 调用 unicode/utf8 标准库</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseString</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	strArr := []<span class="type">rune</span>(str)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strArr)/<span class="number">2</span>; i++ &#123;</span><br><span class="line">		strArr[<span class="built_in">len</span>(strArr)<span class="number">-1</span>-i], strArr[i] = strArr[i], strArr[<span class="built_in">len</span>(strArr)<span class="number">-1</span>-i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(strArr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;hello世界&quot;</span></span><br><span class="line">	fmt.Println(ReverseString(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>堆排序和快速排序的原理</h1>
<h2 id="堆排序">堆排序</h2>
<p>原理阐述： 1. 建堆 2. 堆调整 3. 堆排序</p>
<p>我们一般提到堆排序里的堆指的是二叉堆（binary heap），是一种完全二叉树，二叉堆有两种：最大堆和最小堆，特点是父节点的值大于（小于）两个小节点的值。完全二叉树有一个性质是，除了最底层，每一层都是满的。</p>
<h2 id="快速排序">快速排序</h2>
<p>原理阐述：分而治之</p>
<p>实现步骤：</p>
<p>先从数列中取出一个数作为基准数。分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。再对左右区间重复第二步，直到各区间只有一个数（各个区间都为有序）。</p>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 学习笔记</title>
    <url>/2021/06/18/backend_dev/docker/</url>
    <content><![CDATA[<h1>Docker 基础知识</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run ubuntu:15.10 /bin/echo <span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>参数含义：</strong></p>
<ul>
<li><code>docker</code>：Docker 的二进制执行文件。</li>
<li><code>run</code>：与前面的 docker 组合来运行一个容器。</li>
<li><code>ubuntu:15.10</code>：指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li><code>/bin/echo &quot;Hello world&quot;</code>：在启动的容器里执行的命令</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -i -t ubuntu:15.10 /bin/bash</span><br></pre></td></tr></table></figure>
<p><strong>参数含义：</strong></p>
<ul>
<li><code>-t</code>：在新容器内指定一个伪终端或终端。</li>
<li><code>-i</code>：允许你对容器内的标准输入 <code>stdin</code> 进行交互</li>
<li>可以通过运行 <code>exit</code> 命令或者使用 <code>ctrl+D</code> 来退出容器，会导致容器停止</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-d</code>：让容器在后台运行。</li>
<li><code>-P</code>：将容器内部使用的网络端口随机映射到我们使用的主机上。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker commit &lt;CONTAINER ID&gt; &lt;REPOSITORY&gt;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><strong>参数含义：</strong><br>
<code>-a</code>：提交的镜像作者;<br>
<code>-c</code>：使用Dockerfile指令来创建镜像;<br>
<code>-m</code>：提交时的说明文字;<br>
<code>-p</code>：在commit时，将容器暂停</p>
<table>
<thead>
<tr>
<th>commend</th>
<th>result</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>docker ps</code></td>
<td>查看正在运行的容器</td>
</tr>
<tr>
<td><code>docker ps -a</code></td>
<td>查看所有容器</td>
</tr>
<tr>
<td><code>docker stop &lt;CONTAINER ID/REPOSITORY&gt;</code></td>
<td>关闭容器</td>
</tr>
<tr>
<td><code>docker logs &lt;CONTAINER ID/REPOSITORY&gt;</code></td>
<td>查看容器内的标准输出</td>
</tr>
<tr>
<td><code>docker pull &lt;IMAGE_NAME&gt;</code></td>
<td>载入镜像</td>
</tr>
<tr>
<td><code>docker restart &lt;CONTAINER ID&gt;</code></td>
<td>重启停止的容器</td>
</tr>
<tr>
<td><code>docker attach &lt;CONTAINER ID&gt;</code></td>
<td>进入后台运行中的容器</td>
</tr>
<tr>
<td><code>docker exec &lt;CONTAINER ID&gt;</code></td>
<td>退出容器，不会导致容器的停止</td>
</tr>
<tr>
<td><code>docker export &lt;CONTAINER ID&gt; &gt; xxx.tar</code></td>
<td>导出本地某个容器</td>
</tr>
<tr>
<td>`cat docker/xxx.tar</td>
<td>docker import - <EPOSITORY>:<TAG>`</td>
</tr>
<tr>
<td><code>docker import &lt;URL&gt; &lt;EPOSITORY&gt;</code></td>
<td>导入容器快照</td>
</tr>
<tr>
<td><code>docker rm -f &lt;CONTAINER ID&gt;</code></td>
<td>删除容器<code>-f</code>:强制删除;<code>-no-prune</code>:不要删除未带标签的父镜像</td>
</tr>
<tr>
<td><code>docker container prune</code></td>
<td>清理掉所有处于终止状态的容器</td>
</tr>
<tr>
<td><code>docker rm $(docker container ls -aq)</code></td>
<td>删除所有容器</td>
</tr>
<tr>
<td><code>docker commit &lt;CONTAINER ID&gt; &lt;REPOSITORY&gt;</code></td>
<td>把容器打包成镜像</td>
</tr>
<tr>
<td><code>docker inspect &lt;REPOSITORY&gt;:&lt;CONTAINER ID&gt;</code></td>
<td>查看镜像的详细信息</td>
</tr>
<tr>
<td><code>docker rm $(docker container ls -f &quot;status=exited&quot; -q)</code></td>
<td>同时删除多个符合筛选条件(状态为“exited”)的容器</td>
</tr>
</tbody>
</table>
<h1>Docker 复杂操作合集</h1>
<h2 id="端口映射">端口映射</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it -p 8080:18026 &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>
<p><code>-p</code>：是容器内部端口绑定到指定的主机端口。这里指将主机的8080端口映射到容器的18026端口。-p可以多个端口映射同时存在以实现复杂功能</p>
</br>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it -p 127.0.0.1:8080:18026 &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>
<p>这样我们就可以通过访问 127.0.0.1:8080 来访问容器的 18026 端口。</p>
</br>
<p>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 /udp。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it -p 127.0.0.1:8080:18026/udp &lt;REPOSITORY&gt;:&lt;TAG&gt; /bin/bash</span><br></pre></td></tr></table></figure>
</br>
<p><code>docker port &lt;CONTAINER ID&gt; &lt;PORT&gt;</code>命令可以让我们快捷地查看端口的绑定情况。</p>
<h2 id="代码调试">代码调试</h2>
<p>centos的依赖<code>cmake/gcc/gdb/gdb-gdbserver/openssh-server/openssh-clients</code></p>
<p>docker要以特权模式启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --privileged=<span class="literal">true</span> -v /Users/liuxing1/Files/Docker_Files/Shared\ Folders/:/tmp -p 8080:22 -p 8000:18080 mdm_docker /usr/sbin/init</span><br></pre></td></tr></table></figure>
<p>然后通过<code>docker exec -it &lt;Container_ID&gt; /bin/bash</code>进入容器操作</p>
<p>启动sshd服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">systemctl start sshd</span><br><span class="line"> </span><br><span class="line"><span class="comment">#设置开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> sshd</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置密码</span></span><br><span class="line">passwd</span><br></pre></td></tr></table></figure>
<h2 id="容器和本机互传文件">容器和本机互传文件</h2>
<p>首先需要确定 docker 容器的<code>container_id</code>,可以使用<code>docker ps -a</code>查看你要操作的 docker 容器的<code>container_id</code></p>
<h3 id="容器向本机传送文件">容器向本机传送文件</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> container_id:docker容器内的文件全路径 本机保存文件的全路径</span><br></pre></td></tr></table></figure>
<p><strong>例如：</strong><code>docker cp 4a2f08d2c1f8:/data1/configure.txt E:\PHP\configure.txt</code></p>
<h3 id="本机向容器传送文件">本机向容器传送文件</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> 本机保存文件的全路径 container_id:docker容器内的文件全路径</span><br></pre></td></tr></table></figure>
<p><strong>例如：</strong><code>docker cp E:\PHP\configure.txt 4a2f08d2c1f8:/data1/configure.txt</code></p>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2020/10/16/backend_dev/git/</url>
    <content><![CDATA[<h1>git 基本命令</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&#x27;XXX&#x27;</span></span><br><span class="line">git config --global user.email <span class="string">&#x27;XXX&#x27;</span></span><br><span class="line">git init                    // 初始化代码仓库</span><br><span class="line">git add learngit.txt        // 把所有要提交的文件修改放到暂存区</span><br><span class="line">git commit -m <span class="string">&#x27;add a file&#x27;</span>  // 把暂存区的所有内容提交到当前分支</span><br><span class="line">git commit -s -m            // 添加 signed-off-by 信息，在日志中增加提交者签名</span><br><span class="line">git commit -a -m            // 相当于git add . 与git commit –m “本次提交描述”两句操作合并为一句进行使用。</span><br><span class="line">git status                  // 查看工作区状态</span><br><span class="line">git status -s               // 查看改变的文件列表简化版</span><br><span class="line">git diff                    // 查看不在缓冲区的文件的修改内容</span><br><span class="line">git diff --cached           // 查看缓冲区的文件发生的改变</span><br><span class="line">git diff --staged           // 查看缓冲区的文件发生的改变</span><br><span class="line">git diff HEAD               // 是 git diff 和 git diff --cached 的合并</span><br><span class="line">git <span class="built_in">log</span>                     // 查看提交历史</span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline    // 单行显示</span><br><span class="line">git reset --hard HEAD^      // 回退到上一个版本，其中（HEAD^^(上上版本),HEAD~100(往上100个版本)）</span><br><span class="line">git reset --hard &lt;commit_id&gt;//(版本号) 可回到指定版本</span><br><span class="line">git reflog                  // 查看历史命令</span><br><span class="line"></span><br><span class="line">git diff HEAD -- &lt;file&gt;     // 查看工作区和版本库里最新版本的区别</span><br><span class="line">git checkout -- &lt;file&gt;      // 用版本库的版本替换工作区的版本，无论是工作区的修改还是删除，都可以<span class="string">&#x27;一键还原&#x27;</span></span><br><span class="line">git reset HEAD &lt;file&gt;       // 把暂存区的修改撤销掉，重新放回工作区。</span><br><span class="line">git <span class="built_in">rm</span> &lt;file&gt;               // 删除文件，若文件已提交到版本库，不用担心误删，但是只能恢复文件到最新版本</span><br><span class="line"></span><br><span class="line">git checkout -b dev         // 创建并切换分支</span><br><span class="line"><span class="comment">#相当于git branch dev 和git checkout dev </span></span><br><span class="line">git branch                  // 查看当前分支，当前分支前有个*号</span><br><span class="line">git branch &lt;name&gt;           // 创建分支</span><br><span class="line">git checkout &lt;name&gt;         // 切换分支</span><br><span class="line">git merge &lt;name&gt;            // 合并某个分支到当前分支</span><br><span class="line">git branch -d &lt;name&gt;        // 删除分支</span><br><span class="line">git <span class="built_in">log</span> --graph             // 查看分支合并图</span><br><span class="line">/* 禁用Fast forward合并dev分支*/</span><br><span class="line">git merge --no-ff -m <span class="string">&#x27;message&#x27;</span> dev</span><br><span class="line">git stash                   // 隐藏当前工作现场，等恢复后继续工作</span><br><span class="line">git stash list              // 查看stash记录</span><br><span class="line">git stash apply             // 仅恢复现场，不删除stash内容</span><br><span class="line">git stash drop              // 删除stash内容</span><br><span class="line">git stash pop               // 恢复现场的同时删除stash内容</span><br><span class="line">git branch -D &lt;name&gt;        // 强行删除某个未合并的分支</span><br><span class="line"><span class="comment">#开发新feature最好新建一个分支</span></span><br><span class="line">git remote                  // 查看远程仓库</span><br><span class="line">git remote -v               // 查看远程库详细信息</span><br><span class="line">git pull                    // 抓取远程提交</span><br><span class="line">/* 在本地创建和远程分支对应的分支*/</span><br><span class="line">git checkout -b branch-name origin/branch-name</span><br><span class="line">/* 建立本地分支和远程分支的关联*/</span><br><span class="line">git branch --set-upstream branch-name origin/branch-name</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1>ssh</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 创建SSH Key</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&#x27;your_email&#x27;</span></span><br><span class="line"></span><br><span class="line">// 关联本地仓库，远程库的名字为origin   </span><br><span class="line">git remote add origin git@github.com:username/repostery.git</span><br><span class="line"></span><br><span class="line">// 第一次把当前分支master推送到远程时要加 -u</span><br><span class="line">// -u 参数不但推送，而且将本地的分支和远程的分支关联起来</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h1>tag</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag v1.0                    //给当前分支最新的commit打标签sh</span><br><span class="line">/* -a指定标签名，-m指定说明文字*/</span><br><span class="line">git tag -a v0.1 -m <span class="string">&#x27;version 0.1 released&#x27;</span> 3628164</span><br><span class="line">git tag -s &lt;tagname&gt; -m <span class="string">&#x27;blabla&#x27;</span>//可以用PGP签名标签</span><br><span class="line">git tag                         //查看所有标签</span><br><span class="line">git show v1.0                   //查看标签信息</span><br><span class="line">git tag -d v0.1                 //删除标签</span><br><span class="line">git push origin &lt;tagname&gt;       //推送某个标签到远程</span><br><span class="line">git push origin --tags          //推送所有尚未推送的本地标签</span><br></pre></td></tr></table></figure>
<h1>reset</h1>
<p><code>git reset –option &lt;commitid&gt;</code>是回滚命令，option 有三个参数可选：</p>
<ol>
<li><code>–mixed</code>，这也是默认方式（即不带参数默认是这种），回退暂存区和版本库信息，<strong>工作区的源码不会变化</strong>，可以重新add，重新commit。</li>
<li><code>-soft</code>，回退版本库信息，<strong>暂存区和工作区都不会变化</strong>，如果还要提交，暂存区已经 add 完毕，直接 commit 即可。</li>
<li><code>–hard</code>，彻底回退，<strong>版本库信息、暂存区和工作区都回退到历史某个版本</strong>。</li>
</ol>
<h1>git 复杂操作合集</h1>
<h2 id="回滚某个文件-2">回滚某个文件</h2>
<ol>
<li><code>git log –pretty=oneline &lt;file&gt;</code>可以查看某个文件的修改历史。</li>
<li><code>git show commit_id &lt;file&gt;</code>可以查看对应某个<code>commit</code>时期<code>file</code>的内容。</li>
<li><code>git reset commit_id &lt;file&gt;</code>可以将<code>file</code>回退到某个版本</li>
<li>执行完第3步后提示：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Unstaged changes after reset:</span><br><span class="line">M       README.md</span><br></pre></td></tr></table></figure>
<p>执行<code>git status</code>，提示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   README.md</span><br></pre></td></tr></table></figure>
<p>执行<code>git checkout — &lt;file&gt;</code>后，README.md成功回滚到指定版本。</p>
<h2 id="聚合commit-msg">聚合commit_msg</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rebase -i &lt;commit_ID&gt;</span><br><span class="line">git rebase -i master</span><br><span class="line">git rebase -i HEAD~&lt;num&gt;</span><br><span class="line"></span><br><span class="line">// squash：将这一行的 commit 与上一个 commit 进行合并</span><br><span class="line">// fixup：与 squash 相同，只是不会保留这行 commit 的提交 message 信息</span><br><span class="line"></span><br><span class="line">// 修改上一次 commit 提交的 message</span><br><span class="line">git commit --amend</span><br><span class="line">// 不过只能修正上一次的 commit。如果很多个 commit 之前就有 message 写错，就得用上我们之前说的 git rebase 了</span><br><span class="line"></span><br><span class="line">// 自动标记这一次的 commit 为上一个 commit 的 fix</span><br><span class="line">git commit --fixup &lt;commit&gt;</span><br><span class="line">// 自动组织合并两个 commit</span><br><span class="line">git rebase -i --autosquash</span><br><span class="line"></span><br><span class="line">// 撤销过去的 commit 重建一个新的</span><br><span class="line">git reset HEAD~2</span><br><span class="line">git add .</span><br><span class="line">git commit -am <span class="string">&quot;This is the new feature&quot;</span></span><br><span class="line">git push --force</span><br></pre></td></tr></table></figure>
<h2 id="修改提交至其他分支">修改提交至其他分支</h2>
<blockquote>
<p>当前处于 A 分支，需要将此次的代码提交至 B 分支，则在没有进行 commit 之前可以进行以下操作</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 1、通过git stash将工作区恢复到上次提交的内容，同时备份本地所做的修改</span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line">// 2、然后切换至B分支</span><br><span class="line">git checkout B</span><br><span class="line"></span><br><span class="line">// 3、从git栈中获取到最近一次stash进去的内容，恢复工作区的内容，获取之后，会删除栈中对应的stash</span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line">// 4、然后进行正常的提交代码步骤即可</span><br><span class="line">git add ...</span><br><span class="line">git commit -m <span class="string">&quot;功能开发&quot;</span></span><br><span class="line">git pull origin &lt;分支名称&gt;</span><br><span class="line">git push origin &lt;分支名称&gt;</span><br></pre></td></tr></table></figure>
<h2 id="本地连接远端仓库">本地连接远端仓库</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;url&gt;</span><br><span class="line">git pull --rebase origin master</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h2 id="强制拉取最新代码">强制拉取最新代码</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/&lt;develop&gt;</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<h2 id="git-stash-临时保存修改">git stash 临时保存修改</h2>
<p><code>stash</code>命令可用于临时保存和回复修改，可跨分支。</p>
<p>**注：**在未<code>add</code>之前才能执行<code>stash</code>！！！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">//把暂存区内的修改存储起来：</span><br><span class="line">	git stash </span><br><span class="line">//切换到正确的分支：</span><br><span class="line"> 	git checkout 分支名</span><br><span class="line">//将存储的修改取出来： </span><br><span class="line">	git stash pop</span><br><span class="line">// 继续进行提交等正常的操作</span><br><span class="line"></span><br><span class="line">git stash [save message]</span><br><span class="line"><span class="comment"># 保存，save 为可选项，message 为本次保存的注释</span></span><br><span class="line"></span><br><span class="line">git stash list</span><br><span class="line"><span class="comment"># 所有保存的记录列表</span></span><br><span class="line"></span><br><span class="line">git stash pop stash@&#123;num&#125;</span><br><span class="line"><span class="comment"># 恢复，num是可选项，通过git stash list可查看具体值。只能恢复一次</span></span><br><span class="line"></span><br><span class="line">git stash apply stash@&#123;num&#125;</span><br><span class="line"><span class="comment"># 恢复，num是可选项，通过git stash list可查看具体值。可回复多次</span></span><br><span class="line"></span><br><span class="line">git stash drop stash@&#123;num&#125;</span><br><span class="line"><span class="comment"># 删除某个保存，num是可选项，通过git stash list可查看具体值</span></span><br><span class="line"></span><br><span class="line">git stash clear</span><br><span class="line"><span class="comment"># 删除所有保存</span></span><br></pre></td></tr></table></figure>
<h2 id="git-submodule-管理">git submodule 管理</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule add xxx</span><br><span class="line">git <span class="built_in">clone</span> --recurse-submodules xxx</span><br></pre></td></tr></table></figure>
<h1>出错解决方案合集</h1>
<ul>
<li>‘fatal:remote origin already exists’</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> origin</span><br><span class="line">git remote add origin XXX</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<ul>
<li>如何删除 git 远程仓库项目的所有内容，重新提交所有内容</li>
</ul>
<blockquote>
<p>忘记添加 <strong>gitignore</strong> 文件</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cache .</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;gitignore working&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>git 取消本地修改</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 未添加到暂存区</span><br><span class="line">git checkout -- &lt;filepathname&gt;</span><br><span class="line"></span><br><span class="line">// 放弃所有的文件修改</span><br><span class="line">git checkout .  </span><br><span class="line"></span><br><span class="line">// add 到了缓存区的代码</span><br><span class="line">git reset HEAD &lt;filepathname&gt;</span><br><span class="line"></span><br><span class="line">// 放弃所有缓存区代码，回退到已修改但未存到缓存区的状态</span><br><span class="line">git reset HEAD .</span><br><span class="line"></span><br><span class="line">// 已经提交了代码</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line">// 若想回退到任意版本</span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure>
<ul>
<li>清理版本库信息</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 删除文件夹下的所有 .svn 文件</span><br><span class="line">find . -name <span class="string">&quot;.svn&quot;</span> | xargs <span class="built_in">rm</span> -Rf</span><br><span class="line">// 删除文件夹下的所有 .git 文件</span><br><span class="line">find . -name <span class="string">&quot;.git&quot;</span> | xargs <span class="built_in">rm</span> -Rf</span><br></pre></td></tr></table></figure>
<ul>
<li>git clone 反复需要输入用户名密码</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>
<ul>
<li>文件修改后<code>git add</code>了，也<code>git commit</code>了，发现哪里错了或者是漏<code>add</code>了一个文件。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 添加新修改到暂存区</span><br><span class="line">git add file</span><br><span class="line">git commit –amend -m <span class="string">&quot;xxx&quot;</span> // 这样只会记录一次`commit`</span><br><span class="line">// 相当于将两次 commit 合并成了一次，保留最后一次 message 内容</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>《Go in Action》读书笔记</title>
    <url>/2022/04/20/backend_dev/goinaction/</url>
    <content><![CDATA[<h1>GO IN ACTION</h1>
<h1>第 1 章：关于 Go 语言的介绍</h1>
<h2 id="本章主要内容">本章主要内容</h2>
<ul>
<li>用 Go 语言解决现代计算难题</li>
<li>使用 Go 语言工具</li>
</ul>
<h2 id="本章小结">本章小结</h2>
<ul>
<li>Go 语言是现代的、快速的，带有一个强大的<strong>标准库</strong>。</li>
<li>Go 语言内置对<strong>并发</strong>的支持。</li>
<li>Go 语言使用<strong>接口</strong>作为代码复用的基础模块。</li>
</ul>
<span id="more"></span>
<h1>第 2 章：快速开始一个 Go 程序</h1>
<h2 id="本章主要内容-2">本章主要内容</h2>
<ul>
<li>学习如何写一个复杂的 Go 程序</li>
<li>声明类型、变量、函数和方法</li>
<li>启动并同步操作 goroutine</li>
<li>使用接口写通用的代码</li>
<li>处理程序逻辑和错误</li>
<li>如果需要声明初始值为零值的变量，应该使用 var 关键字声明变量；如果提供确切的非零值初始化变量或者使用函数返回值创建变量，应该使用简化变量声明运算符。</li>
<li>当代码导入了一个包时，程序可以直接访问这个包中任意一个公开的标识符。这些标识符以大写字母开头。以小写字母开头的标识符是不公开的，不能被其他包中的代码直接访问。</li>
<li>在 Go 语言中，所有变量都被初始化为其零值。对于数值类型，零值是 0；对于字符串类型，零值是空字符串；对于布尔类型，零值是 false；对于指针，零值是 nil。对于引用类型来说，所引用的底层数据结构会被初始化为对应的零值。</li>
<li>不仅仅是 Go 语言，很多语言都允许一个函数返回多个值。<strong>一般会像 RetrieveFeeds 函数这样声明一个函数返回一个值和一个错误值。如果发生了错误，永远不要使用该函数返回的另一个值。</strong> 这时必须忽略另一个值，否则程序会产生更多的错误，甚至崩溃。</li>
<li>使用 sync 包的 WaitGroup 跟踪所有启动的 goroutine。非常推荐使用 WaitGroup 来跟踪 goroutine 的工作是否完成。WaitGroup 是一个计数信号量，我们可以利用它来统计所有的 goroutine 是不是都完成了工作。</li>
<li>Go 语言中，所有的变量都以值的方式传递。因为指针变量的值是所指向的内存地址，在函数间传递指针变量，是在传递这个地址值，所以依旧被看作以值的方式在传递。</li>
<li><strong>因为有了闭包，函数可以直接访问到那些没有作为参数传入的变量。</strong> 匿名函数并没有拿到这些变量的副本，而是直接访问外层函数作用域中声明的这些变量本身。因为 matcher 和 feed 变量每次调用时值不相同，所以并没有使用闭包的方式访问这两个变量。</li>
<li>goroutine 里面调用了 WaitGroup 的 Wait 方法。这个方法会导致 goroutine 阻塞，直到 WaitGroup 内部的计数到达 0。</li>
<li><strong>因为 Go 编译器可以根据赋值运算符右边的值来推导类型，声明常量的时候不需要指定类型。</strong></li>
<li>常量的名称使用小写字母开头，表示它只能在当前包内的代码里直接访问，而不暴露到包外面。</li>
<li>每个字段的声明最后 ` 引号里的部分被称作标记（tag），每个标记将结构类型里字段对应到 JSON 文档里指定名字的字段。</li>
<li>使用关键字 defer 来安排调用 Close 方法，可以保证这个函数一定会被调用。哪怕函数意外崩溃终止，也能保证关键字 defer 安排调用的函数会被执行。<strong>关键字 defer 可以缩短打开文件和关闭文件之间间隔的代码行数，有助提高代码可读性，减少错误。</strong></li>
<li>Decode 方法接受一个类型为 interface{}的值作为参数。这个类型在 Go 语言里很特殊，一般会配合 reflect 包里提供的反射功能一起使用。</li>
<li>如果接口类型只包含一个方法，那么这个类型的名字以 er 结尾。如果接口类型内部声明了多个方法，其名字需要与其行为关联。</li>
<li>如果要让一个用户定义的类型实现一个接口，这个用户定义的类型要实现接口类型里声明的所有方法。</li>
<li><strong>空结构在创建实例时，不会分配任何内存。这种结构很适合创建没有任何状态的类型。</strong></li>
<li>如果声明函数的时候带有接收者，则意味着声明了一个方法。这个方法会和指定的接收者的类型绑在一起。Search 方法与 defaultMatcher 类型的值绑在一起。这意味着我们可以使用 defaultMatcher 类型的值或者指向这个类型值的指针来调用 Search 方法。</li>
<li><strong>因为大部分方法在被调用后都需要维护接收者的值的状态，所以，一个最佳实践是，将方法的接收者声明为指针。</strong></li>
<li><strong>使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时候被调用。使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用。</strong></li>
<li>程序里所有的 init 方法都会在 main 函数启动前被调用。</li>
<li>我们使用下划线标识符作为别名导入 matchers 包，完成了这个调用。这种方法可以让编译器在导入未被引用的包时不报错，而且依旧会定位到包内的 init 函数。</li>
<li>append 这个内置函数会根据切片需要，决定是否要增加切片的长度和容量。这个函数的第一个参数是希望追加到的切片，第二个参数是要追加的值。</li>
<li><strong>使用指针可以在函数间或者 goroutine 间共享数据。</strong></li>
</ul>
<h2 id="本章小结-2">本章小结</h2>
<ul>
<li>每个代码文件都属于一个包，而包名应该与代码文件所在的文件夹同名。</li>
<li>Go 语言提供了多种声明和初始化变量的方式。如果变量的值没有显式初始化，编译器会将变量初始化为零值。</li>
<li>使用指针可以在函数间或者 goroutine 间共享数据。</li>
<li>通过启动 goroutine 和使用通道完成并发和同步。</li>
<li>Go 语言提供了内置函数来支持 Go 语言内部的数据结构。</li>
<li>标准库包含很多包，能做很多很有用的事情。</li>
<li>使用 Go 接口可以编写通用的代码和框架。</li>
</ul>
<h1>第 3 章：打包和工具链</h1>
<h2 id="本章主要内容-3">本章主要内容</h2>
<ul>
<li>如何组织 Go 代码</li>
<li>使用 Go 语言自带的相关命令</li>
<li>使用其他开发者提供的工具</li>
<li>与其他开发者合作</li>
<li>所有 Go 语言的程序都会组织成若干组文件，每组文件被称为一个包。这样每个包的代码都可以作为很小的复用单元，被其他项目引用。</li>
<li>所有的 .go 文件，除了空行和注释，都应该在第一行声明自己所属的包。每个包都在一个单独的目录里。</li>
<li>同一个目录下的所有 .go 文件必须声明同一个包名。</li>
<li>给包命名的惯例是使用包所在目录的名字。</li>
<li>所有用 Go 语言编译的可执行程序都必须有一个名叫 main 的包。</li>
<li>当编译器发现某个包的名字为 main 时，它一定也会发现名为 main() 的函数，否则不会创建可执行文件。</li>
<li><strong>程序编译时，会使用声明 main 包的代码所在的目录的目录名作为二进制可执行文件的文件名。</strong></li>
<li>记住，在 Go 语言里，<strong>命令是指任何可执行程序。包更常用来指语义上可导入的功能单元。</strong></li>
<li><code>go doc fmt</code></li>
<li><code>go doc strings</code></li>
<li>GOPATH 指定的这些目录就是开发者的个人工作空间。</li>
<li>编译器会首先查找 Go 的安装目录，然后才会按顺序查找 GOPATH 变量里列出的目录。</li>
</ul>
<h2 id="远程导入">远程导入</h2>
<ul>
<li>目前的大势所趋是，使用分布式版本控制系统（Distributed Version Control Systems DVCS）来分享代码，如 GitHub、Launchpad 还有 Bitbucket。Go 语言的工具链本身就支持从这些网站及类似网站获取源代码。</li>
<li>go get 将获取任意指定的 URL 的包，或者一个已经导入的包所依赖的其他包。由于 go get 的这种递归特性，这个命令会扫描某个包的源码树，获取能找到的所有依赖包。</li>
</ul>
<h2 id="命名导入">命名导入</h2>
<ul>
<li><strong>命名导入是指，在 import 语句给出的包路径的左侧定义一个名字，将导入的包命名为新名字。</strong></li>
<li>当你导入了一个不在代码里使用的包时，Go 编译器会编译失败，并输出一个错误。Go 开发团队认为，这个特性可以防止导入了未被使用的包，避免代码变得臃肿。</li>
<li>有时，用户可能需要导入一个包，但是不需要引用这个包的标识符。在这种情况，可以使用空白标识符_来重命名这个导入。</li>
<li>每个包可以包含任意多个 init 函数，这些函数都会在程序执行开始的时候被调用。</li>
</ul>
<h2 id="Go-常用命令">Go 常用命令</h2>
<ul>
<li>build 和 clean 命令会执行编译和清理的工作。</li>
<li><strong>在不包含文件名时，go 工具会默认使用当前目录来编译。</strong></li>
<li>因为构建包是很常用的动作，所以也可以直接指定包。go build <a href="http://github.com/goinaction/code/chapter3/wordcount">github.com/goinaction/code/chapter3/wordcount</a></li>
<li>也可以在指定包的时候使用通配符。<code>...</code>表示匹配所有的字符串。</li>
<li>除了指定包，大部分 Go 命令使用短路径作为参数。</li>
<li>go run 命令会先构建 wordcount.go 里包含的程序，然后执行构建后的程序。</li>
<li><strong>vet 命令会帮开发人员检测代码的常见错误。</strong></li>
<li>fmt 命令会自动格式化开发人员指定的源代码文件并保存。</li>
<li>如果开发人员使用命令行提示符工作，可以在终端上直接使用 go doc 命令来打印文档。go doc tar</li>
<li>如果开发人员认为一个浏览器界面会更有效率，可以使用 godoc 程序来启动一个 Web 服务器，通过点击的方式来查看 Go 语言的包的文档。godoc -http=:6060</li>
<li><strong>如果想给包写一段文字量比较大的文档，可以在工程里包含一个叫作 doc.go 的文件，使用同样的包名，并把包的介绍使用注释加在包名声明之前。</strong></li>
</ul>
<h2 id="以分享为目的创建代码库">以分享为目的创建代码库</h2>
<ul>
<li>包应该在代码库的根目录中。在创建想要分享的代码库的时候，包名应该就是代码库的名字，而且包的源代码应该位于代码库目录结构的根目录。</li>
<li>包可以非常小。</li>
<li>对代码执行 go fmt。</li>
<li>给代码写文档。</li>
</ul>
<h2 id="现在最流行的依赖管理工具">现在最流行的依赖管理工具</h2>
<ul>
<li>godep</li>
<li>vender</li>
<li><a href="http://gopkg.in">gopkg.in</a></li>
</ul>
<h2 id="第三方依赖">第三方依赖</h2>
<ul>
<li>像 godep 和 vender 这种社区工具已经使用第三方（verdoring）导入路径重写这种特性解决了依赖问题。其思想是把所有的依赖包复制到工程代码库中的目录里，然后使用工程内部的依赖包所在目录来重写所有的导入路径。</li>
<li>gb 基于工程将 Go 工具链工作空间的元信息做替换。这种依赖管理的方法不需要重写工程内代码的导入路径。而且导入路径依旧通过 go get 和 GOPATH 工作空间来管理。</li>
<li>gb 工程会区分开发人员写的代码和开发人员需要依赖的代码。开发人员的代码所依赖的代码被称作第三方代码（vendored code）。</li>
<li>gb 一个最好的特点是，不需要重写导入路径。</li>
<li>gb 工程与 Go 官方工具链（包括 go get）并不兼容。因为 gb 不需要设置 GOPATH，而 Go 工具链无法理解 gb 工程的目录结构，所以无法用 Go 工具链构建、测试或者获取代码。构建（如代码清单 3-16 所示）和测试 gb 工程需要先进入$PROJECT 目录，并使用 gb 工具。</li>
</ul>
<h2 id="本章小结-3">本章小结</h2>
<ul>
<li>在 Go 语言中包是组织代码的基本单位。</li>
<li>环境变量 GOPATH 决定了 Go 源代码在磁盘上被保存、编译和安装的位置。</li>
<li>可以为每个工程设置不同的 GOPATH，以保持源代码和依赖的隔离。</li>
<li>go 工具是在命令行上工作的最好工具。</li>
<li>开发人员可以使用 go get 来获取别人的包并将其安装到自己的 GOPATH 指定的目录。</li>
<li>想要为别人创建包很简单，只要把源代码放到公用代码库，并遵守一些简单规则就可以了。</li>
<li><strong>Go 语言在设计时将分享代码作为语言的核心特性和驱动力。</strong></li>
<li>推荐使用依赖管理工具来管理依赖。</li>
<li>有很多社区开发的依赖管理工具，如 godep、vender 和 gb。</li>
</ul>
<h1>第 4 章：数组、切片和映射</h1>
<h2 id="本章主要内容-4">本章主要内容</h2>
<ul>
<li>数组的内部实现和基础功能</li>
<li>使用切片管理数据集合</li>
<li>使用映射管理键值对</li>
<li><strong>Go 语言有 3 种数据结构可以让用户管理集合数据：数组、切片和映射。</strong></li>
</ul>
<h2 id="数组">数组</h2>
<ul>
<li>在 Go 语言里，数组是一个长度固定的数据类型，用于存储一段具有相同的类型的元素的连续块。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。</li>
<li>声明数组时需要指定内部存储的数据的类型，以及需要存储的元素的数量，这个数量也称为数组的长度。<code>var array [5]int</code></li>
<li>一旦声明，数组里存储的数据类型和数组长度就都不能改变了。如果需要存储更多的元素，就需要先创建一个更长的数组，再把原来数组里的值复制到新数组里。</li>
<li>一种快速创建数组并初始化的方式是使用数组字面量。<code>array := [5]int&#123;10, 20, 30, 40, 50&#125;</code></li>
<li><strong>如果使用<code>...</code>替代数组的长度，Go 语言会根据初始化时数组元素的数量来确定该数组的长度。<code>array := [...]int&#123;10, 20, 30, 40, 50&#125;</code></strong></li>
<li><strong>声明数组并指定特定元素的值。<code>array := [5]int&#123;1: 10, 2: 20&#125;</code></strong></li>
<li>声明一个所有元素都是指针的数组。使用<code>*</code>运算符就可以访问元素指针所指向的值。</li>
<li>数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相同的数组，才能互相赋值。</li>
<li>声明二维数组
<ul>
<li>声明一个二维整型数组，两个维度分别存储 4 个元素和 2 个元素：<code>var array [4][2]int</code></li>
<li>使用数组字面量来声明并初始化一个二维整型数组：<code>array := [4][2]int&#123;&#123;10, 11&#125;, &#123;20, 21&#125;, &#123;30, 31&#125;, &#123;40, 41&#125;&#125;</code></li>
<li>声明并初始化外层数组中索引为 1 个和 3 的元素：<code>array := [4][2]int&#123;1: &#123;20, 21&#125;, 3: &#123;40, 41&#125;&#125;</code></li>
<li>声明并初始化外层数组和内层数组的单个元素：<code>array := [4][2]int&#123;1: &#123;0: 20&#125;, 3: &#123;1: 41&#125;&#125;</code></li>
</ul>
</li>
<li>在函数之间传递变量时，总是以值的方式传递的。<strong>如果这个变量是一个数组，意味着整个数组，不管有多长，都会完整复制，并传递给函数。有一种更好且更有效的方法来处理这个操作。可以只传入指向数组的指针，这样只需要复制 8 字节的数据。</strong></li>
</ul>
<h2 id="切片">切片</h2>
<ul>
<li>切片是一种数据结构，这种数据结构便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。切片的动态增长是通过内置函数 append 来实现的。这个函数可以快速且高效地增长切片。还可以通过对切片再次切片来缩小一个切片的大小。因为切片的底层内存也是在连续块中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处。</li>
<li>切片是有 3 个字段的数据结构，分别是<strong>指向底层数组的指针、切片访问的元素的个数（即长度）和切片允许增长到的元素个数（即容量）。</strong><br>
<img src="http://pic.colliexyy.com/16456783729444.jpg" alt=""></li>
<li><strong>是否能提前知道切片需要的容量通常会决定要如何创建切片，频繁的复制移动底层数组会产生不必要的性能消耗。</strong></li>
<li>一种创建切片的方法是使用内置的 make 函数。当使用 make 时，需要传入一个参数，指定切片的长度。<code>slice := make([]string, 5)</code></li>
<li>如果只指定长度，那么切片的容量和长度相等。也可以分别指定长度和容量。<code>slice := make([]int, 3, 5)</code></li>
<li>不允许创建容量小于长度的切片。</li>
<li>另一种常用的创建切片的方法是使用切片字面量。初始的长度和容量会基于初始化时提供的元素的个数确定。<code>slice := []string&#123;&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;&#125;</code></li>
<li>当使用切片字面量时，可以设置初始长度和容量。要做的就是在初始化时给出所需的长度和容量作为索引。<code>slice := []string&#123;99: &quot;&quot;&#125;</code></li>
<li><strong>记住，如果在<code>[]</code>运算符里指定了一个值，包括<code>...</code>，那么创建的就是数组而不是切片。</strong></li>
<li>创建 <strong>nil 切片</strong>。<code>var slice []int</code><br>
<img src="http://pic.colliexyy.com/16456784619966.jpg" alt=""></li>
<li>利用初始化，通过声明一个切片可以创建一个<strong>空切片</strong>。<code>slice := make([]int, 0) 或 slice := []int&#123;&#125;</code><br>
<img src="http://pic.colliexyy.com/16456784684067.jpg" alt=""></li>
<li>对切片里某个索引指向的元素赋值和对数组里某个索引指向的元素赋值的方法完全一样。使用<code>[]</code>操作符就可以改变某个元素的值。</li>
<li>切片之所以被称为切片，是因为创建一个新的切片就是把底层数组切出一部分。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 5 个元素</span></span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">// 创建一个新切片</span></span><br><span class="line"><span class="comment">// 其长度为 2 个元素，容量为 4 个元素</span></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p><img src="http://pic.colliexyy.com/16456785047191.jpg" alt=""></p>
<ul>
<li>newSlice 无法访问到它所指向的底层数组的第一个元素之前的部分。</li>
<li>需要记住的是，现在<strong>两个切片共享同一个底层数组。如果一个切片修改了该底层数组的共享部分，另一个切片也能感知到。</strong></li>
<li>切片只能访问到其长度内的元素。试图访问超出其长度的元素将会导致语言运行时异常。</li>
<li>相对于数组而言，使用切片的一个好处是，可以按需增加切片的容量。</li>
<li>函数 append 总是会增加新切片的长度，而容量有可能会改变，也可能不会改变，这取决于被操作的切片的可用容量。</li>
<li>如果切片的底层数组没有足够的可用容量，append 函数会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值。</li>
<li>函数 append 会智能地处理底层数组的容量增长。<strong>在切片的容量小于 1000 个元素时，总是会成倍地增加容量。一旦元素个数超过 1000，容量的增长因子会设为 1.25，也就是会每次增加 25%的容量。</strong> 随着语言的演化，这种增长算法可能会有所改变。</li>
<li>第三个索引可以用来控制新切片的容量。其目的并不是要增加容量，而是要限制容量。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符串切片</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 5 个元素</span></span><br><span class="line">source := []<span class="type">string</span>&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Grape&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 将第三个元素切片，并限制容量</span></span><br><span class="line"><span class="comment">// 其长度为 1 个元素，容量为 2 个元素</span></span><br><span class="line">slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>]</span><br><span class="line"><span class="comment">// 对于 slice[i:j:k] 或 [2:3:4]</span></span><br><span class="line"><span class="comment">// 长度: j – i 或 3 * 2 = 1</span></span><br><span class="line"><span class="comment">// 容量: k – i 或 4 * 2 = 2</span></span><br></pre></td></tr></table></figure>
<p><img src="http://pic.colliexyy.com/16456785352268.jpg" alt=""></p>
<ul>
<li>如果试图设置的容量比可用的容量还大，就会得到一个语言运行时错误。</li>
<li><strong>如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个 append 操作创建新的底层数组，与原有的底层数组分离。新切片与原有的底层数组分离后，可以安全地进行后续修改。</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符串切片</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 5 个元素</span></span><br><span class="line">source := []<span class="type">string</span>&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Grape&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 对第三个元素做切片，并限制容量</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 1 个元素</span></span><br><span class="line">slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 向 slice 追加新字符串</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="string">&quot;Kiwi&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>内置函数 append 也是一个可变参数的函数。这意味着可以在一次调用传递多个追加的值。如果使用<code>...</code>运算符，可以将一个切片的所有元素追加到另一个切片里。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建两个切片，并分别用两个整数进行初始化</span></span><br><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// 将两个切片追加在一起，并显示结果</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="built_in">append</span>(s1, s2...))</span><br><span class="line">Output:</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>当迭代切片时，关键字 range 会返回两个值。第一个值是当前迭代到的索引位置，第二个值是该位置对应元素值的一份副本。range 创建了每个元素的副本，而不是直接返回对该元素的引用。</li>
<li>for range 迭代切片</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 4 个元素</span></span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line"><span class="comment">// 迭代每一个元素，并显示其值</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Index: %d Value: %d\n&quot;</span>, index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>传统 for 循环迭代切片</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 4 个元素</span></span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line"><span class="comment">// 从第三个元素开始迭代每个元素</span></span><br><span class="line"><span class="keyword">for</span> index := <span class="number">2</span>; index &lt; <span class="built_in">len</span>(slice); index++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Index: %d Value: %d\n&quot;</span>, index, slice[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有两个特殊的内置函数 len 和 cap，可以用于处理数组、切片和通道。对于切片，函数 len 返回切片的长度，函数 cap 返回切片的容量。</li>
<li>多维切片</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片的切片</span></span><br><span class="line">slice := [][]<span class="type">int</span>&#123;&#123;<span class="number">10</span>&#125;, &#123;<span class="number">100</span>, <span class="number">200</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://pic.colliexyy.com/16456787227017.jpg" alt=""></p>
<ul>
<li>在函数间传递切片就是要在函数间以值的方式传递切片。由于切片的尺寸很小，在函数间复制和传递切片成本也很低。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配包含 100 万个整型值的切片</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1e6</span>)</span><br><span class="line"><span class="comment">// 将 slice 传递到函数 foo</span></span><br><span class="line">slice = foo(slice)</span><br><span class="line"><span class="comment">// 函数 foo 接收一个整型切片，并返回这个切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(slice []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在 64 位架构的机器上，一个切片需要 24 字节的内存：指针字段需要 8 字节，长度和容量字段分别需要 8 字节。由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底层数组。</strong></li>
<li>在函数间传递 24 字节的数据会非常快速、简单。这也是切片效率高的地方。不需要传递指针和处理复杂的语法，只需要复制切片，按想要的方式修改数据，然后传递回一份新的切片副本。</li>
</ul>
<h2 id="映射">映射</h2>
<p><img src="http://pic.colliexyy.com/16456787379595.jpg" alt=""></p>
<ul>
<li>映射里基于键来存储值。映射功能强大的地方是，能够<strong>基于键快速检索数据</strong>。键就像索引一样，指向与该键关联的值。</li>
<li><strong>映射是无序的集合。无序的原因是映射的实现使用了散列表。</strong></li>
<li>使用 make 声明映射</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个映射，键的类型是 string，值的类型是 int</span></span><br><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 创建一个映射，键和值的类型都是 string</span></span><br><span class="line"><span class="comment">// 使用两个键值对初始化映射</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;Red&quot;</span>: <span class="string">&quot;#da1337&quot;</span>, <span class="string">&quot;Orange&quot;</span>: <span class="string">&quot;#e95a22&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>映射的键可以是任何值。这个值的类型可以是内置的类型，也可以是结构类型，只要这个值可以使用==运算符做比较。切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的键，使用这些类型会造成编译错误</li>
<li>声明一个存储字符串切片的映射。<code>dict := map[int][]string&#123;&#125;</code></li>
<li>空映射 &amp; 映射赋值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空映射，用来存储颜色以及颜色对应的十六进制代码</span></span><br><span class="line">colors := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将 Red 的代码加入到映射</span></span><br><span class="line">colors[<span class="string">&quot;Red&quot;</span>] = <span class="string">&quot;#da1337&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>nil 映射</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过声明映射创建一个 nil 映射</span></span><br><span class="line"><span class="keyword">var</span> colors <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"><span class="comment">// 将 Red 的代码加入到映射</span></span><br><span class="line">colors[<span class="string">&quot;Red&quot;</span>] = <span class="string">&quot;#da1337&quot;</span></span><br><span class="line">Runtime Error:</span><br><span class="line"><span class="built_in">panic</span>: runtime <span class="type">error</span>: assignment to entry in <span class="literal">nil</span> <span class="keyword">map</span></span><br></pre></td></tr></table></figure>
<ul>
<li>从映射获取值并判断键是否存在</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键 Blue 对应的值</span></span><br><span class="line">value, exists := colors[<span class="string">&quot;Blue&quot;</span>]</span><br><span class="line"><span class="comment">// 这个键存在吗？</span></span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>从映射获取值，并通过该值是否为对应类型的空值，从而判断键是否存在</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键 Blue 对应的值</span></span><br><span class="line">value := colors[<span class="string">&quot;Blue&quot;</span>]</span><br><span class="line"><span class="comment">// 这个键存在吗？</span></span><br><span class="line"><span class="keyword">if</span> value != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 range 迭代映射</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个映射，存储颜色以及颜色对应的十六进制代码</span></span><br><span class="line">colors := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;AliceBlue&quot;</span>: <span class="string">&quot;#f0f8ff&quot;</span>,</span><br><span class="line"><span class="string">&quot;Coral&quot;</span>: <span class="string">&quot;#ff7F50&quot;</span>,</span><br><span class="line"><span class="string">&quot;DarkGray&quot;</span>: <span class="string">&quot;#a9a9a9&quot;</span>,</span><br><span class="line"><span class="string">&quot;ForestGreen&quot;</span>: <span class="string">&quot;#228b22&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显示映射里的所有颜色</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> colors &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Key: %s Value: %s\n&quot;</span>, key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果想把一个键值对从映射里删除，就使用内置的 delete 函数。<code>delete(colors, &quot;Coral&quot;)</code></li>
<li><strong>在函数间传递映射并不会制造出该映射的一个副本。实际上，当传递映射给一个函数，并对这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改。</strong></li>
</ul>
<h2 id="本章小结-4">本章小结</h2>
<ul>
<li>数组是构造切片和映射的基石。</li>
<li>Go 语言里切片经常用来处理数据的集合，映射用来处理具有键值对结构的数据。</li>
<li>内置函数 make 可以创建切片和映射，并指定原始的长度和容量。也可以直接使用切片和映射字面量，或者使用字面量作为变量的初始值。</li>
<li>切片有容量限制，不过可以使用内置的 append 函数扩展容量。</li>
<li>映射的增长没有容量或者任何限制。</li>
<li>内置函数 len 可以用来获取切片或者映射的长度。</li>
<li>内置函数 cap 只能用于切片。</li>
<li>通过组合，可以创建多维数组和多维切片。也可以使用切片或者其他映射作为映射的值。但是切片不能用作映射的键。</li>
<li><strong>将切片或者映射传递给函数成本很小，并且不会复制底层的数据结构。</strong></li>
</ul>
<h1>第 5 章：Go 语言的类型系统</h1>
<h2 id="本章主要内容-5">本章主要内容</h2>
<ul>
<li>
<p>声明新的用户定义的类型</p>
</li>
<li>
<p>使用方法，为类型增加新的行为</p>
</li>
<li>
<p>了解何时使用指针，何时使用值</p>
</li>
<li>
<p>通过接口实现多态</p>
</li>
<li>
<p>通过组合来扩展或改变类型</p>
</li>
<li>
<p>公开或者未公开的标识符</p>
</li>
<li>
<p><strong>Go 语言是一种静态类型的编程语言。这意味着，编译器需要在编译时知晓程序里每个值的类型。</strong></p>
</li>
<li>
<p>一个 int 值的大小可能是 8 字节（64 位），也可能是 4 字节（32 位）。</p>
</li>
<li>
<p>当用户声明一个新类型时，这个声明就给编译器提供了一个框架，告知必要的内存大小和表示信息。</p>
</li>
<li>
<p>结构里每个字段都会用一个已知类型声明。这个已知类型可以是内置类型，也可以是其他用户定义的类型。<br>
<img src="http://pic.colliexyy.com/16456789214463.jpg" alt=""><br>
<img src="http://pic.colliexyy.com/16456789279256.jpg" alt=""></p>
</li>
<li>
<p><strong>任何时候，创建一个变量并初始化为其零值，习惯是使用关键字 var。</strong></p>
</li>
<li>
<p><strong>一个短变量声明操作符在一次操作中完成两件事情：声明一个变量，并初始化。</strong><br>
<img src="http://pic.colliexyy.com/16456789448794.jpg" alt=""><br>
<img src="http://pic.colliexyy.com/16456789501715.jpg" alt=""><br>
<img src="http://pic.colliexyy.com/16456789562770.jpg" alt=""></p>
</li>
<li>
<p>基于一个已有的类型，将其作为新类型的类型说明。<code>type Duration int64</code>（虽然 int64 是基础类型，Go 并不认为 Duration 和 int64 是同一种类型。）</p>
</li>
<li>
<p>关键字 func 和函数名之间的参数被称作接收者，将函数与接收者的类型绑在一起。如果一个函数有接收者，这个函数就被称为方法。</p>
</li>
<li>
<p>Go 语言里有两种类型的接收者：值接收者和指针接收者。</p>
</li>
<li>
<p>值接受者</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> notify() &#123;</span><br><span class="line">    <span class="comment">// 使用值来调用</span></span><br><span class="line">    bill := user&#123;<span class="string">&quot;Bill&quot;</span>, <span class="string">&quot;bill@email.com&quot;</span>&#125;</span><br><span class="line">    bill.notify()</span><br><span class="line">    <span class="comment">// 使用值的指针来调用，这时候操作的仍然是值的副本</span></span><br><span class="line">    lisa := &amp;user&#123;<span class="string">&quot;Lisa&quot;</span>, <span class="string">&quot;lisa@email.com&quot;</span>&#125;</span><br><span class="line">    lisa.notify()  <span class="comment">// Go背后执行的操作实际是：(*lisa).notify()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指针接收者</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> changeEmail(email <span class="type">string</span>) &#123;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>当调用使用指针接收者声明的方法时，这个方法会共享调用方法时接收者所指向的值</strong><br>
<img src="http://pic.colliexyy.com/16456790245075.jpg" alt=""></li>
<li><strong>值接收者使用值的副本来调用方法，而指针接受者使用实际值来调用方法。</strong></li>
<li><strong>也可以使用一个值来调用使用指针接收者声明的方法</strong><br>
<img src="http://pic.colliexyy.com/16456790474052.jpg" alt=""><br>
<img src="http://pic.colliexyy.com/16456790285047.jpg" alt=""></li>
<li>如果给这个类型增加或者删除某个值，是要创建一个新的值，还是要更改当前的值？<strong>如果是要创建一个新值，该类型的方法就使用值接收者。如果是要修改当前值，就使用指针接收者。</strong></li>
<li>内置类型是由语言提供的一组类型。我们已经见过这些类型，分别是数值类型、字符串类型和布尔类型。</li>
<li>Go 语言里的引用类型有如下几个：切片、映射、通道、接口和函数类型。</li>
<li><strong>是使用值接收者还是指针接收者，不应该由该方法是否修改了接收到的值来决定。这个决策应该基于该类型的本质。</strong></li>
<li>这条规则的一个例外是，需要让类型值符合某个接口的时候，即便类型的本质是非原始本质的，也可以选择使用值接收者声明方法。这样做完全符合接口值调用方法的机制。</li>
<li>接口</li>
<li>多态是指代码可以根据类型的具体实现采取不同行为的能力。如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值。</li>
<li><strong>接口值是一个两个字长度的数据结构，第一个字包含一个指向内部表的指针。这个内部表叫作 iTable，包含了所存储的值的类型信息。iTable 包含了已存储的值的类型信息以及与这个值相关联的一组方法。第二个字是一个指向所存储值的指针。</strong> 将类型信息和指针组合在一起，就将这两个值组成了一种特殊的关系。<br>
<img src="http://pic.colliexyy.com/16456790805527.jpg" alt=""><br>
<img src="http://pic.colliexyy.com/16456790845095.jpg" alt=""></li>
<li>方法集定义了一组关联到给定类型的值或者指针的方法。定义方法时使用的接收者的类型决定了这个方法是关联到值，还是关联到指针，还是两个都关联。</li>
<li><strong>如果使用指针接收者来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。如果使用值接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。</strong></li>
<li>为什么会有这种限制？事实上，编译器并不是总能自动获得一个值的地址。</li>
</ul>
<h2 id="多态：嵌入类型">多态：嵌入类型</h2>
<ul>
<li>Go 语言允许用户扩展或者修改已有类型的行为。这个功能对代码复用很重要，在修改已有类型以符合新类型的时候也很重要。这个功能是通过嵌入类型（type embedding）完成的。嵌入类型是将已有的类型直接声明在新的结构类型里。被嵌入的类型被称为新的外部类型的内部类型。</li>
<li>通过嵌入类型，与内部类型相关的标识符会提升到外部类型上。这些被提升的标识符就像直接声明在外部类型里的标识符一样，也是外部类型的一部分。这样外部类型就组合了内部类型包含的所有属性，并且可以添加新的字段和方法。<strong>外部类型也可以通过声明与内部类型标识符同名的标识符来覆盖内部标识符的字段或者方法。这就是扩展或者修改已有类型的方法。</strong></li>
<li>要嵌入一个类型，只需要声明这个类型的名字就可以了。</li>
<li>一旦我们将 user 类型嵌入 admin，我们就可以说 user 是外部类型 admin 的内部类型。有了内部类型和外部类型这两个概念，就能更容易地理解这两种类型之间的关系。</li>
<li><strong>虽然没有指定内部类型对应的字段名，还是可以使用内部类型的类型名，来访问到内部类型的值。<code>ad.user.notify()</code></strong></li>
<li>由于内部类型的标识符提升到了外部类型，我们可以直接通过外部类型的值来访问内部类型的标识符。</li>
<li>由于内部类型的提升，内部类型实现的接口会自动提升到外部类型。这意味着由于内部类型的实现，外部类型也同样实现了这个接口。<code>ad.notify()</code></li>
<li>如果外部类型实现了 notify 方法，内部类型的实现就不会被提升。不过内部类型的值一直存在，因此还可以通过直接访问内部类型的值，来调用没有被提升的内部类型实现的方法。</li>
</ul>
<h2 id="公开和未公开标识符">公开和未公开标识符</h2>
<ul>
<li>要想设计出好的 API，需要使用某种规则来控制声明后的标识符的可见性。</li>
<li>当一个标识符的名字以小写字母开头时，这个标识符就是未公开的，即包外的代码不可见。如果一个标识符以大写字母开头，这个标识符就是公开的，即被包外的代码可见。</li>
<li><strong>将工厂函数命名为 New 是 Go 语言的一个习惯。</strong></li>
<li>New 函数创建了一个未公开的类型的值，并将这个值返回给调用者。</li>
<li>第一，公开或者未公开的标识符，不是一个值。第二，短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量。</li>
<li>永远不能显式创建一个未公开的类型的变量，不过短变量声明操作符可以这么做。</li>
<li><strong>即便内部类型是未公开的，内部类型里声明的字段依旧是公开的。既然内部类型的标识符提升到了外部类型，这些公开的字段也可以通过外部类型的字段的值来访问。</strong></li>
</ul>
<h2 id="本章小结-5">本章小结</h2>
<ul>
<li>使用关键字 struct 或者通过指定已经存在的类型，可以声明用户定义的类型。</li>
<li>方法提供了一种给用户定义的类型增加行为的方式。</li>
<li><u><strong>设计类型时需要确认类型的本质是原始的，还是非原始的。</strong></u></li>
<li>接口是声明了一组行为并支持多态的类型。</li>
<li>嵌入类型提供了扩展类型的能力，而无需使用继承。</li>
<li>标识符要么是从包里公开的，要么是在包里未公开的。</li>
</ul>
<h1>第 6 章：并发</h1>
<h2 id="本章主要内容-6">本章主要内容</h2>
<ul>
<li>使用 goroutine 运行程序</li>
<li>检测并修正竞争状态</li>
<li>利用通道共享数据</li>
<li>Go 语言里的并发指的是能让某个函数独立于其他函数运行的能力。</li>
<li><strong>Go 语言的并发同步模型来自一个叫作通信顺序进程（Communicating Sequential Processes，CSP）的范型（paradigm）。</strong></li>
<li><strong>CSP 是一种消息传递模型，通过在 goroutine 之间传递数据来传递消息，而不是对数据进行加锁来实现同步访问。</strong></li>
<li>用于在 goroutine 之间同步和传递数据的关键数据类型叫作通道（channel）。</li>
<li>使用通道可以使编写并发程序更容易，也能够让并发程序出错更少。</li>
<li>什么是操作系统的线程（thread）和进程（process）？
<ul>
<li><strong>进程可以看作一个包含了应用程序在运行中需要用到和维护的各种资源的容器。</strong> 这些资源包括但不限于内存地址空间、文件和设备的句柄以及线程。</li>
<li><strong>一个线程是一个执行空间，这个空间会被操作系统调度来运行函数中所写的代码。</strong></li>
<li><strong>每个进程至少包含一个线程，每个进程的初始线程被称作主线程。</strong> 因为执行这个线程的空间是应用程序的本身的空间，所以当主线程终止时，应用程序也会终止。</li>
<li><strong>操作系统会在物理处理器上调度线程来运行，而 Go 语言的运行时会在逻辑处理器上调度 goroutine 来运行。</strong></li>
</ul>
</li>
<li>1.5 版本上，Go 语言的运行时默认会为每个可用的物理处理器分配一个逻辑处理器。</li>
<li>如果创建一个 goroutine 并准备运行，这个 goroutine 就会被放到调度器的全局运行队列中。之后，调度器就将这些队列中的 goroutine 分配给一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列中。本地运行队列中的 goroutine 会一直等待直到自己被分配的逻辑处理器执行。<br>
<img src="http://pic.colliexyy.com/16456792126348.jpg" alt=""></li>
<li>如果一个 goroutine 需要做一个网络 I/O 调用，流程上会有些不一样。在这种情况下，goroutine 会和逻辑处理器分离，并移到集成了网络轮询器的运行池。一旦该轮询器指示某个网络读或者写操作已经就绪，对应的 goroutine 就会重新分配到逻辑处理器上来完成操作。</li>
<li>并发（concurrency）不是并行（parallelism）。<br>
<img src="http://pic.colliexyy.com/16456792372571.jpg" alt=""></li>
<li><strong>并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。</strong> 在很多情况下，并发的效果比并行好，因为操作系统和硬件的总资源一般很少，但能支持系统同时做很多事情。</li>
<li>如果希望让 goroutine 并行，必须使用多于一个逻辑处理器。当有多个逻辑处理器时，调度器会将 goroutine 平等分配到每个逻辑处理器上。这会让 goroutine 在不同的线程上运行。</li>
<li>不过要想真的实现并行的效果，用户需要让自己的程序运行在有多个物理处理器的机器上。否则，哪怕 Go 语言运行时使用多个线程，goroutine 依然会在同一个物理处理器上并发运行，达不到并行的效果。</li>
</ul>
<h2 id="goroutines">goroutines</h2>
<ul>
<li>调用了 runtime 包的 GOMAXPROCS 函数。这个函数允许程序更改调度器可以使用的逻辑处理器的数量。如果不想在代码里做这个调用，也可以通过修改和这个函数名字一样的环境变量的值来更改逻辑处理器的数量。</li>
<li>WaitGroup 是一个计数信号量，可以用来记录并维护运行的 goroutine。</li>
<li>如果 WaitGroup 的值大于 0，Wait 方法就会阻塞。</li>
<li>关键字 defer 会修改函数调用时机，在正在执行的函数返回时才真正调用 defer 声明的函数。</li>
<li>当 goroutine 占用时间过长时，调度器会停止当前正运行的 goroutine，并给其他可运行的 goroutine 运行的机会。<br>
<img src="http://pic.colliexyy.com/16456792583487.jpg" alt=""></li>
<li>给每个可用的核心分配一个逻辑处理器 <code>runtime.GOMAXPROCS(runtime.NumCPU())</code></li>
<li>需要强调的是，使用多个逻辑处理器并不意味着性能更好。在修改任何语言运行时配置参数的时候，都需要配合基准测试来评估程序的运行效果。</li>
<li>记住，只有在有多个逻辑处理器且可以同时让每个 goroutine 运行在一个可用的物理处理器上的时候，goroutine 才会并行运行。</li>
</ul>
<h2 id="竞争状态">竞争状态</h2>
<ul>
<li>如果两个或者多个 goroutine 在没有互相同步的情况下，访问某个共享的资源，并试图同时读和写这个资源，就处于相互竞争的状态，这种情况被称作竞争状态（race candition）。</li>
<li><strong>对一个共享资源的读和写操作必须是原子化的，换句话说，同一时刻只能有一个 goroutine 对共享资源进行读和写操作。</strong></li>
<li><strong>当前 goroutine 从线程退出，并放回到队列：<code>runtime.Gosched()</code></strong></li>
<li><code>go build -race</code>可以在代码里检测竞争状态。在查找这类错误的时候，这个工具非常好用，尤其是在竞争状态并不像这个例子里这么明显的时候。</li>
<li>一种修正代码、消除竞争状态的办法是，使用 Go 语言提供的锁机制，来锁住共享资源，从而保证 goroutine 的同步状态。</li>
</ul>
<h2 id="锁住共享资源">锁住共享资源</h2>
<ul>
<li>如果需要顺序访问一个整型变量或者一段代码，atomic 和 sync 包里的函数提供了很好的解决方案。</li>
<li>原子函数能够以很底层的加锁机制来同步访问整型变量和指针。
<ul>
<li><strong>atmoic 包的 AddInt64 函数会同步整型值的加法，方法是强制同一时刻只能有一个 goroutine 运行并完成这个加法操作。</strong> 当 goroutine 试图去调用任何原子函数时，这些 goroutine 都会自动根据所引用的变量做同步处理。</li>
<li><strong>另外两个有用的原子函数是 LoadInt64 和 StoreInt64。这两个函数提供了一种安全地读和写一个整型值的方式。</strong></li>
<li>原子函数会将这些读写调用互相同步，保证这些操作都是安全的，不会进入竞争状态。</li>
</ul>
</li>
<li>另一种同步访问共享资源的方式是使用互斥锁（mutex）。
<ul>
<li><strong>互斥锁用于在代码上创建一个临界区，保证同一时间只有一个 goroutine 可以执行这个临界区代码。</strong></li>
<li>同一时刻只有一个 goroutine 可以进入临界区。之后，直到调用 Unlock()函数之后，其他 goroutine 才能进入临界区。</li>
</ul>
</li>
</ul>
<h2 id="通道">通道</h2>
<ul>
<li>原子函数和互斥锁都能工作，但是依靠它们都不会让编写并发程序变得更简单，更不容易出错，或者更有趣。</li>
<li>当一个资源需要在 goroutine 之间共享时，通道在 goroutine 之间架起了一个管道，并提供了确保同步交换数据的机制。</li>
<li>声明通道时，需要指定将要被共享的数据的类型。</li>
<li>可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。</li>
<li><strong>使用 make 创建通道。make 的第一个参数需要是关键字 chan，之后跟着允许通道交换的数据的类型。</strong><br>
<img src="http://pic.colliexyy.com/16456793372822.jpg" alt=""></li>
<li>向通道发送值或者指针需要用到&lt;-操作符<br>
<img src="http://pic.colliexyy.com/16456793486607.jpg" alt=""><br>
<img src="http://pic.colliexyy.com/16456793524862.jpg" alt=""></li>
<li><strong>无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。</strong> 如果两个 goroutine 没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。<br>
<img src="http://pic.colliexyy.com/16456793684336.jpg" alt=""></li>
<li><strong>有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。</strong> 这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。</li>
<li>有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。<br>
<img src="http://pic.colliexyy.com/16456793791903.jpg" alt=""></li>
<li>当<strong>通道关闭后，goroutine 依旧可以从通道接收数据，但是不能再向通道里发送数据。</strong> 能够从已经关闭的通道接收数据这一点非常重要，因为这允许通道关闭后依旧能取出其中缓冲的全部值，而不会有数据丢失。<strong>从一个已经关闭且没有数据的通道里获取数据，总会立刻返回，并返回一个通道类型的零值。</strong></li>
</ul>
<h2 id="本章小结-6">本章小结</h2>
<ul>
<li>并发是指 goroutine 运行的时候是相互独立的。</li>
<li>使用关键字 go 创建 goroutine 来运行函数。</li>
<li><strong>goroutine 在逻辑处理器上执行，而逻辑处理器具有独立的系统线程和运行队列。</strong></li>
<li>竞争状态是指两个或者多个 goroutine 试图访问同一个资源。</li>
<li>原子函数和互斥锁提供了一种防止出现竞争状态的办法。</li>
<li>通道提供了一种在两个 goroutine 之间共享数据的简单方法。</li>
<li><strong>无缓冲的通道保证同时交换数据，而有缓冲的通道不做这种保证。</strong></li>
</ul>
<h1>第 7 章：并发模式</h1>
<h2 id="本章主要内容-7">本章主要内容</h2>
<ul>
<li>控制程序的生命周期</li>
<li>管理可复用的资源池</li>
<li>创建可以处理任务的 goroutine 池</li>
</ul>
<h2 id="runner">runner</h2>
<ul>
<li><strong>runner 包用于展示如何使用通道来监视程序的执行时间，如果程序运行时间太长，也可以用 runner 包来终止程序。</strong> 当开发需要调度后台处理任务的程序的时候，这种模式会很有用。这个程序可能会作为 cron 作业执行，或者在基于定时任务的云环境（如 <a href="http://iron.io">iron.io</a>）里执行。<br>
<img src="http://pic.colliexyy.com/16456794334532.jpg" alt=""></li>
<li>在设计上，可支持以下终止点：<br>
_ 程序可以在分配的时间内完成工作，正常终止；<br>
_ 程序没有及时完成工作，“自杀”； * 接收到操作系统发送的中断事件，程序立刻试图清理状态并停止工作。<br>
<img src="http://pic.colliexyy.com/16456794506167.jpg" alt=""></li>
<li>通道 interrupt 被初始化为缓冲区容量为 1 的通道。这可以保证通道至少能接收一个来自语言运行时的 os.Signal 值，确保语言运行时发送这个事件的时候不会被阻塞。如果 goroutine 没有准备好接收这个值，这个值就会被丢弃。</li>
<li>通道 complete 被初始化为无缓冲的通道。当执行任务的 goroutine 完成时，会向这个通道发送一个 error 类型的值或者 nil 值。之后就会等待 main 函数接收这个值。一旦 main 接收了这个 error 值，goroutine 就可以安全地终止了。</li>
<li>最后一个通道 timeout 是用 time 包的 After 函数初始化的。After 函数返回一个 time.Time 类型的通道。语言运行时会在指定的 duration 时间到期之后，向这个通道发送一个 time.Time 的值。</li>
<li>task 字段的零值是 nil，已经满足初始化的要求，所以没有被明确初始化。</li>
<li>可变参数可以接受任意数量的值作为传入参数。</li>
<li>方法 gotInterrupt 展示了带 default 分支的 select 语句的经典用法。<br>
<img src="http://pic.colliexyy.com/16456794746728.jpg" alt=""></li>
<li>代码试图从 interrupt 通道去接收信号。一般来说，select 语句在没有任何要接收的数据时会阻塞，不过有了第 98 行的 default 分支就不会阻塞了。default 分支会将接收 interrupt 通道的阻塞调用转变为非阻塞的。如果 interrupt 通道有中断信号需要接收，就会接收并处理这个中断。如果没有需要接收的信号，就会执行 default 分支。</li>
<li>方法 Start 实现了程序的主流程。<br>
<img src="http://pic.colliexyy.com/16456794874952.jpg" alt=""></li>
</ul>
<h2 id="pool">pool</h2>
<ul>
<li>本章会介绍 pool 包。在 Go 1.6 及之后的版本中，标准库里自带了资源池的实现（sync.Pool）。推荐使用。</li>
<li>这个包用于展示如何使用有缓冲的通道实现资源池，来管理可以在任意数量的 goroutine 之间共享及独立使用的资源。这种模式在需要共享一组静态资源的情况（如共享数据库连接或者内存缓冲区）下非常有用。如果 goroutine 需要从池里得到这些资源中的一个，它可以从池里申请，使用完后归还到资源池里。</li>
<li>Pool 的结构允许调用者根据所需数量创建不同的资源池。只要某类资源实现了 io.Closer 接口，就可以用这个资源池来管理。<br>
<img src="http://pic.colliexyy.com/16456795142159.jpg" alt=""></li>
<li>sync.Mutex 类型的互斥锁用来保证在多个 goroutine 访问资源池时，池内的值是安全的。</li>
<li>resources 字段被声明为 io.Closer 接口类型的通道。这个通道是作为一个有缓冲的通道创建的，用来保存共享的资源。由于通道的类型是一个接口，所以池可以管理任意实现了 io.Closer 接口的资源类型。</li>
<li>factory 字段是一个函数类型。任何一个没有输入参数且返回一个 io.Closer 和一个 error 接口值的函数，都可以赋值给这个字段。这个函数的目的是，当池需要一个新资源时，可以用这个函数创建。这个函数的实现细节超出了 pool 包的范围，并且需要由包的使用者实现并提供。</li>
<li>closed 字段是一个标志，表示 Pool 是否已经被关闭。</li>
<li>Go 语言里会经常创建 error 接口变量。这可以让调用者来判断某个包里的函数或者方法返回的具体的错误值（如果可能存在多种错误值的情况下。）。</li>
<li>Acquire 方法在还有可用资源时会从资源池里返回一个资源，否则会为该调用创建并返回一个新的资源。</li>
<li>一旦程序不再使用资源池，需要调用这个资源池的 Close 方法。在同一时刻只能有一个 goroutine 执行这段代码。事实上，当这段代码被执行时，必须保证其他 goroutine 中没有同时执行 Release 方法。</li>
<li>Release 方法的任务是如果不再需要已经获得的资源，必须将这个资源释放回资源池里。和 Close 方法中的互斥量是同一个互斥量。这样可以阻止这两个方法在不同 goroutine 里同时运行。</li>
<li>唯一标识是通过 atomic.AddInt32 函数生成的。这个函数可以安全地增加包级变量 idCounter 的值。</li>
</ul>
<h2 id="work">work</h2>
<ul>
<li>work 包的目的是展示如何使用无缓冲的通道来创建一个 goroutine 池，这些 goroutine 执行并控制一组工作，让其并发执行。</li>
<li>在这种情况下，使用无缓冲的通道要比随意指定一个缓冲区大小的有缓冲的通道好，因为这个情况下既不需要一个工作队列，也不需要一组 goroutine 配合执行。</li>
<li>无缓冲的通道保证两个 goroutine 之间的数据交换。</li>
<li>这种使用无缓冲的通道的方法允许使用者知道什么时候 goroutine 池正在执行工作，而且如果池里的所有 goroutine 都忙，无法接受新的工作的时候，也能及时通过通道来通知调用者。</li>
<li>使用无缓冲的通道不会有工作在队列里丢失或者卡住，所有工作都会被处理。<br>
<img src="http://pic.colliexyy.com/16456795522106.jpg" alt=""></li>
<li>work 包的工厂函数<br>
<img src="http://pic.colliexyy.com/16456795648957.jpg" alt=""></li>
<li>代码展示了 New 函数，这个函数使用固定数量的 goroutine 来创建一个工作池。goroutine 的数量作为参数传给 New 函数。</li>
<li>在第 22 行，创建了一个 Pool 类型的值，并使用无缓冲的通道来初始化 work 字段。</li>
<li>之后，在第 26 行，初始化 WaitGroup 需要等待的数量，并在第 27 行到第 34 行，创建了同样数量的 goroutine。</li>
<li>这些 goroutine 只接收 Worker 类型的接口值，并调用这个值的 Task 方法。</li>
<li>代码清单 7-31 里的 for range 循环会一直阻塞，直到从 work 通道收到一个 Worker 接口值。</li>
<li>如果收到一个值，就会执行这个值的 Task 方法。一旦 work 通道被关闭（所有任务结束后，在 shutdown 中关闭），for range 循环就会结束，并调用 WaitGroup 的 Done 方法。然后 goroutine 终止。<br>
<img src="http://pic.colliexyy.com/16456795776727.jpg" alt=""></li>
<li>Shutdown 方法做了两件事，首先，它关闭了 work 通道，这会导致所有池里的 goroutine 停止工作，并调用 WaitGroup 的 Done 方法；然后，Shutdown 方法调用 WaitGroup 的 Wait 方法，这会让 Shutdown 方法等待所有 goroutine 终止。</li>
</ul>
<h2 id="本章小结-7">本章小结</h2>
<ul>
<li>可以使用通道来控制程序的生命周期。</li>
<li><strong>带 default 分支的 select 语句可以用来尝试向通道发送或者接收数据，而不会阻塞。</strong></li>
<li><strong>有缓冲的通道可以用来管理一组可复用的资源。</strong></li>
<li>语言运行时会处理好通道的协作和同步。</li>
<li><strong>使用无缓冲的通道来创建完成工作的 goroutine 池。</strong></li>
<li>任何时间都可以用无缓冲的通道来让两个 goroutine 交换数据，在通道操作完成时一定保证对方接收到了数据。</li>
</ul>
<h1>第 8 章：标准库</h1>
<h2 id="本章主要内容-8">本章主要内容</h2>
<ul>
<li>输出数据以及记录日志</li>
<li>对 JSON 进行编码和解码</li>
<li>处理输入/输出，并以流的方式处理数据</li>
<li>让标准库里多个包协同工作</li>
<li>Go 标准库是一组核心包，用来扩展和增强语言的能力。这些包为语言增加了大量不同的类型。开发人员可以直接使用这些类型，而不用再写自己的包或者去下载其他人发布的第三方包。</li>
<li>标准库本身是经过良好设计的，并且比其他语言的标准库提供了更多的功能。</li>
</ul>
<h2 id="文档与源代码">文档与源代码</h2>
<p><img src="http://pic.colliexyy.com/16456796242116.jpg" alt=""></p>
<ul>
<li>不管用什么方式安装 Go，标准库的源代码都会安装在$GOROOT/src/pkg 文件夹中。</li>
<li>作为 Go 发布包的一部分，标准库的源代码是经过预编译的。这些预编译后的文件，称作归档文件（archive file）。可以 在$GOROOT/pkg 文件夹中找到已经安装的各目标平台和操作系统的归档文件。</li>
<li>归档文件是特殊的 Go 静态库文件，由 Go 的构建工具创建，并在编译和链接最终程序时被使用。归档文件可以让构建的速度更快。</li>
</ul>
<h2 id="记录日志">记录日志</h2>
<ul>
<li>日志是开发人员的眼睛和耳朵，可以用来跟踪、调试和分析代码。</li>
<li>标准库提供了 log 包，可以对日志做一些最基本的配置。根据特殊需要，开发人员还可以自己定制日志记录器。</li>
<li>传统的 CLI（命令行界面）程序直接将输出写到名为 stdout 的设备上。</li>
<li>stderr 设备被创建为日志的默认目的地。</li>
<li>如果用户的程序只记录日志，没有程序输出，更常用的方式是将一般的日志信息写到 stdout，将错误或者警告信息写到 stderr。</li>
<li><strong>通常程序会在 init()函数里配置日志参数，这样程序一开始就能使用 log 包进行正确的输出。</strong></li>
<li>有几个和 log 包相关联的标志，这些标志用来控制可以写到每个日志项的其他信息。<br>
<img src="http://pic.colliexyy.com/16456796486532.jpg" alt=""></li>
<li>关键字 iota 在常量声明区里有特殊的作用。这个关键字让编译器为每个常量复制相同的表达式，直到声明区结束，或者遇到一个新的赋值语句。关键字 iota 的另一个功能是，iota 的初始值为 0，之后 iota 的值在每次处理为常量后，都会自增 1。<br>
<img src="http://pic.colliexyy.com/16456796565200.jpg" alt=""></li>
<li>Fatal 系列函数用来写日志消息，然后使用 os.Exit(1)终止程序。</li>
<li>Panic 系列函数用来写日志消息，然后触发一个 panic。除非程序执行 recover 函数，否则会导致程序打印调用栈后终止。</li>
<li>Print 系列函数是写日志消息的标准方法。</li>
<li>log 包有一个很方便的地方就是，这些日志记录器是多 goroutine 安全的。这意味着在多个 goroutine 可以同时调用来自同一个日志记录器的这些函数，而不 会有彼此间的写冲突。</li>
</ul>
<h2 id="定制的日志记录器">定制的日志记录器</h2>
<ul>
<li>要想创建一个定制的日志记录器，需要创建一个 Logger 类型值。可以给每个日志记录器配置一个单独的目的地，并独立设置其前缀和标志。<br>
<img src="http://pic.colliexyy.com/16456796876518.jpg" alt=""></li>
<li>为了创建每个日志记录器，我们使用了 log 包的 New 函数，它创建并正确初始化一个 Logger 类型的值。<br>
<img src="http://pic.colliexyy.com/16456797022738.jpg" alt=""></li>
<li>当某个等级的日志不重要时，使用 Discard 变量可以禁用这个等级的日志。</li>
<li><strong>MultiWriter 函数是一个变参函数，可以接受任意个实现了 io.Writer 接口的值。这个函数会返回一个 io.Writer 值，这个值会把所有传入的 io.Writer 的值绑在一起。当对这个返回值进行写入时，会向所有绑在一起的 io.Writer 值做写入。</strong></li>
<li>Logger 类型实现的所有方法<br>
<img src="http://pic.colliexyy.com/16456796908521.jpg" alt=""></li>
</ul>
<h2 id="编码-解码">编码/解码</h2>
<ul>
<li>如果程序需要处理 XML 或者 JSON，可以使用标准库里名为 xml 和 json 的包，它们可以处理这些格式的数据。</li>
<li>在今天，JSON 远比 XML 流行。这主要是因为与 XML 相比，使用 JSON 需要处理的标签更少。而这就意味着网络传输时每个消息的数据更少，从而提升整个系统的性能。而且，JSON 可以转换为 BSON（Binary JavaScript Object Notation，二进制 JavaScript 对象标记），进一步缩小每个消息的数据长度。<br>
<img src="http://pic.colliexyy.com/16456797308594.jpg" alt=""></li>
<li>每个字段最后使用单引号声明了一个字符串。这些字符串被称作标签（tag），是提供每个字段的元信息的一种机制，将 JSON 文档和结构类型里的字段一一映射起来。</li>
<li>如果不存在标签，编码和解码过程会试图以大小写无关的方式，直接使用字段的名字进行匹配。如果无法匹配，对应的结构类型里的字段就包含其零值。</li>
<li>Decode 方法接受一个 interface{} 类型的值做参数，并返回一个 error 值。任何类型都实现了一个空接口 interface{}。这意味着 Decode 方法可以接受任意类型的值。使用反射，Decode 方法会拿到传入值的类型信息。然后，在读取 JSON 响应的过程中，Decode 方法会将对应的响应解码为这个类型的值。</li>
<li><strong>有时，需要处理的 JSON 文档会以 string 的形式存在。在这种情况下，需要将 string 转换为 byte 切片（[]byte），并使用 json 包的 Unmarshal 函数进行反序列化的处理。</strong></li>
<li>有时，无法为 JSON 的格式声明一个结构类型，而是需要更加灵活的方式来处理 JSON 文档。在这种情况下，可以将 JSON 文档解码到一个 map 变量中。</li>
<li>变量 c 声明为一个 map 类型，其键是 string 类型，其值是 interface{} 类型。这意味着这个 map 类型可以使用任意类型的值作为给定键的值。var c map[string]interface{}</li>
<li>展示了如何将 contact 键的值转换为另一个键是 string 类型，值是 interface{} 类型的 map 类型。<br>
<img src="http://pic.colliexyy.com/16456797524566.jpg" alt=""></li>
<li>使用 json 包的 MarshalIndent 函数进行编码。这个函数可以很方便地将 Go 语言的 map 类型的值或者结构类型的值转换为易读格式的 JSON 文档。</li>
<li>序列化（marshal）是指将数据转换为 JSON 字符串的过程。</li>
</ul>
<h2 id="输入和输出">输入和输出</h2>
<ul>
<li><strong>类 UNIX 的操作系统如此伟大的一个原因是，一个程序的输出可以是另一个程序的输入这一理念。</strong> 依照这个哲学，这类操作系统创建了一系列的简单程序，每个程序只做一件事，并把这件事做得非常好。之后，将这些程序组合在一起，可以创建一些脚本做一些很惊艳的事情。这些程序使用 stdin 和 stdout 设备作为通道，在进程之间传递数据。</li>
<li>与 stdout 和 stdin 对应，这个包含有 io.Writer 和 io.Reader 两个接口。</li>
<li>所有实现了这两个接口的类型的值，都可以使用 io 包提供的所有功能，也可以用于其他包里接受这两个接口的函数以及方法。这是用接口类型来构造函数和 API 最美妙的地方。</li>
<li>由于 io.Writer 和 io.Reader 提供了足够的抽象，这些 io 包里的函数和方法并不知道数据的类型，也不知道这些数据在物理上是如何读和写的。<br>
<img src="http://pic.colliexyy.com/16456798193068.jpg" alt=""><br>
<img src="http://pic.colliexyy.com/16456798231494.jpg" alt=""><br>
<img src="http://pic.colliexyy.com/16456798257437.jpg" alt=""><br>
<img src="http://pic.colliexyy.com/16456798319556.jpg" alt=""></li>
<li>在 bytes 包的源代码里，为 Buffer 类型声明的 Write 方法<br>
<img src="http://pic.colliexyy.com/16456798492658.jpg" alt=""></li>
<li>os 包的源代码里，为 File 类型声明的 Write 方法<br>
<img src="http://pic.colliexyy.com/16456798555094.jpg" alt=""></li>
<li>应该花时间看一下标准库中提供了些什么，以及它是如何实现的——不仅要防止重新造轮子，还要理解 Go 语言的设计者的习惯，并将这些习惯应用到自己的包和 API 的设计上。</li>
</ul>
<h2 id="本章小结-8">本章小结</h2>
<ul>
<li>标准库有特殊的保证，并且被社区广泛应用。</li>
<li>使用标准库的包会让你的代码更易于管理，别人也会更信任你的代码。</li>
<li>100 余个包被合理组织，分布在 38 个类别里。</li>
<li>标准库里的 log 包拥有记录日志所需的一切功能。</li>
<li>标准库里的 xml 和 json 包让处理这两种数据格式变得很简单。</li>
<li>io 包支持以流的方式高效处理数据。</li>
<li>接口允许你的代码组合已有的功能。</li>
<li><strong>阅读标准库的代码是熟悉 Go 语言习惯的好方法。</strong></li>
</ul>
<h1>第 9 章：测试和性能</h1>
<h2 id="本章主要内容-9">本章主要内容</h2>
<ul>
<li>编写单元测试来验证代码的正确性</li>
<li>使用 httptest 来模拟基于 HTTP 的请求和响应</li>
<li>使用示例代码来给包写文档</li>
<li>通过基准测试来检查性能</li>
<li><strong>作为一名合格的开发者，不应该在程序开发完之后才开始写测试代码。</strong></li>
<li>使用 Go 语言的测试框架，可以在开发的过程中就进行单元测试和基准测试。</li>
<li>和 go build 命令类似，go test 命令可以用来执行写好的测试代码，需要做的就是遵守一些规则来写测试。而且，可以将测试无缝地集成到代码工程和持续集成系统里。</li>
</ul>
<h2 id="单元测试">单元测试</h2>
<ul>
<li>单元测试是用来测试包或者程序的一部分代码或者一组代码的函数。</li>
<li>一个场景是正向路经测试，就是在正常执行的情况下，保证代码不产生错误的测试。</li>
<li>一些单元测试可能会测试负向路径的场景，保证代码不仅会产生错误，而且是预期的错误。</li>
<li>基础测试（basic test）只使用一组参数和结果来测试一段代码。</li>
<li>表组测试（table test）也会测试一段代码，但是会使用多组参数和结果进行测试。</li>
<li>使用一些方法来模仿（mock）测试代码需要使用到的外部资源，如数据库或者网络服务器。</li>
</ul>
<h2 id="基础测试">基础测试</h2>
<ul>
<li>调用 go test -v 来运行这个测试（-v 表示提供冗余输出）。</li>
<li>Go 语言的测试工具只会认为<strong>以 <code>_test.go</code> 结尾的文件是测试文件</strong>。</li>
<li>testing 包提供了从测试框架到报告测试的输出和状态的各种测试功能的支持。<br>
<img src="http://pic.colliexyy.com/16450993159728.jpg" alt=""></li>
<li>第 09 行和第 10 行声明了两个常量，这两个常量包含写测试输出时会用到的对号（√）和叉号（×）</li>
<li>一个测试函数必须是公开的函数，并且<strong>以 Test 单词开头</strong>。不但函数名字要以 Test 开头，而且<strong>函数的签名必须接收一个指向 testing.T 类型的指针，并且不返回任何值</strong>。</li>
<li>测试的输出需使用完整易读的语句，来记录为什么需要这个测试，具体测试了什么，以及测试的结果是什么。</li>
<li>使用方法 t.Log 来输出测试的消息。这个方法还有一个名为 t.Logf 的版本，可以格式化消息。</li>
<li><strong>如果执行 go test 的时候没有加入冗余选项（-v），除非测试失败，否则我们是看不到任何测试输出的。</strong></li>
<li>每个测试函数都应该通过解释这个测试的给定要求（given need），来说明为什么应该存在这个测试。</li>
<li>特别说明了要测试的值。</li>
<li>在每种情况下，我们都会说明测试应有的结果。如果调用失败，除了结果，还会输出叉号以及得到的错误值。如果测试成功，会输出对号。</li>
<li>t.Fatal 方法不但报告这个单元测试已经失败，而且会向测试输出写一些消息，而后<strong>立刻停止这个测试函数的执行</strong>。如果除了这个函数外还有其他没有执行的测试函数，会继续执行其他测试函数。这个方法对应的格式化版本名为 t.Fatalf。</li>
<li>如果需要报告测试失败，但是<strong>并不想停止当前测试函数的执行</strong>，可以使用 t.Error 系列方法</li>
</ul>
<h2 id="表组测试">表组测试</h2>
<ul>
<li>表组测试除了会有一组不同的输入值和期望结果之外，其余部分都很像基础单元测试。</li>
</ul>
<h2 id="模仿调用">模仿调用</h2>
<ul>
<li>依赖不属于你的或者你无法操作的服务来进行测试，也不是一个好习惯。这两点会严重影响测试持续集成和部署的自动化。</li>
<li>httptest 的包让开发人员可以模仿基于 HTTP 的网络调用。</li>
<li>模仿（mocking）是一个很常用的技术手段，用来在运行测试时模拟访问不可用的资源。包 httptest 可以让你能够模仿互联网资源的请求和响应。</li>
<li>httptest.Server 的值是整个模仿服务的关键。</li>
<li>HandlerFunc 类型是一个适配器，允许常规函数作为 HTTP 的处理函数使用。<br>
<img src="http://pic.colliexyy.com/16450994882616.jpg" alt=""></li>
<li>当我们使用由模仿服务器提供的 URL 时，http.Get 调用依旧会按我们预期的方式运行。http.Get 方法调用时并不知道我们的调用是否经过互联网。</li>
<li>如果仔细看用于调用的 URL，会发现这个 URL 使用了 localhost 作为地址，端口是 52065。这个端口号每次运行测试时都会改变。</li>
</ul>
<h2 id="测试服务端点">测试服务端点</h2>
<ul>
<li>服务端点（endpoint）是指与服务宿主信息无关，用来分辨某个服务的地址，一般是不包含宿主的一个路径。</li>
<li>如果在构造网络 API，你会希望直接测试自己的服务的所有服务端点，而不用启动整个网络服务。</li>
<li>handlers_test 包的名字也使用<code>_test</code>结尾。<strong>如果包使用这种方式命名，测试代码只能访问包里公开的标识符。</strong> 即便测试代码文件和被测试的代码放在同一个文件夹中，也只能访问公开的标识符。</li>
</ul>
<h2 id="示例">示例</h2>
<ul>
<li>Go 语言很重视给代码编写合适的文档。专门内置了 godoc 工具来从代码直接生成文档。这个工具的另一个特性是示例代码。</li>
<li>开发人员可以创建自己的示例，并且在包的 Go 文档里展示。</li>
<li><strong>示例基于已经存在的函数或者方法。我们需要使用 Example 作为函数名的开始。</strong></li>
<li><strong>示例代码的函数名字必须基于已经存在的公开的函数或者方法。</strong></li>
<li>写示例代码的目的是展示某个函数或者方法的特定使用方法。</li>
<li><strong>这个<code>Output:</code>标记用来在文档中标记出示例函数运行后期望的输出。</strong></li>
<li>Go 的测试框架知道如何比较注释里的期望输出和标准输出的最终输出。如果两者匹配，这个示例作为测试就会通过，并加入到包的 Go 文档里。如果输出不匹配，这个示例作为测试就会失败。</li>
<li>示例的一组完整文档，包括代码和期望的输出。</li>
<li>由于这个示例也是测试的一部分，可以使用 go test 工具来运行这个示例函数。</li>
<li>运行测试时，使用<code>-run</code>选项指定了特定的函数。<code>-run</code> 选项接受任意的正则表达式，来指定要运行的测试函数。这个选项既支持单元测试，也支持示例函数。</li>
</ul>
<h2 id="基准测试">基准测试</h2>
<ul>
<li>基准测试是一种测试代码性能的方法。</li>
<li>想要测试解决同一问题的不同方案的性能，以及查看哪种解决方案的性能更好时，基准测试就会很有用。</li>
<li>基准测试也可以用来识别某段代码的 CPU 或者内存效率问题，而这段代码的效率可能会严重影响整个应用程序的性能。</li>
<li>许多开发人员会用基准测试来测试不同的并发模式，或者用基准测试来辅助配置工作池的数量，以保证能最大化系统的吞吐量。</li>
<li>基准测试的文件名也必须以<code>_test.go</code>结尾。同时也必须导入 testing 包。</li>
<li><strong>基准测试函数必须以 Benchmark 开头，接受一个指向 testing.B 类型的指针作为唯一参数。</strong></li>
<li><strong>基准测试框架默认会在持续 1 * 秒的时间内，反复调用需要测试的函数。</strong></li>
<li><strong>测试框架每次调用测试函数时，都会增加 b.N 的值。</strong></li>
<li>第一次调用时，b.N 的值为 1。需要注意，一定要将所有要进行基准测试的代码都放到循环里，并且循环要使用 b.N 的值。否则，测试的结果是不可靠的。</li>
<li>如果我们只希望运行基准测试函数，需要加入-bench 选项。<code>go test -v -run=&quot;none&quot; -bench=&quot;BenchmarkSprintf&quot;</code></li>
<li><strong>给<code>-run</code>选项传递了字符串&quot;none&quot;，来保证在运行制订的基准测试函数之前没有单元测试会被运行。</strong></li>
<li><strong>默认情况下，基准测试的最小运行时间是 1 秒。如果想让运行时间更长，可以使用另一个名为<code>-benchtime</code>的选项来更改测试执行的最短时间。</strong></li>
<li><strong>对大多数测试来说，超过 3 秒的基准测试并不会改变测试的精确度。</strong></li>
<li>在代码开始执行循环之前需要进行初始化时，b.ResetTimer 方法用来重置计时器，保证测试代码执行前的初始化代码，不会干扰计时器的结果。</li>
<li><strong>运行基准测试时，另一个很有用的选项是-benchmem 选项。这个选项可以提供每次操作分配内存的次数，以及总共分配内存的字节数。</strong></li>
<li><strong>单位为 allocs/op 的值表示每次操作从堆上分配内存的次数。</strong></li>
<li><strong>单位为 B/op 的值表示每次操作分配的字节数。</strong></li>
</ul>
<h2 id="本章小结-9">本章小结</h2>
<ul>
<li>测试功能被内置到 Go 语言中，Go 语言提供了必要的测试工具。</li>
<li>go test 工具用来运行测试。</li>
<li>测试文件总是以_test.go 作为文件名的结尾。</li>
<li>表组测试是利用一个测试函数测试多组值的好办法。</li>
<li>包中的示例代码，既能用于测试，也能用于文档。</li>
<li>基准测试提供了探查代码性能的机制。</li>
</ul>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 学习笔记</title>
    <url>/2020/10/22/backend_dev/golang_default/</url>
    <content><![CDATA[<h1>array</h1>
<ul>
<li>数组初始化</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># 一维数组</span><br><span class="line"><span class="keyword">var</span> a [<span class="number">4</span>]<span class="type">int</span> 					<span class="comment">//元素自动初始化为零[0 0 0 0] </span></span><br><span class="line">b := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">5</span>&#125; 				<span class="comment">//未提供初始化值得元素自动初始化为0  [2 5 0 0] </span></span><br><span class="line">c := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; 			<span class="comment">//编译器按初始化值数量确定数组长度 [1 2 3] </span></span><br><span class="line">d := [<span class="number">2</span>]<span class="type">string</span>&#123;<span class="string">&quot;TigerwolfC&quot;</span>, <span class="string">&quot;chen_peggy&quot;</span>&#125;</span><br><span class="line">e := [...]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">3</span>: <span class="number">100</span>&#125; 		<span class="comment">//支持索引初始化，但注意数组长度与此有关 [10 0 0 100]</span></span><br><span class="line">f := [<span class="number">4</span>]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;b&quot;</span>, <span class="number">3</span>: <span class="string">&quot;c&quot;</span>&#125; 	<span class="comment">// 可以指定初始化的位置</span></span><br><span class="line"></span><br><span class="line"># 复合类型数组</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line">d := [...]user&#123;</span><br><span class="line">		&#123;<span class="string">&quot;TigerwolfC&quot;</span>, <span class="number">20</span>&#125;, <span class="comment">// 可省略元素类型。</span></span><br><span class="line">		&#123;<span class="string">&quot;chen_peggy&quot;</span>, <span class="number">18</span>&#125;, <span class="comment">// 别忘了最后一行的逗号。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li>数组去重</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveDuplicate</span><span class="params">(v []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">//为了性能需要尽可能的减小拷贝，最悲观的情况每个元素只移动一次。</span></span><br><span class="line">	toIndex := <span class="number">0</span></span><br><span class="line">	p := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> v &#123;</span><br><span class="line">		<span class="comment">// 为了实际去重结构时减小内存拷贝</span></span><br><span class="line">		c := &amp;v[i]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> p == *c &amp;&amp; i != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 重复内容，跳过</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> i != toIndex &#123;</span><br><span class="line">			<span class="comment">// 需要移动当前元素</span></span><br><span class="line">			v[toIndex] = *c</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		toIndex++</span><br><span class="line">		p = *c</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> v[:toIndex]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := []<span class="type">int</span>&#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 升序排序</span></span><br><span class="line">	sort.Slice(v, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> v[i] &lt;= v[j] &#125;)</span><br><span class="line">	<span class="comment">//sort.Ints(v)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 去重</span></span><br><span class="line">	v = RemoveDuplicate(v)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印结果</span></span><br><span class="line">	<span class="comment">// []int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符类型数组去重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArrayRemoveRepeated</span><span class="params">(arr []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	sort.Strings(arr)</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> j <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(arr)<span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(arr) &amp;&amp; arr[i] == arr[j]; j++ &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		arr = <span class="built_in">append</span>(arr[:i+<span class="number">1</span>], arr[j:]...)</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除数组中的某个元素</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除第 i 个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>:]...)</span><br></pre></td></tr></table></figure>
<h1>string</h1>
<ul>
<li>字符串分割</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;-100 123 200&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//指定分割符</span></span><br><span class="line">    countSplit := strings.Split(str, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    fmt.Println(countSplit， <span class="built_in">len</span>(countSplit))</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//指定分割符，指定分割次数</span></span><br><span class="line">    countSplit = strings.SplitN(str, <span class="string">&quot; &quot;</span>, <span class="number">2</span>)</span><br><span class="line">    fmt.Println(countSplit, <span class="built_in">len</span>(countSplit))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="string">&quot;-100&quot;</span> <span class="string">&quot;123&quot;</span> <span class="string">&quot;200&quot;</span>] <span class="number">3</span></span><br><span class="line">[<span class="string">&quot;-100&quot;</span> <span class="string">&quot;123 200&quot;</span>] <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除某个字符</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># 删除下标为 i 的字符</span><br><span class="line">str = str[:i] + str[i+<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong> 遍历字符串时删除字符可能会导致错位。</p>
<ul>
<li>
<p>字符判断</p>
<ul>
<li>判断是否为字母：<code>unicode.IsLetter(v)</code></li>
<li>判断是否为十进制数字：<code>unicode.IsDigit(v)</code></li>
<li>判断是否为数字：<code>unicode.IsNumber(v)</code></li>
<li>判断是否为空白符号：<code>unicode.IsSpace(v)</code></li>
<li>判断是否为 Unicode 标点字符：<code>unicode.IsPunct(v)</code></li>
</ul>
</li>
<li>
<p>字符串查找</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找某个字符是否在这个字符串中存在</span></span><br><span class="line">fmt.Println(strings.Contains(<span class="string">&quot;widuu&quot;</span>, <span class="string">&quot;wi&quot;</span>)) <span class="comment">//true</span></span><br><span class="line">fmt.Println(strings.Contains(<span class="string">&quot;wi&quot;</span>, <span class="string">&quot;widuu&quot;</span>)) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串中是否包含多个字符</span></span><br><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;widuu&quot;</span>, <span class="string">&quot;w&amp;d&quot;</span>)) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串中是否包含rune类型</span></span><br><span class="line"><span class="comment">// rune类型是utf8.RUneCountString可以完整表示全部Unicode字符的类型</span></span><br><span class="line">fmt.Println(strings.ContainsRune(<span class="string">&quot;widuu&quot;</span>, <span class="type">rune</span>(<span class="string">&#x27;w&#x27;</span>))) <span class="comment">//true</span></span><br><span class="line">fmt.Println(strings.ContainsRune(<span class="string">&quot;widuu&quot;</span>, <span class="number">20</span>))        <span class="comment">//fasle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出，在一段字符串中有多少匹配到的字符</span></span><br><span class="line">fmt.Println(strings.Count(<span class="string">&quot;widuu&quot;</span>, <span class="string">&quot;uu&quot;</span>)) <span class="comment">//1</span></span><br><span class="line">fmt.Println(strings.Count(<span class="string">&quot;widuu&quot;</span>, <span class="string">&quot;u&quot;</span>))  <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找字符串，然后返回当前的位置，输入的都是string类型，然后返回的int是位置信息</span></span><br><span class="line">fmt.Println(strings.Index(<span class="string">&quot;widuu&quot;</span>, <span class="string">&quot;i&quot;</span>)) <span class="comment">//1</span></span><br><span class="line">fmt.Println(strings.Index(<span class="string">&quot;widuu&quot;</span>, <span class="string">&quot;u&quot;</span>)) <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找，字符串第一次出现的位置，如果不存在就返回-1</span></span><br><span class="line">fmt.Println(strings.IndexAny(<span class="string">&quot;widuu&quot;</span>, <span class="string">&quot;u&quot;</span>)) <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找第一次粗线的位置，只不过这次C是byte类型的，查找到返回位置，找不到返回-1</span></span><br><span class="line">fmt.Println(strings.IndexByte(<span class="string">&quot;hello xiaowei&quot;</span>, <span class="string">&#x27;x&#x27;</span>)) <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找位置，只不过这次是rune类型的</span></span><br><span class="line">fmt.Println(strings.IndexRune(<span class="string">&quot;widuu&quot;</span>, <span class="type">rune</span>(<span class="string">&#x27;w&#x27;</span>))) <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过类型的转换来用函数查找位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(strings.IndexFunc(<span class="string">&quot;nihaoma&quot;</span>, split)) <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> r == <span class="string">&#x27;a&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找的是最后出现的位置，正好跟index相反</span></span><br><span class="line">fmt.Println(strings.LastIndex(<span class="string">&quot;widuu&quot;</span>, <span class="string">&quot;u&quot;</span>)) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟indexAny正好相反，也是查找最后一个</span></span><br><span class="line">fmt.Println(strings.LastIndexAny(<span class="string">&quot;widuu&quot;</span>, <span class="string">&quot;u&quot;</span>)) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h1>go_tips</h1>
<ul>
<li>格式化 int，位数不够，用 0 补齐</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="number">32</span></span><br><span class="line">sInt := fmt.Sprintf(<span class="string">&quot;%07d&quot;</span>, n) <span class="comment">// 0000032</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>%v 按默认格式输出，</p>
</li>
<li>
<p>%+v 在%v的基础上额外输出字段名，</p>
</li>
<li>
<p>%#v 在%+v的基础上额外输出类型名。</p>
</li>
<li>
<p>用两个协程，依次打印121212</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>) <span class="comment">//控制结束退出的信号</span></span><br><span class="line">	order1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line">	order2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line">	order1 &lt;- <span class="literal">true</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-order1</span><br><span class="line">			fmt.Println(<span class="number">1</span>)</span><br><span class="line">			order2 &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-order2</span><br><span class="line">			fmt.Println(<span class="number">2</span>)</span><br><span class="line">			order1 &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		done &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">//阻塞等待退出信号</span></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>随机数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">//必须有个main包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//设置种子，只需一次</span></span><br><span class="line">	<span class="comment">//rand.Seed(123) 如果种子参数一样，每次运行程序产生的随机数都一样</span></span><br><span class="line">	rand.Seed(time.Now().UnixNano()) <span class="comment">//以当前系统时间作为种子参数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="comment">//产生随机数</span></span><br><span class="line">		<span class="comment">//fmt.Println(&quot;rand = &quot;, rand.Int()) //随机很大的数</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;rand = &quot;</span>, rand.Intn(<span class="number">100</span>)) <span class="comment">//限制在100内的数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Golang 接口功能演示</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> geometry <span class="keyword">interface</span> &#123;</span><br><span class="line">	area() <span class="type">float32</span></span><br><span class="line">	perimeter() <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	radius <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span></span> area() <span class="type">float32</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.height * r.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span></span> area() <span class="type">float32</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span></span> perimeter() <span class="type">float32</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * (r.height + r.width)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span></span> perimeter() <span class="type">float32</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(g geometry)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;面积：&quot;</span>, g.area())</span><br><span class="line">	fmt.Println(<span class="string">&quot;周长：&quot;</span>, g.perimeter())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := rect&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	measure(r)</span><br><span class="line">	c := circle&#123;<span class="number">3</span>&#125;</span><br><span class="line">	measure(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面积： 12</span><br><span class="line">周长： 14</span><br><span class="line">面积： 28.274334</span><br><span class="line">周长： 18.849556</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 操作 Excel 总结</title>
    <url>/2022/05/30/backend_dev/golang_excel/</url>
    <content><![CDATA[<h1>读</h1>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f, err := excelize.OpenFile(<span class="string">&quot;./HealthCheck.xlsx&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// Close the spreadsheet.</span></span><br><span class="line">		<span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Excel 文件关闭失败: &quot;</span> + err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get all the rows in the Sheet1.</span></span><br><span class="line">	rows, err := f.GetRows(<span class="string">&quot;监测点列表&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> || <span class="built_in">len</span>(rows) == <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Excel 文件读取失败: &quot;</span> + err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, row := <span class="keyword">range</span> rows[<span class="number">1</span>:] &#123;</span><br><span class="line">		<span class="comment">// 在表格末尾有空格的时候，每一行实际的 row 并不等长</span></span><br><span class="line">		<span class="comment">// 但是行首有空格并不会导致 row 长度变短</span></span><br><span class="line">		rowTmp := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">6</span>)</span><br><span class="line">		<span class="keyword">for</span> k, v := <span class="keyword">range</span> row &#123;</span><br><span class="line">			rowTmp[k] = v</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, row)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, rowTmp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;----------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">	r, _ := f.Rows(<span class="string">&quot;监测点列表&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.Next() &#123;</span><br><span class="line">			rst, _ := r.Columns()</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, rst)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;----------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查行的存在性</span></span><br><span class="line">	visible1, _ := f.GetRowVisible(<span class="string">&quot;Sheet1&quot;</span>, <span class="number">2</span>)</span><br><span class="line">	visible2, _ := f.GetRowVisible(<span class="string">&quot;代理列表&quot;</span>, <span class="number">2</span>)</span><br><span class="line">	visible3, _ := f.GetRowVisible(<span class="string">&quot;代理列表&quot;</span>, <span class="number">10</span>)</span><br><span class="line">	fmt.Println(visible1, visible2, visible3)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;----------------------------&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1>写</h1>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := excelize.NewFile()</span><br><span class="line">	<span class="comment">// 修改默认的 Sheet1 命名</span></span><br><span class="line">	f.SetSheetName(<span class="string">&quot;Sheet1&quot;</span>, <span class="string">&quot;Test_Origin&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a new sheet.</span></span><br><span class="line">	f.NewSheet(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 填充单位格</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		f.SetCellValue(<span class="string">&quot;Test&quot;</span>, <span class="string">&quot;A&quot;</span>+strconv.Itoa(i), strconv.Itoa(i*<span class="number">100</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置列宽，可一次设置等宽多列</span></span><br><span class="line">	f.SetColWidth(<span class="string">&quot;Test&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;H&quot;</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置行高</span></span><br><span class="line">	f.SetRowHeight(<span class="string">&quot;Test&quot;</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置列表大纲模式</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= <span class="number">8</span>; i++ &#123;</span><br><span class="line">		f.SetRowOutlineLevel(<span class="string">&quot;Test&quot;</span>, i, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置下拉选项</span></span><br><span class="line">	<span class="comment">// 新建下拉数据验证数据结构，可以选空 allowBlank:true</span></span><br><span class="line">	dvRangeAgent := excelize.NewDataValidation(<span class="literal">true</span>)</span><br><span class="line">	<span class="comment">// 此处设置需要添加数据验证的行</span></span><br><span class="line">	dvRangeAgent.Sqref = <span class="string">&quot;D2:F10&quot;</span></span><br><span class="line">	<span class="comment">// 此处设置数据验证选项源</span></span><br><span class="line">	dvRangeAgent.SetSqrefDropList(<span class="string">&quot;=Test!$A$1:$A$10&quot;</span>)</span><br><span class="line">	<span class="comment">// 添加到对应Sheet</span></span><br><span class="line">	f.AddDataValidation(<span class="string">&quot;Test&quot;</span>, dvRangeAgent)</span><br><span class="line">	f.AddDataValidation(<span class="string">&quot;Test_Origin&quot;</span>, dvRangeAgent)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置单元格样式</span></span><br><span class="line">	<span class="comment">// 样式除了颜色填充以外还有边框，字体等等</span></span><br><span class="line">	style, _ := f.NewStyle(&amp;excelize.Style&#123;</span><br><span class="line">		Fill: excelize.Fill&#123;Type: <span class="string">&quot;pattern&quot;</span>, Color: []<span class="type">string</span>&#123;<span class="string">&quot;#FF0000&quot;</span>&#125;, Pattern: <span class="number">1</span>&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	f.SetCellStyle(<span class="string">&quot;Test_Origin&quot;</span>, <span class="string">&quot;A1&quot;</span>, <span class="string">&quot;H10&quot;</span>, style)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save spreadsheet by the given path.</span></span><br><span class="line">	<span class="keyword">if</span> err := f.SaveAs(<span class="string">&quot;./test.xlsx&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 包/中间件</title>
    <url>/2021/12/10/backend_dev/golang_package/</url>
    <content><![CDATA[<h1><a href="https://github.com/casbin/casbin">casbin</a></h1>
<blockquote>
<p>权限管理。</p>
</blockquote>
<h2 id="简介">简介</h2>
<p>权限管理在几乎每个系统中都是必备的模块。如果项目开发每次都要实现一次权限管理，无疑会浪费开发时间，增加开发成本。因此，casbin库出现了。casbin是一个强大、高效的访问控制库。支持常用的多种访问控制模型，如ACL/RBAC/ABAC等。可以实现灵活的访问权限控制。同时，casbin支持多种编程语言，Go/Java/Node/PHP/Python/.NET/Rust。我们只需要一次学习，多处运用。</p>
<h2 id="结构">结构</h2>
<p>权限实际上就是控制<strong>谁</strong>能对什么<strong>资源</strong>进行什么操作。casbin 将访问控制模型抽象到一个基于 PERM（Policy，Effect，Request，Matchers） 元模型的配置文件（模型文件）中。因此切换或更新授权机制只需要简单地修改配置文件。</p>
<p>policy 是策略或者说是规则的定义。它定义了具体的规则。</p>
<p>effect 根据对请求运用匹配器得出的所有结果进行汇总，来决定该请求是允许还是拒绝。</p>
<p>request 是对访问请求的抽象，它与 e.Enforce() 函数的参数是一一对应的</p>
<p>matcher 匹配器会将请求与定义的每个 policy 一一匹配，生成多个匹配结果。</p>
<span id="more"></span>
<h1><a href="https://github.com/boltdb/bolt">BoltDB</a></h1>
<blockquote>
<p>嵌入式kv数据库</p>
</blockquote>
<h2 id="简介-2">简介</h2>
<p>BoltDB设计源于LMDB，具有以下特点：</p>
<ul>
<li>直接使用API存取数据，没有查询语句；</li>
<li>支持完全可序列化的ACID事务，这个特性比LevelDB强；</li>
<li>数据保存在内存映射的文件里。没有wal、线程压缩和垃圾回收；</li>
<li>通过COW技术，可实现无锁的读写并发，但是无法实现无锁的写写并发，这就注定了读性能超高，但写性能一般，适合与读多写少的场景。</li>
</ul>
<h1><a href="https://gorm.io/zh_CN/">GORM</a></h1>
<blockquote>
<p>go-orm 数据库关系映射管理工具</p>
</blockquote>
<ul>
<li>gorm 更新数据，当用结构体更新的时候，当结构体的值是&quot;&quot;或者0，false 等该数据类型的零值时，就什么也不会更新。</li>
<li><a href="https://github.com/go-gorm/datatypes">datatypes</a>仓库负责收集各种自定义数据类型。</li>
<li>gorm 支持 clause 来实现 Upsert 的功能，但是发现只支持根据 id 进行判断，如果对应 id 记录存在则更新，对应 id 记录不存在则插入。</li>
</ul>
<h2 id="gorm-实现-upsert">gorm 实现 upsert</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gorm 实现有则修改，无则新增</span></span><br><span class="line">res = dao.Db.Table(xxx).Where(<span class="string">&quot;abc = ?&quot;</span>, r.Abc).First(&amp;oneRow)</span><br><span class="line"><span class="keyword">if</span> res.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> res.Error == gorm.ErrRecordNotFound &#123;</span><br><span class="line">		res = dao.Db.Table(xxx).Create(&amp;r)</span><br><span class="line">		<span class="keyword">if</span> res.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> res.Error</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	res = dao.Db.Table(xxx).Model(&amp;oneRow).Updates(&amp;r)</span><br><span class="line">	<span class="keyword">if</span> res.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res.Error</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://gorm.io/zh_CN/docs/update.html">gorm update 的坑</a></li>
<li><a href="https://gorm.io/zh_CN/docs/models.html">gorm 模型设计</a></li>
</ul>
<h1><a href="https://github.com/robfig/cron">cron</a></h1>
<blockquote>
<p>定时任务</p>
</blockquote>
<p><a href="https://blog.csdn.net/zjbyough/article/details/113853582">Golang 定时任务 github/robfig/cron/v3 使用与源码解析</a></p>
<h1>flag</h1>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">log := flag.String(<span class="string">&quot;LOG&quot;</span>, <span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;设置服务日志级别&quot;</span>)</span><br><span class="line">host := flag.String(<span class="string">&quot;HOST&quot;</span>, <span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;数据库主机地址&quot;</span>)</span><br><span class="line">port := flag.Int(<span class="string">&quot;PORT&quot;</span>, <span class="number">5432</span>, <span class="string">&quot;数据库端口&quot;</span>)</span><br><span class="line">user := flag.String(<span class="string">&quot;USER&quot;</span>, <span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;数据库用户名称&quot;</span>)</span><br><span class="line">name := flag.String(<span class="string">&quot;DBNAME&quot;</span>, <span class="string">&quot;postgres&quot;</span>, <span class="string">&quot;数据库Database名称&quot;</span>)</span><br><span class="line">pwd := flag.String(<span class="string">&quot;PASSWORD&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;数据库连接密码&quot;</span>)</span><br><span class="line"></span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">flag.Set(<span class="string">&quot;logtostderr&quot;</span>, <span class="string">&quot;false&quot;</span>) <span class="comment">//日志输出到stderr，不输出到日志文件。false为关闭</span></span><br><span class="line">flag.Set(<span class="string">&quot;log_file&quot;</span>, <span class="string">&quot;../log/srv.log&quot;</span>)</span><br><span class="line"><span class="comment">// 一定要用指针</span></span><br><span class="line">flag.Set(<span class="string">&quot;stderrthreshold&quot;</span>, *log)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：注册之后，<code>flag.Parse()</code>完成才能拿到参数具体值。且一定要用指针类型使用 flag 解析出来的值，不然就会是默认值，而获取不到命令参数传递的值。</p>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 代码的测试方法</title>
    <url>/2021/05/22/backend_dev/golang_test/</url>
    <content><![CDATA[<h1>性能测试</h1>
<p>注册 pprof 服务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 开启服务</span></span><br><span class="line">pprofOpen := c.GetBool(<span class="string">&quot;pprof.open&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> pprofOpen &#123;</span><br><span class="line">	<span class="comment">// 运行pprof服务器，其路由已在pprof包自动注册</span></span><br><span class="line">	pprofPort := c.GetInt(<span class="string">&quot;pprof.port&quot;</span>)</span><br><span class="line">	s.pprofSvr = &amp;http.Server&#123;</span><br><span class="line">		Addr:    <span class="string">&quot;:&quot;</span> + strconv.Itoa(pprofPort),</span><br><span class="line">		Handler: <span class="literal">nil</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := s.pprofSvr.ListenAndServe()</span><br><span class="line">		log.Infof(<span class="string">&quot;pprof server down: %+v&quot;</span>, err)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止服务</span></span><br><span class="line">c := config.GetConfig()</span><br><span class="line">pprofOpen := c.GetBool(<span class="string">&quot;pprof.open&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> pprofOpen &#123;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="comment">// 开始关闭pprof服务器</span></span><br><span class="line">		ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">		<span class="keyword">defer</span> cancel()</span><br><span class="line">		<span class="keyword">if</span> err := s.pprofSvr.Shutdown(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Infof(<span class="string">&quot;Server Shutdown: &quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go tool pprof --seconds 60 http://127.0.0.1:8098/debug/pprof/profile</span><br><span class="line">&gt;&gt; web</span><br></pre></td></tr></table></figure>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[pprof]</span></span><br><span class="line"><span class="attr">open</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">8098</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 上传下载</title>
    <url>/2022/06/01/backend_dev/golang_upload_download/</url>
    <content><![CDATA[<h1>Go 实现上传下载功能</h1>
<h1>上传</h1>
<h2 id="单文件上传">单文件上传</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line">	<span class="comment">// 给表单限制上传大小 (默认 32 MiB)</span></span><br><span class="line">	<span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">	router.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 单文件</span></span><br><span class="line">		file, _ := c.FormFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">		log.Println(file.Filename)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 上传文件到指定的路径</span></span><br><span class="line">		c.SaveUploadedFile(file, <span class="string">&quot;./test.xmind&quot;</span>)</span><br><span class="line"></span><br><span class="line">		c.String(http.StatusOK, fmt.Sprintf(<span class="string">&quot;uploaded!&quot;</span>))</span><br><span class="line">	&#125;)</span><br><span class="line">	router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="多文件上传">多文件上传</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line">	<span class="comment">// 给表单限制上传大小 (默认 32 MiB)</span></span><br><span class="line">	<span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">	router.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 多文件</span></span><br><span class="line">		form, _ := c.MultipartForm()</span><br><span class="line">		<span class="comment">// form-data 的 key 值就是 &quot;upload[]&quot; 括号不能省略</span></span><br><span class="line">		files := form.File[<span class="string">&quot;upload[]&quot;</span>]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">			log.Println(file.Filename)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 上传文件到指定的路径</span></span><br><span class="line">			c.SaveUploadedFile(file, <span class="string">&quot;./&quot;</span>+file.Filename)</span><br><span class="line">		&#125;</span><br><span class="line">		c.String(http.StatusOK, fmt.Sprintf(<span class="string">&quot;%d files uploaded!&quot;</span>, <span class="built_in">len</span>(files)))</span><br><span class="line">	&#125;)</span><br><span class="line">	router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>下载</h1>
<h2 id="直接下载">直接下载</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">&quot;/download&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.Header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/octet-stream&quot;</span>)</span><br><span class="line">		<span class="comment">// filename 中文乱码问题 filename*=utf-8&#x27;&#x27;xxx</span></span><br><span class="line">		<span class="comment">//disposition := fmt.Sprintf(&quot;attachment; filename*=utf-8&#x27;&#x27;%s&quot;, url.QueryEscape(&quot;工作簿1.xlsx&quot;))</span></span><br><span class="line">		disposition := <span class="string">&quot;attachment; filename=下载测试.xlsx&quot;</span></span><br><span class="line">		c.Header(<span class="string">&quot;Content-Disposition&quot;</span>, disposition)</span><br><span class="line">		<span class="comment">//file, err := ioutil.ReadFile(&quot;../../PostgreSQL数据库内核分析.pdf&quot;)</span></span><br><span class="line">		file, err := ioutil.ReadFile(<span class="string">&quot;../../工作簿1.xlsx&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">		c.Writer.Write(file)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="展示文件，手动下载（适合PDF等文件）">展示文件，手动下载（适合PDF等文件）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">&quot;/download&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.File(<span class="string">&quot;../../PostgreSQL数据库内核分析.pdf&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="限速下载">限速下载</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">&quot;/download&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		file, err := os.Open(<span class="string">&quot;../../工作簿1.xlsx&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">		<span class="comment">//读取文件头部信息</span></span><br><span class="line">		fileHeader := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">512</span>)</span><br><span class="line">		file.Read(fileHeader) <span class="comment">//取出文件头部信息</span></span><br><span class="line"></span><br><span class="line">		fileStat, _ := file.Stat()</span><br><span class="line"></span><br><span class="line">		<span class="comment">//c.Header(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;)</span></span><br><span class="line">		c.Header(<span class="string">&quot;Content-Type&quot;</span>, http.DetectContentType(fileHeader))       <span class="comment">//返回检测到的文件类型</span></span><br><span class="line">		c.Header(<span class="string">&quot;Content-Length&quot;</span>, strconv.FormatInt(fileStat.Size(), <span class="number">10</span>)) <span class="comment">//返回文件大小</span></span><br><span class="line">		<span class="comment">// filename 中文乱码问题 filename*=utf-8&#x27;&#x27;xxx</span></span><br><span class="line">		<span class="comment">//disposition := fmt.Sprintf(&quot;attachment; filename*=utf-8&#x27;&#x27;%s&quot;, url.QueryEscape(&quot;工作簿1.xlsx&quot;))</span></span><br><span class="line">		disposition := <span class="string">&quot;attachment; filename=下载测试.xlsx&quot;</span></span><br><span class="line">		c.Header(<span class="string">&quot;Content-Disposition&quot;</span>, disposition)</span><br><span class="line"></span><br><span class="line">		<span class="comment">//file.Seek(0, 0)</span></span><br><span class="line">		<span class="comment">//io.Copy(c.Writer, file)</span></span><br><span class="line">		c.Writer.Write(fileHeader)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			tmp := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1000</span>) <span class="comment">//通过切片长度控制流速</span></span><br><span class="line">			n, err := file.Read(tmp)</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			c.Writer.Write(tmp[:n])</span><br><span class="line">			time.Sleep(time.Second * <span class="number">1</span>) <span class="comment">//通过sleep时间控制流速</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>《Go Web 编程》读书笔记</title>
    <url>/2022/02/28/backend_dev/goweb/</url>
    <content><![CDATA[<h1>GO Web 编程</h1>
<h1>Go 语言介绍</h1>
<h1>第一章：Go与web应用</h1>
<h2 id="HTTP">HTTP</h2>
<ul>
<li>HTTP 是一种<strong>无状态、由文本构成</strong>的请求-响应(request-response)协议，这种协议使用的是客户端-服务器(client-server)计算模型</li>
<li>CGI 通用网管接口(Common Gateway Interface)，允许web服务器与一个独立运行于web服务器进程之外的进程对接</li>
<li>SSI(server-side includes)服务器端，允许开发者在HTML文件里包含一些指令，衍生出了JSP(Java Server Pages)，ASP(Active Server Pages)等Web模板引擎</li>
</ul>
<hr>
<ul>
<li>http请求
<ul>
<li>请求行(request-line)</li>
<li>零个或任意多个请求首部(header)</li>
<li>一个空行</li>
<li>可选的报文主体(body)</li>
</ul>
</li>
<li>请求方法
<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
<li>PUT</li>
<li>DELETE</li>
<li>TRACE</li>
<li>OPTIONS</li>
<li>CONNECT</li>
<li>PATCH</li>
</ul>
</li>
</ul>
<span id="more"></span>
<hr>
<ul>
<li>http响应
<ul>
<li>一个状态行</li>
<li>零个或任意数量的响应首部</li>
<li>一个空行</li>
<li>一个可选的报文主体</li>
</ul>
</li>
<li>响应状态码
<ul>
<li>1XX 情报状态码</li>
<li>2XX 成功状态码</li>
<li>3XX 重定向状态码</li>
<li>4XX 客户端错误状态码</li>
<li>5XX 服务器错误状态码</li>
</ul>
</li>
<li>响应首部
<ul>
<li>Allow</li>
<li>Content-Length</li>
<li>Content-Type</li>
<li>Date</li>
<li>Location</li>
<li>Server</li>
<li>Set-Cookie</li>
<li>WWW-Authenticate</li>
</ul>
</li>
</ul>
<hr>
<h2 id="URI">URI</h2>
<ul>
<li>URI一般格式为：<code>&lt;方案名称&gt;:&lt;分层部分&gt;[ ? &lt;查询参数&gt;] [ # &lt;片段&gt;]</code></li>
<li>因每个URL都是一个单独的字符串，所以URL里不能包含空格，?和#这些符号也不能做其它用途，我们需要用URL编码(百分号编码)对这些字符进行转换，做法是<strong>将该字符在ASCII码中的字节值转换为16进制，并在前面加上%</strong>，例如空格就被转换为%20。</li>
</ul>
<h2 id="处理器">处理器</h2>
<p>Web应用中的处理器出了要接收和处理客户端发来的请求，还需要调用模板引擎，然后由模板引擎生成HTML并把数据填充至将要回传给客户端的响应报文中</p>
<h2 id="模板引擎-template-engine">模板引擎(template engine)</h2>
<ul>
<li>静态模板</li>
<li>动态模板</li>
</ul>
<h1>第二章：ChitChat论坛</h1>
<ul>
<li>请求的接收和处理是所有 Web 应用的核心。</li>
<li>多路复用器会将 HTTP 请求重定向到正确的处理器进行处理，针对静态文件的请求也是如此。</li>
<li><strong>处理器函数是一种接受 ResponseWriter 和 Request 指针作为参数的 Go 函数。</strong></li>
<li>cookie 可以用作一种访问控制机制。</li>
<li>对模板文件以及数据进行语法分析会产生相应的 HTML， 这些 HTML 会被用作返回给浏览器的响应数据。</li>
<li>通过使用 sql 包以及相应的 SQL 语句，用户可以将数据持久地存储在关系数据库中。</li>
</ul>
<h1>第三章：接收请求</h1>
<h2 id="net-http标准库">net/http标准库</h2>
<p><img src="http://pic.colliexyy.com/goweb.jpg" alt=""></p>
<p>net/http 标准库通常包括两个部分，客户端和服务器，我们可以通过ListenAndServe创建一个简陋的服务器</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会使用默认的80端口进行网络连接，并且使用默认的多路复用器DefaultServeMux，我们也可以通过Server结构进行更详细的配置</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    server := http.Server &#123;</span><br><span class="line">        Addr: <span class="string">&quot;127.0.0.1:80&quot;</span>,</span><br><span class="line">        Handler: <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理器和处理函数">处理器和处理函数</h2>
<h3 id="处理器-2">处理器</h3>
<p>前面的代码会返回404响应，因为我们还没有为请求编写相应的处理器。一个处理器就是一个拥有ServeHTTP方法的接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过实现这个接口来编写处理器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MyHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    handler := MyHandler&#123;&#125;</span><br><span class="line">    server := http.Server &#123;</span><br><span class="line">        Addr: <span class="string">&quot;127.0.0.1:80&quot;</span>,</span><br><span class="line">        Handler: &amp;handler,</span><br><span class="line">    &#125;</span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以设置多个处理器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hello *HelloHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WorldHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(world *WorldHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Reuest) &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hello := HelloHandler&#123;&#125;</span><br><span class="line">    world := WorldHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line">    server := http.Server &#123;</span><br><span class="line">        Addr: <span class="string">&quot;127.0.0.1:80&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    http.Handle(<span class="string">&quot;/hello&quot;</span>, &amp;hello)</span><br><span class="line">    http.Handle(<span class="string">&quot;/world&quot;</span>, &amp;world)</span><br><span class="line"></span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下Handle函数再源码中的定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="type">string</span>, handler Handler)</span></span> &#123; </span><br><span class="line">    DefaultServeMux.Handle(pattern, handler) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是在调用DefaultServeMux的某个方法，前面我们已经提到过了DefaultServeMux是个默认多路复用器，实际上它也是个Handler处理器，因为他是ServeMux结构的一个实例，而ServeMux也实现了Handler接口的ServeHTTP方法。这样就可以对不同的请求做出不同的响应。</p>
<h3 id="处理器函数">处理器函数</h3>
<p>处理器函数是与处理器拥有同样行为的函数，它们与ServeHTTP拥有同样的函数签名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span> <span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    server := http.Server &#123;</span><br><span class="line">        Addr: <span class="string">&quot;127.0.0.1:8080&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line"></span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HandleFunc是Go语言拥有的一种函数类型，它可以把一个带有正确签名的f转换为带有方法f的handler。</p>
<p>来看看HandleFunc的源码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> HandleFunc(pattern <span class="type">string</span>, handler <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;http: nil handler&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Handle函数是不是似曾相识！</p>
<h2 id="串联多个处理器和处理器函数">串联多个处理器和处理器函数</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w *http.ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(h http.Handler)</span></span> http.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Log!&quot;</span>)</span><br><span class="line">        h(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    server := http.Server &#123;</span><br><span class="line">        Addr: <span class="string">&quot;127.0.0.1:8080&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, log(hello))</span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line">其中HandlerFunc是实现了Handler接口的函数类型，源码定义：</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ServeMux">ServeMux</h2>
<p>ServeMux是一个HTTP请求多路复用器，负责接收HTTP请求并根据请求中的URL将请求重定向到正确的处理器。ServeMux包含一个映射，这个映射会将URL映射至相应的处理器。值得一提的是，ServeMux无法使用变量实现URL模式匹配，因此必要时我们完全可以用其它自建的多路复用器来代替ServeMux，如HttpRouter等高效轻量的第三方复用器</p>
<h1>第四章：处理请求</h1>
<h2 id="请求和响应">请求和响应</h2>
<h3 id="Request结构">Request结构</h3>
<ul>
<li>URL字段</li>
<li>Header字段</li>
<li>Body字段</li>
<li>Form, PostForm, MultipartForm字段</li>
</ul>
<p>在处理器函数中，我们可以通过Request获取各个字段的详细信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_request_value</span><span class="params">(w *http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    h := r.Header</span><br><span class="line">    brower := r.Header.Get(<span class="string">&quot;User-Agent&quot;</span>)</span><br><span class="line">    fme.Fprintln(w, h)</span><br><span class="line"></span><br><span class="line">    body := <span class="built_in">make</span>([]<span class="type">byte</span>, r.ContentLength)</span><br><span class="line">    r.Body.Read(body)</span><br><span class="line">    fmt.Fprintln(w, <span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Go与HTML表单">Go与HTML表单</h2>
<p><strong>用户在表单中输入的数据会以键值对的形式记录在请求的主体中</strong>，其中表单中的<strong>enctype</strong>属性决定了以何种形式发送键值对。默认属性值为application/x-www-form-urlencoded，这个属性会把表单中的数据编码一个连续的长查询字符串，另一种编码方式为multipart/form-data，表单中的数据会被转换为一条MIME报文，每个键值对都构成了这个报文的一部分。简单来说，<strong>当表单只需要传送简单数据时，默认编码更加简单，高效；而当表单需要传输大量数据(如文件)时，使用后一种编码方式会更好。</strong> 有些时候，用户可以通过Base64编码，以文本方式传送二进制数据。</p>
<p>使用Request结构获取表单数据的一般步骤是：</p>
<ol>
<li>调用ParseForm或者ParseMultipartForm方法进行语法分析</li>
<li>访问Form, PostForm, MultipartForm等字段获取数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_form_data1</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm()</span><br><span class="line">    fmt.Fprintln(w, r.Form)</span><br><span class="line">    <span class="comment">// PostForm字段只支持默认编码，并且只返回表单值，不返回URL查询值</span></span><br><span class="line">    fmt.Fprintln(w, r.PostForm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用multipart/form-data编码时，表单数据会被存储到MultipartForm字段中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_form_data2</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseMultipartForm(<span class="number">1024</span>)</span><br><span class="line">    fmt.Fprintln(w, r.MultipartForm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以使用FormValue或者PostFormValue快速获取表单值，也两个方法会自动调用ParseForm或者ParseMultipartForm方法，其中PostFormValue只会返回表单键值对而不会返回URL键值对</p>
<p>使用FormFile方法可以快速的获取被上传的文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    file, _, err := r.FormFile(<span class="string">&quot;upload&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        data, err := ioutil.ReadAll(file)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintln(w, <span class="type">string</span>(data))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ResponseWriter">ResponseWriter</h2>
<ul>
<li>Write 接收一个字节数组，并写入到HTTP响应主体中</li>
<li>WriteHeader 改变HTTP响应状态码</li>
<li>Header 修改HTTP响应首部</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    json2 <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">    User <span class="type">string</span></span><br><span class="line">    Threads []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeExample</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    str := <span class="string">`&lt;html&gt;</span></span><br><span class="line"><span class="string">            &lt;head&gt;&lt;title&gt;Go&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">            &lt;body&gt;&lt;h1&gt;Hello world&lt;/h1&gt;&lt;/body&gt;</span></span><br><span class="line"><span class="string">            &lt;/html&gt;`</span></span><br><span class="line">    w.Write([]<span class="type">byte</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeHeaderExample</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.WriteHeader(<span class="number">501</span>)</span><br><span class="line">    fmt.Fprintln(w, <span class="string">&quot;No such service, try next door&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">headerExample</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Header().Set(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;http://baidu.com&quot;</span>)</span><br><span class="line">    w.WriteHeader(<span class="number">302</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jsonExample</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    post := &amp;Post&#123;</span><br><span class="line">        User: <span class="string">&quot;authetic&quot;</span>,</span><br><span class="line">        Threads: []<span class="type">string</span>&#123;<span class="string">&quot;first&quot;</span>, <span class="string">&quot;second&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    json, _ := json2.Marshal(post)</span><br><span class="line">    w.Write(json)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    server := http.Server&#123;</span><br><span class="line">        Addr: <span class="string">&quot;127.0.0.1:8080&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/write&quot;</span>, writeExample)</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/writeheader&quot;</span>, writeHeaderExample)</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/redirect&quot;</span>, headerExample)</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/json&quot;</span>, jsonExample)</span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cookie">cookie</h2>
<h3 id="Go与cookie">Go与cookie</h3>
<p>响应头部没有设置Expires字段的通常被成为会话cookie，浏览器关闭或刷新cookie就会消失，设置了Expires字段的通常被称为持久cookie，在过期时间之前会一直存在。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set_cookie</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    c1 := http.Cookie&#123;</span><br><span class="line">        Name: <span class="string">&quot;first_cookie&quot;</span>,</span><br><span class="line">        Value: <span class="string">&quot;Go Web&quot;</span>,</span><br><span class="line">        HttpOnly: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    c2 := http.Cookie&#123;</span><br><span class="line">        Name: <span class="string">&quot;second_cookie&quot;</span>,</span><br><span class="line">        Value: <span class="string">&quot;Go Web&quot;</span>,</span><br><span class="line">        HttpOnly: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    http.SetCookie(w, &amp;c1)</span><br><span class="line">    http.SetCookie(w, &amp;c2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_cookie</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// h := r.Header[&quot;Cookie&quot;]</span></span><br><span class="line">    cl, err := r.Cookie(<span class="string">&quot;first_cookie&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintln(w, <span class="string">&quot;Something wrong&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    cs := r.Cookies()</span><br><span class="line">    fmt.Fprintln(w, cl)</span><br><span class="line">    fmt.Fprintln(w, cs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="cookie实现闪现消息">cookie实现闪现消息</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setMessage</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    msg := []<span class="type">byte</span>(<span class="string">&quot;Hello Go&quot;</span>)</span><br><span class="line">    c := http.Cookie&#123;</span><br><span class="line">        Name: <span class="string">&quot;flash&quot;</span>,</span><br><span class="line">        Value: base64.URLEncoding.EncodeToString(msg),</span><br><span class="line">    &#125;</span><br><span class="line">    http.SetCookie(w, &amp;c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showMessage</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    c, err := r.Cookie(<span class="string">&quot;flash&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == http.ErrNoCookie &#123;</span><br><span class="line">            fmt.Fprintln(w, <span class="string">&quot;No message found&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rc := http.Cookie&#123;</span><br><span class="line">            Name: <span class="string">&quot;flash&quot;</span>,</span><br><span class="line">            MaxAge: <span class="number">-1</span>,</span><br><span class="line">            Expires: time.Unix(<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">        &#125;</span><br><span class="line">        http.SetCookie(w, &amp;rc)</span><br><span class="line">        val, _ := base64.URLEncoding.DecodeString(c.Value)</span><br><span class="line">        fmt.Fprintln(w, <span class="type">string</span>(val))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>第五章：内容展示</h1>
<ul>
<li>在 Web 应用中，模板引擎会把模板和数据进行合并，生成将要返回给客户端的 HTML。</li>
<li>Go 的标准模板引擎定义在 html/template 包当中。</li>
<li>Go 模板引擎的工作方式就是对一个模板进行语法分析，接着在执行这个模板的时候，将一个ResponseWriter 以及一些数据传递给它。被调用的模板引擎会对传入的已分析模板以及数据进行合并，然后把合并的结果传递给 ResponseWriter。</li>
<li>Go 的模板拥有一系列丰富多样并且威力强大的动作，这些动作就是一系列命令，它们可以告诉模板应该以何种方式与数据合并。</li>
<li>除了动作之外，模板还可以包含参数、管道和变量：其中<strong>参数用于表示模板中的数据值，管道用于串联起多个参数和函数，至于变量则会作为动作的组件而存在。</strong></li>
<li>Go 拥有一系列受限的模板函数。此外，通过创建一个函数映射并将它与模板进行绑定，用户也可以创建出自己的模板函数。</li>
<li>Go 的模板引擎可以根据数据所在的位置改变数据的显示方式，这种上下文感知特性能够有效地防御 XSS 攻击。</li>
<li>人们在设计一个拥有一致外观和使用感受的 Web 应用时，常常会用到 Web 布局，Go可以使用嵌套模板来实现 Web 布局。</li>
</ul>
<h1>第六章：存储数据</h1>
<ul>
<li>通过使用结构将数据存储在<strong>内存</strong>里面，以此来构建数据缓存机制并提高响应速度。</li>
<li>通过使用 CSV 或者 gob 二进制格式将数据存储在<strong>文件</strong>里面，可以对用户提交的文件进行处理，或者为缓存数据提供备份。</li>
<li>通过使用 database/sql 包，可以对关系数据库执行 CRUD 操作，并在不同的数据之间建立起相应的关系。</li>
<li>通过 Sqlx 和 Gorm 这样的第三方数据访问库，可以使用威力更强大的工具去操纵<strong>数据库</strong>中的数据。</li>
</ul>
<h1>第七章：Go Web 服务</h1>
<ul>
<li>编写 Web 服务是 Go 语言目前非常常见的用途之一，了解如何构建 Web 服务是一项非常有价值的技能。</li>
<li>Web 服务主要分为两种类型——一种是基于 SOAP 的 Web 服务，而另一种则是基于 REST 的 Web 服务
<ul>
<li>SOAP 是一种协议，它能够对定义在 XML 中的结构化数据进行交换。但是，因为 SOAP 的 WSDL 报文有可能会变得非常复杂，所以基于 SOAP 的 Web 服务没有基于 REST 的 Web 服务那么流行。</li>
<li>基于 REST 的 Web 服务通过 HTTP 协议向外界公开自己拥有的资源，并允许外界通过 HTTP 协议对这些资源执行指定的动作。</li>
</ul>
</li>
<li>创建和分析 XML 以及 JSON 的步骤都是相似的，用户要么根据指定的结构去生成 XML 或者JSON，要么从指定的结构里面提取数据到 XML 或者 JSON 里面，前一种操作称为封装，而后一种操作则称为解封。</li>
</ul>
<h1>第八章：应用测试</h1>
<ul>
<li>Go 通过 go test 命令为用户提供了内置的测试工具，并提供了 testing 包以便实现单元测试。</li>
<li>testing 包提供了基本的功能测试以及基准测试能力。</li>
<li>对于 Go 语言来说，Web 应用的单元测试可以通过 testing/httptest 包来完成。</li>
<li>使用测试替身可以让测试用例变得更加独立</li>
<li>实现测试替身的一种方法是使用<strong>依赖注入设计模式</strong>。</li>
<li>Go 语言拥有许多第三方测试库，其中包括对 Go 的测试功能进行扩展的 Gocheck 包，以及实现了行为驱动测试的 Ginkgo 包。</li>
</ul>
<h1>第九章：发挥 Go 的并发优势</h1>
<ul>
<li>Go web 服务器本身是并发的，服务器会把接收到的每条请求都放到独立的 goroutine 里运行。</li>
<li>并发和并行是两个相辅相成的概念，但它们并不相同。并发指的是两个或多个任务在同一时间段内启动、运行和结束，并且这些任务可能会彼此互动，而并行则是单纯地同时运行多个任务。</li>
<li>Go 通过 goroutine 和通道这两个重要的特性直接支持并发，但 Go 并不直接支特并行。</li>
<li>goroutine 用于编写并发程序，而通道则用于为不同的 goroutine 之间提供通信功能。</li>
<li>无缓冲通道都是同步的，尝试向一个已经包含数据的无缓冲通道推入新的数据将被阻塞；但是，有缓冲通道在被填满之前都是异步的。</li>
<li><strong>select 语句可以以先到先服务的方式，从多个通道里选出一个已经准备好执行接收操作的通道</strong></li>
<li>WaitGroup 同样可以用于对多个通道进行同步。</li>
<li>并发程序的性能一般都会比相应的非并发程序要高，而具体提升多少则取决于所使用的算法（即使在只使用一个 CPU 的情况下，也是如此）。</li>
<li>在条件允许的情况下，并发的 Web 应用将自动地获得并行带来的优势。</li>
</ul>
<h1>第十章：Go 的部署</h1>
<ul>
<li>部署 Go Web 服务最简单的方法就是直接将二进制可执行文件放置到服务器里面（这个服务器可以是虚拟机，也可以是实际存在的服务器），然后通过配置 Upstart 来保证服务可以随系统启动并持续地运行下去。</li>
<li>Docker 是一种最近开始崭露头角并且威力强大的 Web 服务和 Web 应用部署方式。用户首先需要将被部署的 Go Web服务 Docker 化为容器，然后才能在本地 Docker 宿主或者云端的远程 Docker 宿主上部署这个容器。</li>
</ul>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s 学习笔记</title>
    <url>/2021/07/21/backend_dev/kubernetes/</url>
    <content><![CDATA[<h1>CI / CD 基本原理</h1>
<p>CI/CD 是两个流水线，持续集成 Continuous Integration（CI）是<strong>服务构建流程</strong>，持续部署 Continuous Deployment（CD）是<strong>服务发布流程</strong>。也可以视作三个流水线，加上持续交付 Continuous Delivery（CD）给测试和质量团队的中间过程。</p>
<h2 id="持续集成（CI）">持续集成（CI）</h2>
<blockquote>
<p>持续将代码集成到主干。</p>
</blockquote>
<p>好处：</p>
<ul>
<li>快速发现错误，定位比较容易</li>
<li>防止分支大幅偏离主干</li>
</ul>
<p>持续集成强调开发人员提交了新代码之后，<strong>立刻进行构建、测试。根据测试结果来判断新代码是否和原有代码正确集成在一起。</strong></p>
<span id="more"></span>
<h2 id="持续交付（CD）">持续交付（CD）</h2>
<blockquote>
<p>Continuous Delivery<br>
频繁地将软件的新版本交付给质量团队或用户，以供评审。如果通过，代码就进入生产阶段。</p>
</blockquote>
<p>持续交付强调的是<strong>代码不管怎么更新，软件是随时可以交付的。</strong></p>
<p>自动部署到类生产环境完成更多的测试，如果代码没有问题，可以继续手动部署到生产环境中。</p>
<h2 id="持续部署（CD）">持续部署（CD）</h2>
<blockquote>
<p>Continuous Deployment<br>
和持续交付的区别在于自动化部署到生产环境。</p>
</blockquote>
<p>持续部署强调的是<strong>代码在任何时刻都是可部署的，可以进入生产阶段。</strong></p>
<p>持续部署的前提是能自动化完成测试、构建、部署等步骤。</p>
<h1>Jenkins</h1>
<blockquote>
<p>开源 CI&amp;CD 软件 <a href="http://jenkins-ci.org">官方网站</a></p>
</blockquote>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode_collection(停更)</title>
    <url>/2019/04/08/backend_dev/leetcode/</url>
    <content><![CDATA[<h1><a href="https://github.com/collie2nd/JustForGo/tree/main/OJ/LeetCode">最新入口</a></h1>
<h1>121. 买卖股票的最佳时机</h1>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p><strong>注意</strong>:你不能在买入股票前卖出股票。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: [7,1,5,3,6,4]<br>
<code>输出</code>: 5<br>
<code>解释</code>: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: [7,6,4,3,1]<br>
<code>输出</code>: 0<br>
<code>解释</code>: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	gaps := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(prices)<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(gaps); i++ &#123;</span><br><span class="line">		gaps[i] = prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">	&#125;</span><br><span class="line">	ans := <span class="number">0</span></span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(gaps); i++ &#123;</span><br><span class="line">		sum += gaps[i]</span><br><span class="line">		ans = getMax(ans, sum)</span><br><span class="line">		sum = getMax(sum, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMax</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>122. 买卖股票的最佳时机 II</h1>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: [7,1,5,3,6,4]<br>
<code>输出</code>: 7<br>
<code>解释</code>: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: [1,2,3,4,5]<br>
<code>输出</code>: 4<br>
<code>解释</code>: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>
注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>
因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
</blockquote>
<p><code>示例 3</code>:</p>
<blockquote>
<p><code>输入</code>: [7,6,4,3,1]<br>
<code>输出</code>: 0<br>
<code>解释</code>: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	ans := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(prices)<span class="number">-1</span>; i++ &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> prices[i+<span class="number">1</span>] &gt; prices[i] &#123;</span><br><span class="line">			ans += prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>123. 买卖股票的最佳时机 III</h1>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p><strong>注意</strong>: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: [3,3,5,0,0,3,1,4]<br>
<code>输出</code>: 6<br>
<code>解释</code>: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>
随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: [1,2,3,4,5]<br>
<code>输出</code>: 4<br>
<code>解释</code>: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>
注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>
因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
</blockquote>
<p><code>示例 3</code>:</p>
<blockquote>
<p><code>输入</code>: [7,6,4,3,1]<br>
<code>输出</code>: 0<br>
<code>解释</code>: 在这个情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> intMin = ^<span class="type">int</span>(^<span class="type">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	fstBuy, secBuy := intMin, intMin</span><br><span class="line">	fstSell, secSell := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, vousmevoyez := <span class="keyword">range</span> prices &#123;</span><br><span class="line">		fstBuy = getMax(fstBuy, -vousmevoyez)</span><br><span class="line">		fstSell = getMax(fstSell, fstBuy+vousmevoyez)</span><br><span class="line">		secBuy = getMax(secBuy, fstSell-vousmevoyez)</span><br><span class="line">		secSell = getMax(secSell, secBuy+vousmevoyez)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> secSell</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMax</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>188. 买卖股票的最佳时机 IV</h1>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p><strong>注意</strong>: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: [2,4,1], k = 2<br>
<code>输出</code>: 2<br>
<code>解释</code>: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: [3,2,6,5,0,3], k = 2<br>
<code>输出</code>: 7<br>
<code>解释</code>: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。<br>
随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">profits</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>] &#123;</span><br><span class="line">			res += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(k <span class="type">int</span>, prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> prices == <span class="literal">nil</span> || <span class="built_in">len</span>(prices) == <span class="number">0</span> || k &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(prices) &#123;</span><br><span class="line">		<span class="keyword">return</span> profits(prices)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ownDp := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	noDp := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> ownDp &#123;</span><br><span class="line">		ownDp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, k+<span class="number">1</span>)</span><br><span class="line">		noDp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, k+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> t := <span class="number">0</span>; t &lt;= k; t++ &#123;</span><br><span class="line">		noDp[<span class="number">0</span>][t] = <span class="number">0</span></span><br><span class="line">		ownDp[<span class="number">0</span>][t] = -prices[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	ownDp[<span class="number">0</span>][k] = <span class="number">-1</span>&lt;&lt;<span class="number">32</span> - <span class="number">1</span></span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">		x := i % <span class="number">2</span></span><br><span class="line">		y := (i - <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">		<span class="keyword">for</span> m := <span class="number">0</span>; m &lt;= k; m++ &#123;</span><br><span class="line">			<span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">				noDp[x][m] = max(<span class="number">-1</span>&lt;&lt;<span class="number">32</span><span class="number">-1</span>, noDp[y][m])</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				noDp[x][m] = max(noDp[y][m], ownDp[y][m<span class="number">-1</span>]+prices[i])</span><br><span class="line">			&#125;</span><br><span class="line">			ownDp[x][m] = max(ownDp[y][m], noDp[y][m]-prices[i])</span><br><span class="line">			tmp := max(noDp[x][m], ownDp[x][m])</span><br><span class="line">			res = max(res, tmp)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>322. 零钱兑换</h1>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: coins = [1, 2, 5], amount = 11<br>
<code>输出</code>: 3<br>
<code>解释</code>: 11 = 5 + 5 + 1</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: coins = [2], amount = 3<br>
<code>输出</code>: -1<br>
<code>说明</code>: 你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="type">int</span>, amount <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> vousmevoyez := <span class="number">1</span>; vousmevoyez &lt;= amount; vousmevoyez++ &#123;</span><br><span class="line">		dp[vousmevoyez] = <span class="number">0x3f3f3f3f</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">		<span class="keyword">for</span> vousmevoyez := coin; vousmevoyez &lt;= amount; vousmevoyez++ &#123;</span><br><span class="line">			<span class="keyword">if</span> dp[vousmevoyez] &gt; dp[vousmevoyez-coin] + <span class="number">1</span> &#123;</span><br><span class="line">				dp[vousmevoyez] = dp[vousmevoyez-coin] + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> dp[amount] == <span class="number">0x3f3f3f3f</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>518. 零钱兑换 II</h1>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p>
<p><code>示例 1</code>:</p>
<blockquote>
<p><code>输入</code>: amount = 5, coins = [1, 2, 5]<br>
<code>输出</code>: 4<br>
<code>解释</code>: 有四种方式可以凑成总金额:<br>
5=5<br>
5=2+2+1<br>
5=2+1+1+1<br>
5=1+1+1+1+1</p>
</blockquote>
<p><code>示例 2</code>:</p>
<blockquote>
<p><code>输入</code>: amount = 3, coins = [2]<br>
<code>输出</code>: 0<br>
<code>解释</code>: 只用面额2的硬币不能凑成总金额3。</p>
</blockquote>
<p><code>示例 3</code>:</p>
<blockquote>
<p><code>输入</code>: amount = 10, coins = [10]<br>
<code>输出</code>: 1</p>
</blockquote>
<p><strong>注意</strong>:</p>
<blockquote>
<p>你可以假设：<br>
0 &lt;= amount (总金额) &lt;= 5000<br>
1 &lt;= coin (硬币面额) &lt;= 5000<br>
硬币种类不超过 500 种<br>
结果符合 32 位符号整数</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="type">int</span>, coins []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> amount == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(coins) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(coins); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := coins[i]; j &lt;= amount; j++ &#123;</span><br><span class="line">            dp[j] += dp[j - coins[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>88. 合并两个有序数组</h1>
<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<p><strong>说明</strong>:<br>
初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
<p><code>示例</code>:</p>
<blockquote></blockquote>
<p><code>输入</code>:<br>
nums1 = [1,2,3,0,0,0], m = 3<br>
nums2 = [2,5,6],       n = 3<br>
<code>输出</code>: [1,2,2,3,5,6]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="type">int</span>, m <span class="type">int</span>, nums2 []<span class="type">int</span>, n <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">copy</span>(nums1, nums2)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(nums1[m:], nums2)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m+n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; m+n<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums1[j] &gt; nums1[j+<span class="number">1</span>] &#123;</span><br><span class="line">				nums1[j], nums1[j+<span class="number">1</span>] = nums1[j+<span class="number">1</span>], nums1[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>C/两数之和</h1>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p><strong>注意</strong>:/<br>
<code>示例</code>:</p>
<blockquote>
<p><code>输入</code>:nums = [2, 7, 11, 15]<br>
<code>输出</code>:target = 9<br>
<code>解释</code>:因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="type">int</span> *result;</span><br><span class="line"></span><br><span class="line">    result = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = target - nums[i];</span><br><span class="line">        <span class="keyword">for</span> (j = numsSize<span class="number">-1</span>; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == temp)</span><br><span class="line">            &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">free</span>(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_SOP</title>
    <url>/2020/10/01/backend_dev/linux_SOP/</url>
    <content><![CDATA[<h1>vim 常用快捷键</h1>
<p><img src="http://pic.colliexyy.com/vim_sop.jpg" alt="vim快捷键"></p>
<p>《Linux私房菜基础学习篇》Page278-280</p>
 <span id="more"></span>
<h1>常用系统命令</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将目前目录及其子目录下所有延伸档名是 c 的文件列出来。</span></span><br><span class="line">find . -name <span class="string">&quot;*.c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目前目录其其下子目录中所有一般文件列出</span></span><br><span class="line">find . -<span class="built_in">type</span> f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目前目录及其子目录下所有最近 20 天内更新过的文件列出</span></span><br><span class="line">find . -ctime -20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本替换</span></span><br><span class="line">sed <span class="string">&quot;s/success/&#123;\\\\\&quot;status\\\\\&quot;:0&#125;/g&quot;</span> -i /home/mdm/script/config/audi_pre.json</span><br></pre></td></tr></table></figure>
<h1>linux 系统命令</h1>
<h2 id="history">history</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 显示历史命令</span><br><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure>
<p>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  ls</span><br><span class="line">2  ls -a</span><br><span class="line">3  ls -al</span><br><span class="line">4  ls -als</span><br><span class="line">5  ls -h</span><br><span class="line">6  ls</span><br><span class="line">7  ls -alsh</span><br><span class="line">8  ls -als</span><br><span class="line">9  cls</span><br><span class="line">10  clear</span><br><span class="line">11  clear</span><br><span class="line">12  cls</span><br><span class="line">13  ls -help</span><br><span class="line">14  ls --help</span><br><span class="line">15  date</span><br><span class="line">16  date +%Y</span><br><span class="line">17  date +%y</span><br><span class="line">18  date +%M</span><br><span class="line">19  date +%m</span><br><span class="line">20  cal</span><br><span class="line">21  cal 2022</span><br><span class="line">22  cal 2022 02</span><br><span class="line">23  cal 3-22</span><br><span class="line">24  cal 03-22</span><br><span class="line">25  cal 03-2022</span><br><span class="line">26  cal 03 2022</span><br><span class="line">27  bc</span><br><span class="line">28  date</span><br><span class="line">29  history</span><br></pre></td></tr></table></figure>
<p>然后输入<code>!15</code>可以快速执行 history 中标记 15 的那行命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@47546a5b4ea9 /]<span class="comment"># !15</span></span><br><span class="line"><span class="built_in">date</span></span><br><span class="line">Wed Mar 23 02:14:32 UTC 2022</span><br></pre></td></tr></table></figure>
<h2 id="cal">cal</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@47546a5b4ea9 /]<span class="comment"># cal 03 2022</span></span><br><span class="line">     March 2022</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">       1  2  3  4  5</span><br><span class="line"> 6  7  8  9 10 11 12</span><br><span class="line">13 14 15 16 17 18 19</span><br><span class="line">20 21 22 23 24 25 26</span><br><span class="line">27 28 29 30 31</span><br></pre></td></tr></table></figure>
<h2 id="date">date</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[root@47546a5b4ea9 /]<span class="comment"># date +%Y</span></span><br><span class="line">2022</span><br><span class="line">[root@47546a5b4ea9 /]<span class="comment"># date +%y</span></span><br><span class="line">22</span><br><span class="line">[root@47546a5b4ea9 /]<span class="comment"># date +%M     //秒</span></span><br><span class="line">46</span><br><span class="line">[root@47546a5b4ea9 /]<span class="comment"># date +%m     //月</span></span><br><span class="line">03</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>常用快捷键</h1>
<ul>
<li>Ctrl + i：跳到本行开头</li>
<li>Ctrl + e：跳到本行结束</li>
<li>Ctrl + ←：往左跳一个单词</li>
<li>Ctrl + →：往右跳一个单词</li>
<li>Ctrl + U：从当前光标开始删除，删到本行开头</li>
<li>Ctrl + K：从当前光标开始删除，删到本行结束</li>
<li>ESC + . ：快速提取上条命令的输入参数（准确来说是命令的最后一部分值），可反复上翻调用</li>
<li>^AA^BB  ：把上条命令中的AA替换成BB之后重新执行一遍</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@47546a5b4ea9 /]<span class="comment"># ls -a</span></span><br><span class="line">.	    dev   lib64       opt   sbin  usr</span><br><span class="line">..	    etc   lost+found  proc  srv   var</span><br><span class="line">.dockerenv  home  media       root  sys</span><br><span class="line">bin	    lib   mnt	      run   tmp</span><br><span class="line">[root@47546a5b4ea9 /]<span class="comment"># ^-a^-l</span></span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">total 48</span><br><span class="line">lrwxrwxrwx   1 root root    7 Nov  3  2020 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x   5 root root  360 Mar 23 01:28 dev</span><br><span class="line">drwxr-xr-x   1 root root 4096 Mar 23 01:28 etc</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 home</span><br><span class="line">lrwxrwxrwx   1 root root    7 Nov  3  2020 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx   1 root root    9 Nov  3  2020 lib64 -&gt; usr/lib64</span><br><span class="line">drwx------   2 root root 4096 Sep 15  2021 lost+found</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 media</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 mnt</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 opt</span><br><span class="line">dr-xr-xr-x 170 root root    0 Mar 23 01:28 proc</span><br><span class="line">dr-xr-x---   2 root root 4096 Sep 15  2021 root</span><br><span class="line">drwxr-xr-x  11 root root 4096 Sep 15  2021 run</span><br><span class="line">lrwxrwxrwx   1 root root    8 Nov  3  2020 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 srv</span><br><span class="line">dr-xr-xr-x  13 root root    0 Mar 23 01:28 sys</span><br><span class="line">drwxrwxrwt   7 root root 4096 Sep 15  2021 tmp</span><br><span class="line">drwxr-xr-x  12 root root 4096 Sep 15  2021 usr</span><br><span class="line">drwxr-xr-x  20 root root 4096 Sep 15  2021 var</span><br></pre></td></tr></table></figure>
<ul>
<li>文本下冒号输入<code>/(string)</code>：查找文本中的对应字符串，小写 n 从上往下查找，大写 N 从下往上查找。string 也支持部分正则表达式。</li>
<li>file 命令可以查看 linux 文件种类（因为 linux 大部分文件都是没有后缀或者说扩展名的）。</li>
<li><code>cd -</code>：回到刚才那个目录</li>
<li><code>cd(后面什么都不跟)</code>：进入到当前用户的主文件夹。</li>
<li><code>cd ~account</code>：进入到 account 用户的主文件夹。</li>
<li><code>pwd -P</code>：显示正确的完整路径，针对 link 类型的文件有用。</li>
<li><code>mkdir -p</code>：可以创建多层目录。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir -p test/&#123;dir1,dir2,dir3&#125;</span></span><br><span class="line"><span class="comment"># tree test</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">├── dir1</span><br><span class="line">├── dir2</span><br><span class="line">└── dir3</span><br><span class="line"></span><br><span class="line">3 directories, 0 files</span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>cat -n</code>：查看文件时显示行号。cat 适合查看小文件。<code>cat -n</code>等用于命令<code>nl</code></li>
<li><code>tac</code>：与<code>cat</code>相反，从最后一行开始显示，一直显示到第一行。没有 -n 选项。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@47546a5b4ea9 /]<span class="comment"># cat /etc/hosts</span></span><br><span class="line">127.0.0.1	localhost</span><br><span class="line">::1	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0	ip6-localnet</span><br><span class="line">ff00::0	ip6-mcastprefix</span><br><span class="line">ff02::1	ip6-allnodes</span><br><span class="line">ff02::2	ip6-allrouters</span><br><span class="line">172.17.0.2	47546a5b4ea9</span><br><span class="line">[root@47546a5b4ea9 /]<span class="comment"># cat -n /etc/hosts</span></span><br><span class="line">     1	127.0.0.1	localhost</span><br><span class="line">     2	::1	localhost ip6-localhost ip6-loopback</span><br><span class="line">     3	fe00::0	ip6-localnet</span><br><span class="line">     4	ff00::0	ip6-mcastprefix</span><br><span class="line">     5	ff02::1	ip6-allnodes</span><br><span class="line">     6	ff02::2	ip6-allrouters</span><br><span class="line">     7	172.17.0.2	47546a5b4ea9</span><br><span class="line">[root@47546a5b4ea9 /]<span class="comment"># tac -n /etc/hosts</span></span><br><span class="line"><span class="built_in">tac</span>: invalid option -- <span class="string">&#x27;n&#x27;</span></span><br><span class="line">Try <span class="string">&#x27;tac --help&#x27;</span> <span class="keyword">for</span> more information.</span><br><span class="line">[root@47546a5b4ea9 /]<span class="comment"># tac /etc/hosts</span></span><br><span class="line">172.17.0.2	47546a5b4ea9</span><br><span class="line">ff02::2	ip6-allrouters</span><br><span class="line">ff02::1	ip6-allnodes</span><br><span class="line">ff00::0	ip6-mcastprefix</span><br><span class="line">fe00::0	ip6-localnet</span><br><span class="line">::1	localhost ip6-localhost ip6-loopback</span><br><span class="line">127.0.0.1	localhost</span><br></pre></td></tr></table></figure>
<ul>
<li>嵌套在语句中的命令如果要被执行，需要打标记，如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@47546a5b4ea9 /]<span class="comment"># hostname</span></span><br><span class="line">47546a5b4ea9</span><br><span class="line">[root@47546a5b4ea9 /]<span class="comment"># echo &quot;xxx `hostname` xxx&quot;</span></span><br><span class="line">xxx 47546a5b4ea9 xxx</span><br><span class="line">[root@47546a5b4ea9 /]<span class="comment"># echo &quot;xxx $(hostname) xxx&quot;</span></span><br><span class="line">xxx 47546a5b4ea9 xxx</span><br><span class="line">[root@47546a5b4ea9 /]<span class="comment"># echo &quot;xxx $&#123;hostname&#125; xxx&quot;</span></span><br><span class="line">xxx 47546a5b4ea9 xxx</span><br></pre></td></tr></table></figure>
<ul>
<li>查找文件的几种方式：
<ul>
<li><code>which</code>：只用来找命令，且只在 PATH 中找，只显示找出来的第一条，<code>-a</code>则列出所有同名执行文件。</li>
<li><code>where is</code>：<code>-b</code>只找二进制文件；<code>-m</code>只找说明文件；<code>-s</code>只找source源文件。</li>
<li><code>locate</code>：与上面一样，通过数据库查找数据，没有实际查找磁盘，所以很快，但导致需要更新数据库：<code>updatedb</code>，不然可能找到已经删除的文件，或找不到刚刚创建的新文件。查找支持关键字查找，输入部分名称也可检索出结果。</li>
<li><code>find [PATH] [option] [action]</code>：强大但慢，是查找磁盘，所以不是很常用。《鸟哥私房菜》Page 190 有详细用法介绍。</li>
</ul>
</li>
<li>查找文件时<code>-i</code>选项用来忽略大小写。</li>
<li><code>tar</code>：本身不压缩，只用来打包，打包功能来源于 bzip2 和 gzip 的功能支持。
<ul>
<li><code>-c</code>：新建打包文件；</li>
<li><code>-t</code>：查看打包文件的内容含有哪些文件名；</li>
<li><code>-x</code>：解打包/解压缩；</li>
<li><code>-j</code>：通过 bzip2 的支持，进行压缩/解压缩，此时文件名最好为<code>*.tar.bz2</code>；</li>
<li><code>-z</code>：通过 gzip 的支持，进行压缩/解压缩，此时文件名最好为<code>*.tar.gz</code>；</li>
<li><code>-v</code>：显示正在处理的文件名；</li>
<li><code>-f filename</code>：接的是被处理的文件名，建议<code>-f</code>单独写作一个参数；</li>
<li><code>-C</code>：用于解压缩时指定解压缩目录；</li>
</ul>
</li>
<li><code>dump [-Suvj] [-1evel] [-f 备份文件] 待备份数据</code>：对文件系统进行备份和存储。
<ul>
<li><code>-S</code>：仅列出后面的待备份数据需要多少磁盘空间才能够备份完毕；</li>
<li><code>-u</code>：将这次 dump 的时问记录到 /etc/ dumpdateS 文件中；</li>
<li><code>-v</code>：将 dump 的文件过程显示出来；</li>
<li><code>-j</code>：加入 bzip2 的支持，将数据进行压缩，默认 bzip2 压缩等级为 2；</li>
<li><code>-(level)</code>：-0 ~ -9 共10个等级；</li>
<li><code>-f</code>：有点类似 tar，后面接产生的文件，可接例如 /dev/st0 设备文件名等；</li>
<li><code>-W</code>：列出在 /etc/fstab 里面的具有 dump 设置的分区是否有备份过。</li>
</ul>
</li>
<li><code>restore</code>：恢复系统。Page 262</li>
<li><code>dd</code>：可备份完整的分区或磁盘，因为 dd 可读取磁盘的扇区表面数据。Page 262</li>
<li><code>curl</code></li>
</ul>
<h1>认识与学习 bash</h1>
<ul>
<li>使用变量过程中需要注意的问题：
<ul>
<li>单引号 VS 双引号</li>
<li>变量名前要带 $</li>
<li>最好带大括号，避免产生歧义：<code>$&#123;xxx&#125;</code></li>
<li><code>set</code>查看本地变量 <code>env</code>/<code>export</code>查看环境变量</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@9824e1123313 /]<span class="comment"># var=&#x27;$PATH&#x27;  // 单引号</span></span><br><span class="line">[root@9824e1123313 /]<span class="comment"># echo $var</span></span><br><span class="line"><span class="variable">$PATH</span></span><br><span class="line">[root@9824e1123313 /]<span class="comment"># var=&quot;$PATH&quot;  // 双引号</span></span><br><span class="line">[root@9824e1123313 /]<span class="comment"># echo var     // 不带 $</span></span><br><span class="line">var</span><br><span class="line">[root@9824e1123313 /]<span class="comment"># echo $var    // 带 $</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line"></span><br><span class="line">[root@9824e1123313 /]<span class="comment"># set 1 2 3 4 5 6 7 8 9 a b c</span></span><br><span class="line">[root@9824e1123313 /]<span class="comment"># echo $10     // 不带&#123;&#125;，分解为 $1 + 0</span></span><br><span class="line">10</span><br><span class="line">[root@9824e1123313 /]<span class="comment"># echo $&#123;10&#125;   // 带&#123;&#125;</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<ul>
<li><code>read</code>常用在 shell 中阻断，等待读取用户输入的参数，进行交互。<code>-p</code>：输入前的提示语句。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/<span class="comment"># read xx</span></span><br><span class="line">123</span><br><span class="line">/<span class="comment"># echo $xx     // echo 不加 -n 则会默认输出一个换行</span></span><br><span class="line">123</span><br><span class="line">/<span class="comment"># echo -n $xx</span></span><br><span class="line">123/<span class="comment"># read      // read 不加变量则赋值给默认环境变量 REPLY</span></span><br><span class="line">222</span><br><span class="line">/<span class="comment"># echo $REPLY</span></span><br><span class="line">222</span><br></pre></td></tr></table></figure>
<ul>
<li>bash 中的 array 类型。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/<span class="comment"># xx=(aa bb cc)</span></span><br><span class="line">/<span class="comment"># echo $&#123;xx[1]&#125;</span></span><br><span class="line">bb</span><br><span class="line">/<span class="comment"># echo $&#123;xx[*]&#125;</span></span><br><span class="line">aa bb cc</span><br><span class="line">/<span class="comment"># echo $&#123;xx[@]&#125;</span></span><br><span class="line">aa bb cc</span><br><span class="line">/<span class="comment"># echo $&#123;!xx[*]&#125;</span></span><br><span class="line">0 1 2</span><br></pre></td></tr></table></figure>
<ul>
<li>利用 $RANDOM 设置随机数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// $ RANDOM 介于0~32768之间，设置0~9的随机数，代码如下</span><br><span class="line">/<span class="comment"># declare -i number=$RANDOM*10/32768; echo $number</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<ul>
<li>查看命令的执行优先级：<code>type -a xxx</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/<span class="comment"># type -a rm</span></span><br><span class="line"><span class="built_in">rm</span> is an <span class="built_in">alias</span> <span class="keyword">for</span> trash</span><br><span class="line"><span class="built_in">rm</span> is /bin/rm</span><br></pre></td></tr></table></figure>
<h1>linux 复杂操作合集</h1>
<h2 id="访问本机接口-2">访问本机接口</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl --location --request POST <span class="string">&#x27;http://本机IP/接口&#x27;</span> --header <span class="string">&#x27;Content-Type: application/x-www-form-urlencoded&#x27;</span> --data-urlencode <span class="string">&#x27;data=[&#123;&quot;type&quot;:1,&quot;brand&quot;:&quot;GE&quot;,&quot;ae_oe_code&quot;:&quot;9261317&quot;&#125;]&#x27;</span></span><br><span class="line"></span><br><span class="line">curl --location --request GET <span class="string">&#x27;http://127.0.0.1:18016/honda/oe_by_std_name?vin=LVHRM1836D5019492&amp;std_name=%E6%B3%A2%E7%AE%B1%E6%B2%B9&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="查看-log-技巧-2">查看 log 技巧</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f &lt;file&gt; i//自动刷新查看文件，适用于查看日志，相对于<span class="built_in">cat</span>的优点在于不用全部打开，只会看最新的几行，看大文件时不会那么容易卡死</span><br><span class="line"></span><br><span class="line">//查看nginx日志，并进行过滤</span><br><span class="line"><span class="built_in">tail</span> -f /var/log/nginx/access.log | grep XXX </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 学习笔记</title>
    <url>/2020/07/20/backend_dev/mysql/</url>
    <content><![CDATA[<h1>MySQL 一些不熟的语句</h1>
<h2 id="DISTINCT">DISTINCT</h2>
<p>DISTINCT 关键词用于返回唯一不同的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name,column_name <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<h2 id="UPDATE">UPDATE</h2>
<p>UPDATE 语句用于更新表中已存在的记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> column1<span class="operator">=</span>value1,column2<span class="operator">=</span>value2,... <span class="keyword">WHERE</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure>
<p>注意 : UPDATE 语句中的 WHERE 子句！WHERE 子句规定哪条记录或者哪些记录需要更新。如果您省略了 WHERE 子句，所有的记录都将被更新！</p>
<h2 id="DELETE">DELETE</h2>
<p>DELETE 语句用于删除表中的行(记录)。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure>
<p>注意 : SQL DELETE 语句中的 WHERE 子句！WHERE 子句规定哪条记录或者哪些记录需要删除。如果您省略了 WHERE 子句，所有的记录都将被删除！</p>
<span id="more"></span>
<h2 id="REGEXP">REGEXP</h2>
<p>示例：正则表达式 <code>B[an]*s</code> 匹配下述字符串中的任何一个：<code>Bananas，Baaaaas，Bs</code>，以及以 B 开始，以 s 结束、并在其中包含任意数目 a 或 n 字符的任何其他字符串。</p>
<p>以下是可用于随 REGEXP 操作符的表的模式。</p>
<p><img src="http://pic.colliexyy.com/16566670388532.jpg" alt=""></p>
<p>应用示例，查找用户表中 Email 格式错误的用户记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="keyword">NOT</span> REGEXP <span class="string">&#x27;^[A-Z0-9._%-]+@[A-Z0-9.-]+.[A-Z]&#123;2,4&#125;$&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>^ </code>匹配字符串的开始位置，如 <code>^a</code> 表示以字母 a 开头的字符串。</li>
<li><code>$</code>匹配字符串的结束位置，如 <code>X$</code> 表示以字母 X 结尾的字符串。</li>
<li><code>. </code>这个字符就是英文下的点，它匹配任何一个字符，包括回车、换行等。</li>
<li><code>*</code>星号匹配 0 个或多个字符，在它之前必须有内容。如：<code>mysql&gt; SELECT 'xxxyyy' REGEXP 'x*';</code></li>
<li><code>+</code>加号匹配 1 个或多个字符，在它之前也必须有内容。加号跟星号的用法类似，只是星号允许出现 0 次，加号则必须至少出现一次。</li>
<li><code>?</code>问号匹配0 次或 1 次。</li>
</ul>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询找到所有的名字以 st 开头：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> person_tbl <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;^st&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询找到所有的名字以 ok 结尾：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> person_tbl <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;ok$&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询找到所有的名字包含 mar 的字符串：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> person_tbl <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;mar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询找到所有名称以元音开始和 ok 结束的：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> person_tbl <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;^[aeiou]|ok$&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>&#123;m,n&#125;</code>这是一个更全面的方法，它可以实现前面好几种保留字的功能。</p>
<ul>
<li><code>a*</code> 可以写成 <code>a&#123;0,&#125;</code>。</li>
<li><code>a+</code> 可以写成 <code>a&#123;1,&#125;</code>。</li>
<li><code>a?</code> 可以写成 <code>a&#123;0,1&#125;</code>。</li>
</ul>
</li>
<li>
<p><code>&#123;i&#125;</code>表示字符只能出现 i 次；</p>
</li>
<li>
<p><code>&#123;i,&#125;</code>表示字符可以出现 i 次或 i 次以上；</p>
</li>
<li>
<p><code>&#123;i,j&#125;</code>表示字符只能出现 i 次以上，j 次以下，包括 i 次和 j 次。其中的整型参数必须大于等于 0，小于等于 RE_DUP_MAX（默认是 255）。 如果有两个参数，第二个必须大于等于第一个。</p>
</li>
<li>
<p><code>[a-dX]</code>匹配 <code>“a”、“b”、“c”、“d”</code> 或 <code>“X”</code>。</p>
</li>
<li>
<p><code>[^a-dX]</code>匹配除 <code>“a”、“b”、“c”、“d”、“X”</code> 以外的任何字符。</p>
</li>
<li>
<p><code>[</code>、<code>]</code>必须成对使用：</p>
</li>
</ul>
<h2 id="IN-操作符">IN 操作符</h2>
<p>IN 操作符允许您在 WHERE 子句中规定多个值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1,value2,...);</span><br></pre></td></tr></table></figure>
<h2 id="BETWEEN-操作符">BETWEEN 操作符</h2>
<p>BETWEEN 操作符选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="keyword">BETWEEN</span> value1 <span class="keyword">AND</span> value2;</span><br></pre></td></tr></table></figure>
<h2 id="AS-操作符">AS 操作符</h2>
<p>通过使用 AS 操作符，可以为表名称或列名称指定别名。创建别名是为了让列名称的可读性更强。AS 在给表取别名时可省略。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 列的 <span class="keyword">SQL</span> 别名语法</span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name <span class="keyword">FROM</span> table_name;</span><br><span class="line"></span><br><span class="line"># 表的 <span class="keyword">SQL</span> 别名语法</span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name <span class="keyword">AS</span> alias_name;</span><br></pre></td></tr></table></figure>
<h2 id="JOIN">JOIN</h2>
<p>JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。</p>
<ul>
<li><code>INNER JOIN</code>：如果表中有至少一个匹配，则返回行</li>
<li><code>LEFT JOIN</code>：即使右表中没有匹配，也从左表返回所有的行</li>
<li><code>RIGHT JOIN</code>：即使左表中没有匹配，也从右表返回所有的行</li>
<li><code>FULL JOIN</code>：只要其中一个表中存在匹配，则返回行</li>
</ul>
<p><img src="http://pic.colliexyy.com/16566670388548.jpg" alt=""></p>
<h3 id="INNER-JOIN">INNER JOIN</h3>
<p>INNER JOIN 要求两表中都要匹配才返回行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">INNER</span> 可省</span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name<span class="operator">=</span>table2.column_name;</span><br></pre></td></tr></table></figure>
<p><img src="http://pic.colliexyy.com/16566670388568.jpg" alt=""></p>
<h3 id="LEFT-JOIN">LEFT JOIN</h3>
<p>LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name<span class="operator">=</span>table2.column_name;</span><br></pre></td></tr></table></figure>
<p>注意：在某些数据库中，LEFT JOIN 称为 LEFT OUTER JOIN。</p>
<p><img src="http://pic.colliexyy.com/16566670388582.jpg" alt=""></p>
<h3 id="RIGHT-JOIN">RIGHT JOIN</h3>
<p>RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name<span class="operator">=</span>table2.column_name;</span><br></pre></td></tr></table></figure>
<p>注意：在某些数据库中，RIGHT JOIN 称为 RIGHT OUTER JOIN。</p>
<p><img src="http://pic.colliexyy.com/16566670388597.jpg" alt=""></p>
<h3 id="FULL-OUTER-JOIN">FULL OUTER JOIN</h3>
<p>FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行。</p>
<p>FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1 <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name<span class="operator">=</span>table2.column_name;</span><br></pre></td></tr></table></figure>
<p>注意：MySQL中不支持 FULL OUTER JOIN</p>
<p><img src="http://pic.colliexyy.com/16566670388611.jpg" alt=""></p>
<h2 id="UNION-操作符">UNION 操作符</h2>
<p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>
<p>请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。但是名称不用对应相同，结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>
<p>注意：UNION 操作符会默认去重。如果允许重复的值，请使用 UNION ALL。</p>
<h2 id="INSERT-INTO-SELECT">INSERT INTO SELECT</h2>
<p>INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>  (准备好的表) <span class="keyword">SELECT</span> <span class="operator">*</span>（或者取用自己想要的结构）<span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 各种条件</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>我们可以从一个表中复制所有的列插入到另一个已存在的表中：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table2 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>或者我们可以只复制希望的列插入到另一个已存在的表中：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table2 (column_name(s)) <span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table1;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 复制表结构及其数据</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name_new <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name_old</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 只复制表结构</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name_new <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name_old <span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 或者</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name_new <span class="keyword">LIKE</span> table_name_old</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 只复制表数据，如果两个表结构一样：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name_new <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name_old</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 只复制表数据，如果两个表结构不一样：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name_new(column1,column2...) <span class="keyword">SELECT</span> column1,column2... <span class="keyword">FROM</span> table_name_old</span><br></pre></td></tr></table></figure>
<h2 id="SELECT-INTO-FROM">SELECT INTO FROM</h2>
<p><code>SELECT INTO FROM</code>将查询出来的数据整理到一张新表中保存，表结构与查询结构一致。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>（查询出来的结果） <span class="keyword">INTO</span> newtable（新的表名）<span class="keyword">FROM</span> <span class="keyword">WHERE</span> （后续条件）</span><br></pre></td></tr></table></figure>
<h2 id="SQL-约束（Constraints）-2">SQL 约束（Constraints）</h2>
<p>SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定（CREATE TABLE），或者在表创建之后规定（ALTER TABLE）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">column_name1 data_type(size) constraint_name,</span><br><span class="line">column_name2 data_type(size) constraint_name,</span><br><span class="line">column_name3 data_type(size) constraint_name,</span><br><span class="line">....</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在 SQL 中，我们有如下约束：</p>
<ul>
<li><code>NOT NULL</code>指示某列不能存储 NULL 值。</li>
<li><code>UNIQUE</code>保证某列元素值必须唯一。</li>
<li><code>PRIMARY KEY</code>主键标识(<code>NOT NULL</code> 和 <code>UNIQUE</code> 的结合)。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>
<li><code>FOREIGN KEY</code>保证一个表中的数据匹配另一个表中的值的参照完整性。</li>
<li><code>CHECK</code>保证列中的值符合指定的条件。</li>
<li><code>DEFAULT</code>规定没有给列赋值时的默认值。</li>
</ul>
<h2 id="ALTER-TABLE">ALTER TABLE</h2>
<p>ALTER TABLE 语句用于在已有的表中添加、删除或修改列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 添加列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> column_name datatype</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 删除列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 改变表中列的数据类型</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name MODIFY <span class="keyword">COLUMN</span> column_name datatype</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改表列属性</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 原列名 新列名  类型； <span class="comment">--修改表的列属性名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 列名 类型 ；  <span class="comment">--修改表的类类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 列名；  <span class="comment">--删除表的某一列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span>  列名 类型；<span class="comment">--添加某一列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME 新表名； <span class="comment">--修改表名</span></span><br></pre></td></tr></table></figure>
<h2 id="AUTO-INCREMENT">AUTO INCREMENT</h2>
<p>AUTO-INCREMENT 会在新记录插入表中时生成一个唯一的数字。比如自动地创建主键字段的值。</p>
<h2 id="VIEW">VIEW</h2>
<p>视图是基于 SQL 语句的结果集的可视化的表。视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。</p>
<p>您可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 创建视图</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> <span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 删除视图</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name;</span><br></pre></td></tr></table></figure>
<p>注意：视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。</p>
<h1>mysql 复杂操作合集</h1>
<h2 id="重置自增ID">重置自增ID</h2>
<blockquote>
<p>也就是说如何重排 auto_increment</p>
</blockquote>
<p>两种方法：</p>
<ol>
<li>清空表时使用<code>truncate</code>命令，而不用<code>delete</code>命令</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name ;</span><br></pre></td></tr></table></figure>
<p>使用<code>truncate</code>命令的好处：</p>
<blockquote>
<p>1）、速度快<br>
2）、可以对自增 ID 进行重排，使自增 ID 仍从1开始计算</p>
</blockquote>
<ol start="2">
<li>清空表数据后，使用 alter 修改表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="时间戳设置">时间戳设置</h2>
<ul>
<li><code>DEFAULT CURRENT_TIMESTAMP</code>：表示当插入数据的时候，该字段默认值为当前时间</li>
<li><code>ON UPDATE CURRENT_TIMESTAMP</code>：在数据库数据有更新的时，UPDATE_TIME 的时间会自动更新。</li>
</ul>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 架构（面试用）</title>
    <url>/2021/10/30/backend_dev/mysql_qa/</url>
    <content><![CDATA[<h1>MySQL的基本架构</h1>
<p>Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</p>
<p>存储引擎层： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</p>
<h1>查询语句执行过程解析</h1>
<p>1、客户端发起一个请求时，首先会建立一个连接<br>
2、服务端会检查缓存，如果命中则直接返回，否则继续之后后面步骤<br>
3、服务器端根据收到的sql语句进行解析，然后对其进行词法分析，语法分析以及预处理<br>
4、由优化器生成执行计划<br>
5、调用存储引擎层API来执行查询<br>
6、返回查询到的结果</p>
<p><img src="http://pic.colliexyy.com/mysql_qa.jpg" alt=""></p>
<span id="more"></span>
<h1>更新语句执行过程解析</h1>
<p>1、先根据更新语句的条件，查询出对应的记录，如果有缓存，也会用到缓存<br>
2、Server端调用InnoDB引擎API接口，InnoDB引擎将这条数据写到内存，同时写入redo log，并将redo log状态设置为prepare<br>
3、通知Server层，可以正式提交数据了<br>
4、Server层收到通知后立刻写入bin log，然后调用InnoD对应接口发出commit请求<br>
5、InnoDB收到commit请求后将数据设置为commit状态</p>
<h1>bin log</h1>
<p>MySQL整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面讲的redo log是InnoDB 引擎特有的日志，而Server 层也有自己的日志，称为 bin log（归档日志），也叫做二进制日志。</p>
<h1>redo log</h1>
<p>redo log，即重做日志，是InnoDB引擎所特有,主要用于崩溃修复(crash-safe)。</p>
<h1>bin log 和 redo log 的区别</h1>
<p>1、redo log 是 InnoDB 引擎特有的；bin log 是 MySQL 的Server层实现的，所有引擎都可以使用。<br>
2、redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；bin log 是逻辑日志，记录的是这个语句的原始逻辑，比如“给id=2 这一行的c字段加 1 ”。<br>
3、redo log 是循环写的，空间固定会用完；bin log 是可以追加写入的。“追加写”是指 bin log 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识体系（面试用）</title>
    <url>/2021/11/10/backend_dev/network_qa/</url>
    <content><![CDATA[<h1>计算机网络应用层协议有哪些?</h1>
<p>应用层协议：</p>
<p>1、远程登录协议（Telnet)<br>
2、文件传输协议（FTP）<br>
3、超文本传输协议（HTTP）<br>
4、域名服务协议（DNS）<br>
5、简单邮件传输协议（SMTP）<br>
6、邮局协议（POP3）</p>
<p>其中，从网络上下载文件时使用的是FTP协议，上网游览网页时使用的是HTTP协议；在网络上访问一台主机时，通常不直接输入IP地址，而是输入域名，用的是DNS服务协议，它会将域名解析为IP地址；通过FoxMail发送电子邮件时，使用SMTP协议，接收电子邮件时就使用POP3协议。</p>
<p>传输层协议：</p>
<p>1、传输控制协议 TCP<br>
2、用户数据报协议 UDP</p>
<p>TCP协议：面向连接的可靠传输协议。利用TCP进行通信时，首先要通过三步握手，以建立通信双方的连接。TCP提供了数据的确认和数据重传的机制，保证发送的数据一定能到达通信的对方。</p>
<p>UDP协议：是无连接的，不可靠的传输协议。采用UDP进行通信时不用建立连接，可以直接向一个IP地址发送数据，但是不能保证对方是否能收到。</p>
<p>网络层协议：</p>
<p>1、网际协议 IP<br>
2、Internet互联网控制报文协议 ICMP<br>
3、Internet组织管理协议 IGMP<br>
4、地址解析协议 ARP</p>
<span id="more"></span>
<h1>HTTP\HTTPS</h1>
<h2 id="http通讯存在的问题">http通讯存在的问题</h2>
<p>容易被监听</p>
<p>http通讯都是明文，数据在客户端与服务器通讯过程当中，任何一点均可能被劫持。好比，发送了银行卡号和密码，hacker劫取到数据，就能看到卡号和密码，这是很危险的</p>
<p>被假装</p>
<p>http通讯时，没法保证通行双方是合法的，通讯方多是假装的。<a href="http://xn--www-x69di67b4y0abway18q.taobao.com">好比你请求www.taobao.com</a>,你怎么知道返回的数据就是来自淘宝，中间人可能返回数据假装成淘宝。</p>
<p>被篡改</p>
<p>hacker中间篡改数据后，接收方并不知道数据已经被更改</p>
<h2 id="https解决的问题">https解决的问题</h2>
<p>https很好的解决了http的三个缺点（被监听、被篡改、被假装），https不是一种新的协议，它是http+SSL(TLS)的结合体，SSL是一种独立协议，因此其它协议好比smtp等也能够跟ssl结合。https改变了通讯方式，它由之前的http—–&gt;tcp，改成http——&gt;SSL—–&gt;tcp；https采用了共享密钥加密+公开密钥加密的方式</p>
<p>防监听</p>
<p>数据是加密的，因此监听获得的数据是密文，hacker看不懂。</p>
<p>防假装</p>
<p>假装分为客户端假装和服务器假装，通讯双方携带证书，证书至关于身份证，有证书就认为合法，没有证书就认为非法，证书由第三方颁布，很难伪造</p>
<p>防篡改</p>
<p>https对数据作了摘要，篡改数据会被感知到。hacker即便从中改了数据也白搭。</p>
<h2 id="https链接过程">https链接过程</h2>
<ol>
<li>客户端发起HTTPS请求</li>
</ol>
<p>这个没什么好说的，就是用户在浏览器里输入一个https网址，而后链接到server的443端口。</p>
<ol start="2">
<li>服务端的配置</li>
</ol>
<p>采用HTTPS协议的服务器必需要有一套数字证书，能够本身制做，也能够向组织申请。区别就是本身颁发的证书须要客户端验证经过，才能够继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。若是对公钥和私钥不太理解，能够想象成一把钥匙和一个锁头，只是全世界只有你一我的有这把钥匙，你能够把锁头给别人，别人能够用这个锁把重要的东西锁起来，而后发给你，由于只有你一我的有这把钥匙，因此只有你才能看到被这把锁锁起来的东西。</p>
<ol start="3">
<li>传送证书</li>
</ol>
<p>这个证书其实就是公钥，只是包含了不少信息，如证书的颁发机构，过时时间等等。</p>
<ol start="4">
<li>客户端解析证书</li>
</ol>
<p>这部分工做是有客户端的TLS来完成的，首先会验证公钥是否有效，好比颁发机构，过时时间等等，若是发现异常，则会弹出一个警告框，提示证书存在问题。若是证书没有问题，那么就生成一个随机值。而后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，否则看不到被锁住的内容。</p>
<ol start="5">
<li>传送加密信息</li>
</ol>
<p>这部分传送的是用证书加密后的随机值，目的就是让服务端获得这个随机值，之后客户端和服务端的通讯就能够经过这个随机值来进行加密解密了。</p>
<ol start="6">
<li>服务段解密信息</li>
</ol>
<p>服务端用私钥解密后，获得了客户端传过来的随机值(私钥)，而后把内容经过该值进行对称加密。所谓对称加密就是，将信息和私钥经过某种算法混合在一块儿，这样除非知道私钥，否则没法获取内容，而正好客户端和服务端都知道这个私钥，因此只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>
<ol start="7">
<li>传输加密后的信息</li>
</ol>
<p>这部分信息是服务段用私钥加密后的信息，能够在客户端被还原。</p>
<ol start="8">
<li>客户端解密信息</li>
</ol>
<p>客户端用以前生成的私钥解密服务段传过来的信息，因而获取了解密后的内容。整个过程第三方即便监听到了数据，也一筹莫展。</p>
<h2 id="CA证书原理">CA证书原理</h2>
<p>1.客户端向服务端发送自己支持的加密算法</p>
<p>2.服务端向客户端返回包含其RSA公钥的数字证书</p>
<p>3.客户端使用网上公布的CA公钥检验数字证书（目的：证明消息来自服务器而非黑客）</p>
<p>4.然后随机生成随机数（使用公钥加密），发送给服务器</p>
<p>数字证书我的理解就是相当于一个签名。</p>
<p>用CA的私钥对数字证书生成签名，然后用公钥验证数字证书是否被篡改过，如果没被篡改说明证书上的服务器和公钥是对应的。</p>
<h2 id="http协议的methods有哪些">http协议的methods有哪些</h2>
<p>想让服务器知道我们请求的意图，那就须清楚HTTP中常用 methods(请求方法)，先来列一列有哪些methods:</p>
<p>GET: 获取资源<br>
HEAD: 获取报文头部<br>
POST: 传输实体主体<br>
PUT: 传输文件<br>
DELETE: 删除文件<br>
OPTIONS: 询问支持方法</p>
<blockquote>
<p>GET : 获取资源</p>
</blockquote>
<p>用来请求已被URI识别的资源。GET方法用作请求数据，但不会对数据产生任何影响</p>
<blockquote>
<p>HEAD: 获取报文头部</p>
</blockquote>
<p>跟GET方法一样，但是HEAD方法不返回报文的主体，只是返回一些相关信息，比如确认URI的有效性、资源更新的日期等信息</p>
<blockquote>
<p>POST 传输实体主体</p>
</blockquote>
<p>用来给服务器发送数据，比如要表单提交的数据，文件更新的数据等。所以，我们更好理解POST方法的主要目的——传输实体主体</p>
<blockquote>
<p>PUT: 传输文件</p>
</blockquote>
<p>用来传输文件，请求报文主体中包含文件内容，然后保存到请求URI指定了资源的存放位置<br>
由于任何人都可以上传文件，所以PUT存在安全性问题，一般Web网站不使用它。但如果配合Web应用程序的验证机制，或架构设计采用Rest标准的同类Web网站，就能开放使用PUT方法</p>
<blockquote>
<p>DELETE: 删除文件</p>
</blockquote>
<p>用来删除文件，即删除按请求URI下的指定资源<br>
和PUT方法一样，存在安全性问题，所以一般Web网站不使用 DELETE方法。但如果配合Web应用程序的验证机制，或架构设计采用Rest标准的同类Web网站，就能开放使用PUT方法</p>
<blockquote>
<p>OPTIONS: 询问支持方法</p>
</blockquote>
<p>用于获取请求URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值便是所支持的方法，如“GET、POST”。</p>
<h2 id="讲一下get和post的区别">讲一下get和post的区别</h2>
<ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。</li>
</ul>
<p>附加：</p>
<ul>
<li>GET产生一个TCP数据包；POST产生两个TCP数据包。</li>
</ul>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
<p>但不推荐用GET替换掉POST来优化网页性能。</p>
<p>原因：</p>
<ol>
<li>GET与POST都有自己的语义，不能随便混用。</li>
<li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li>
<li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li>
</ol>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 学习笔记</title>
    <url>/2020/07/20/backend_dev/nginx/</url>
    <content><![CDATA[<h1>nginx</h1>
<h2 id="nginx-配置">nginx 配置</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/nginx/nginx.conf</span><br><span class="line"><span class="built_in">cat</span> /etc/nginx/conf.d/xxxxxxxx.conf</span><br></pre></td></tr></table></figure>
<p>示例：路由 stdname 设置 <strong>nginx 监听 18026</strong> 收到请求后<strong>转发</strong>至 stdnameSvr 的 <strong>监听端口 19026</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       18026;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location /stdname/  &#123;</span><br><span class="line">                fastcgi_pass   127.0.0.1:19026;</span><br><span class="line">                fastcgi_index  index.cgi;</span><br><span class="line">                include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="nginx-常用命令">nginx 常用命令</h2>
<ul>
<li><code>-t</code>：加上<code>-t</code>可以测试 nginx 配置是否正确</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 验证 nginx 配置文件是否正确</span></span><br><span class="line">nginx -t</span><br><span class="line"></span><br><span class="line">nginx: the configuration file /.../nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /.../nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明配置文件正确</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>-c</code>：指定 nginx 运行时使用的 conf 文件路径</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nginx -c /path_of_nginx.conf/nginx.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>停止 nginx</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx         //查看进程号</span><br><span class="line"><span class="built_in">kill</span> -QUIT &lt;pid_of_nginx&gt;   //从容停止</span><br><span class="line"><span class="built_in">kill</span> -TERM &lt;pid_of_nginx&gt;   //快速停止</span><br><span class="line"><span class="built_in">kill</span> -INT &lt;pid_of_nginx&gt;    //快速停止</span><br><span class="line"><span class="built_in">kill</span> -9 nginx               //强制停止</span><br></pre></td></tr></table></figure>
<p>或者（如果已经注册到了系统服务里）可以用系统服务命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl stop nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>重启 nginx</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<p>或者（如果已经注册到了系统服务里）可以用系统服务命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>
<p>或者用 kill 命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP &lt;pid_of_nginx&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>python 学习笔记</title>
    <url>/2021/07/10/backend_dev/python/</url>
    <content><![CDATA[<h1>python 复制操作合集</h1>
<h2 id="通过跳转机连接-mysql">通过跳转机连接 mysql</h2>
<blockquote>
<p>场景：本地-&gt;跳转机-&gt;mysql服务器<br>
分两步：1.通过 sshtunnel 登陆跳转机；2.创建数据库连接。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> sshtunnel <span class="keyword">import</span> SSHTunnelForwarder</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> SSHTunnelForwarder(</span><br><span class="line">        (<span class="string">&#x27;*.*.*.*&#x27;</span>, <span class="number">11690</span>),  <span class="comment"># 指定ssh登录的跳转机的address，端口号</span></span><br><span class="line">        ssh_username=<span class="string">&quot;***&quot;</span>,  <span class="comment"># 跳转机的用户</span></span><br><span class="line">        ssh_pkey=<span class="string">&quot;/Users/.ssh/id_rsa&quot;</span>, <span class="comment">#私钥路径</span></span><br><span class="line">        ssh_private_key_password=<span class="string">&quot;***&quot;</span>, <span class="comment">#密码（电脑开机密码）</span></span><br><span class="line">        remote_bind_address=(<span class="string">&#x27;*.*.*.*&#x27;</span>, <span class="number">3306</span>)) <span class="keyword">as</span> server:  <span class="comment"># mysql服务器的address，端口号</span></span><br><span class="line">    conn = pymysql.connect(host=<span class="string">&#x27;127.0.0.1&#x27;</span>,  <span class="comment"># 此处必须是是127.0.0.1</span></span><br><span class="line">                           port=server.local_bind_port,</span><br><span class="line">                           user=<span class="string">&#x27;**&#x27;</span>, <span class="comment">#数据库用户名</span></span><br><span class="line">                           passwd=<span class="string">&#x27;**&#x27;</span>, <span class="comment">#数据库密码</span></span><br><span class="line">                           db=<span class="string">&#x27;**&#x27;</span> <span class="comment">#数据库名称)</span></span><br><span class="line"> </span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    <span class="comment"># 使用 execute()  方法执行 SQL 查询</span></span><br><span class="line">    cursor.execute(<span class="string">&quot;SELECT VERSION()；&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 使用 fetchone() 方法获取单条数据.</span></span><br><span class="line">    data = cursor.fetchone()</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Database version : %s &quot;</span> % data)</span><br><span class="line">    <span class="comment"># 关闭数据库连接</span></span><br><span class="line">    cursor.close()</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="读取-Excel-文档">读取 Excel 文档</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_excel</span>(<span class="params">self, path</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">&quot;begin read %s&quot;</span> % path)</span><br><span class="line">        <span class="comment"># 读取 Excel 预处理动作↓，使用 xlrd 包将 Excel 文件读入 book 中</span></span><br><span class="line">        book = xlrd.open_workbook(path,encoding_override=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        data = <span class="built_in">dict</span>()</span><br><span class="line">        sheets = book.sheets()</span><br><span class="line">        <span class="keyword">for</span> cur <span class="keyword">in</span> sheets:</span><br><span class="line">            sheet_name = cur.name</span><br><span class="line">            nrows = cur.nrows</span><br><span class="line">            ncols = cur.ncols</span><br><span class="line">            logger.info(<span class="string">&quot;nrows=%d,ncols=%d&quot;</span> % (nrows, ncols))</span><br><span class="line">            sheet_val = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, nrows):</span><br><span class="line">                line = cur.row_values(idx)</span><br><span class="line">                <span class="comment"># sheet_val 为对应该页面每行数据的 list 数据</span></span><br><span class="line">                sheet_val.append(line)</span><br><span class="line">            <span class="comment"># data 为整个 Excel 文件每一张 sheet 的 Map 数据</span></span><br><span class="line">            data[sheet_name] = sheet_val</span><br><span class="line">        logger.info(<span class="string">&quot;read end, sheet=%d&quot;</span> % <span class="built_in">len</span>(data))</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.info(<span class="string">&quot;read %s fail, err=%s&quot;</span> % (path, <span class="built_in">str</span>(e)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h2 id="Excel-数据处理">Excel 数据处理</h2>
<p><strong>Excel 转换成 SQL 语句</strong></p>
<p>单独拉出一列，在首行传入该函数后，复制到每一行，可拉取对应列的数据，并转换为 sql 语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=CONCATENATE(&quot;INSERT INTO table_name (list_1,list_2,list_3) VALUES (&#x27;&quot;,A1,&quot;&#x27;,&#x27;&quot;,B1,&quot;&#x27;,&#x27;&quot;,C1,&quot;&#x27;);&quot;)</span><br></pre></td></tr></table></figure>
<p><strong>Python 批量处理 Excel</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">连接数据库</span></span><br><span class="line"><span class="string">args：db_name（数据库名称）</span></span><br><span class="line"><span class="string">returns:db</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mysql_link</span>(<span class="params">db_name</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        db = pymysql.connect(host=<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>,</span><br><span class="line">                             port=xxxx,</span><br><span class="line">                             user=<span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">                             passwd=<span class="string">&quot;xxxxxx&quot;</span>,</span><br><span class="line">                             db=db_name,</span><br><span class="line">                             charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;could not connect to mysql server&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">读取excel函数</span></span><br><span class="line"><span class="string">args：excel_file（excel文件，目录在py文件同目录）</span></span><br><span class="line"><span class="string">returns：book</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">open_excel</span>(<span class="params">excel_file</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        book = xlrd.open_workbook(excel_file)  <span class="comment"># 文件名，把文件与py文件放在同一目录下</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;open excel file failed!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> book</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">执行插入操作</span></span><br><span class="line"><span class="string">args:db_name（数据库名称）</span></span><br><span class="line"><span class="string">table_name(表名称）</span></span><br><span class="line"><span class="string">excel_file（excel文件名，把文件与py文件放在同一目录下）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store_to</span>(<span class="params">db_name: <span class="built_in">object</span>, table_name: <span class="built_in">object</span>, excel_file: <span class="built_in">object</span></span>) -&gt; <span class="built_in">object</span>:</span><br><span class="line">    db = mysql_link(db_name)  <span class="comment"># 打开数据库连接</span></span><br><span class="line">    cursor = db.cursor()  <span class="comment"># 使用 cursor() 方法创建一个游标对象 cursor</span></span><br><span class="line">    book = open_excel(excel_file)  <span class="comment"># 打开excel文件</span></span><br><span class="line">    sheets = book.sheet_names()  <span class="comment"># 获取所有sheet表名</span></span><br><span class="line">    <span class="keyword">for</span> sheet <span class="keyword">in</span> sheets:</span><br><span class="line">        sh = book.sheet_by_name(sheet)  <span class="comment"># 打开每一张表</span></span><br><span class="line">        row_num = sh.nrows</span><br><span class="line">        <span class="keyword">if</span> row_num != <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(row_num - <span class="number">1</span>)</span><br><span class="line">        data_list = []  <span class="comment"># 定义列表用来存放数据</span></span><br><span class="line">        num = <span class="number">0</span>  <span class="comment"># 用来控制每次插入的数量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, row_num):  <span class="comment"># 第一行是标题名，对应表中的字段名所以应该从第二行开始，计算机以0开始计数，所以值是1</span></span><br><span class="line">            row_data = sh.row_values(i)  <span class="comment"># 按行获取excel的值</span></span><br><span class="line">            value = (</span><br><span class="line">                row_data[<span class="number">0</span>], row_data[<span class="number">1</span>], row_data[<span class="number">2</span>], row_data[<span class="number">3</span>], row_data[<span class="number">4</span>], row_data[<span class="number">5</span>], row_data[<span class="number">6</span>], row_data[<span class="number">7</span>],</span><br><span class="line">                row_data[<span class="number">8</span>])</span><br><span class="line">            sql = <span class="string">&quot;INSERT INTO &quot;</span> + <span class="built_in">str</span>(table_name) + <span class="string">&quot;(brand,sub_model_name,v8_10,`year`,trans_code,oe_code,std_name,&quot;</span> \</span><br><span class="line">                                                     <span class="string">&quot;`level`,specification,creator,updator) VALUES(%s,%s,%s,%s,%s,&quot;</span> \</span><br><span class="line">                                                     <span class="string">&quot;%s,%s,%s,%s,\&quot;xing.liuxing1218\&quot;,\&quot;xing.liuxing1218\&quot;) &quot;</span></span><br><span class="line">            data_list.append(value)  <span class="comment"># 将数据暂存在列表</span></span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt;= <span class="number">1000</span>:  <span class="comment"># 每一千条数据执行一次插入</span></span><br><span class="line">                cursor.executemany(sql, data_list)  <span class="comment"># 执行sql语句</span></span><br><span class="line">                data_list.clear()  <span class="comment"># 清空list</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;worksheets: &quot;</span> + sheet + <span class="string">&quot; has been inserted 1000 data!&quot;</span>)</span><br><span class="line">                num = <span class="number">0</span>  <span class="comment"># 计数归零</span></span><br><span class="line">        cursor.executemany(sql, data_list)  <span class="comment"># 执行sql语句</span></span><br><span class="line">        data_list.clear()  <span class="comment"># 清空list</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;worksheets: &quot;</span> + sheet + <span class="string">&quot; has been inserted &quot;</span> + <span class="built_in">str</span>(num) + <span class="string">&quot; data!&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> row_num != <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Success: worksheets: &quot;</span> + sheet + <span class="string">&quot; has been inserted &quot;</span> + <span class="built_in">str</span>(row_num - <span class="number">1</span>) + <span class="string">&quot; data!&quot;</span>)</span><br><span class="line">    db.commit()  <span class="comment"># 提交</span></span><br><span class="line">    cursor.close()  <span class="comment"># 关闭连接</span></span><br><span class="line">    db.close()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    store_to(<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;xxx.xls&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="python-复制文件-2">python 复制文件</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">shutil.copy(src, dst)</span><br></pre></td></tr></table></figure>
<h2 id="字符串处理">字符串处理</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将变量转化成字符串类型</span></span><br><span class="line"><span class="built_in">str</span>(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串全大写/全小写</span></span><br><span class="line">name = name.upper()</span><br><span class="line">name = name.lower()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类 C 语言中的字符串格式化语言，python 中用 % 处理变量转化</span></span><br><span class="line">ftp_name = <span class="string">&quot;%s_%s&quot;</span>%(cass_id, sec[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># strip()去掉字符串首位多余字符，为空时去掉多余空格</span></span><br><span class="line"><span class="comment"># split()将字符串通过参数中的字符，分割成若干字符串存在数组中</span></span><br><span class="line">plist = pic_advantage.strip().split(<span class="string">&quot;，&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># re模块处理正则表达式，以下为将 code 转化为[^a-zA-Z0-9]字符的函数</span></span><br><span class="line">pattern_code_trim = re.<span class="built_in">compile</span>(<span class="string">&quot;[^a-zA-Z0-9]&quot;</span>)</span><br><span class="line">src_code_trim = pattern_code_trim.sub(<span class="string">&#x27;&#x27;</span>, code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python中没有自增</span></span><br><span class="line">i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="字典的遍历">字典的遍历</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># keys() 该方法会返回字典的所有的key</span></span><br><span class="line"><span class="comment"># 该方法会返回一个序列，序列中保存有字典的所有的键</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.keys())</span><br><span class="line"><span class="comment"># 通过遍历keys()来获取所有的键</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d.keys() :</span><br><span class="line">    <span class="built_in">print</span>(k , d[k])</span><br><span class="line"></span><br><span class="line"><span class="comment"># values()</span></span><br><span class="line"><span class="comment"># 该方法会返回一个序列，序列中保存有字典的所有的值</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> d.values():</span><br><span class="line">    <span class="built_in">print</span>(v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># items()</span></span><br><span class="line"><span class="comment"># 该方法会返回字典中所有的项</span></span><br><span class="line"><span class="comment"># 它会返回一个序列，序列中包含有双值子序列</span></span><br><span class="line"><span class="comment"># 双值分别是，字典中的key和value</span></span><br><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d.items())</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(k, <span class="string">&#x27;=&#x27;</span>, v)</span><br></pre></td></tr></table></figure>
<h2 id="解析json">解析json</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">d = json.loads(req.text)</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;element&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;element_parent&#x27;</span>][<span class="string">&#x27;element_child&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(item[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> item[<span class="number">1</span>][<span class="string">&#x27;element1&#x27;</span>] == <span class="string">&#x27;xx&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span> item[<span class="number">1</span>][<span class="string">&#x27;element2&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="常用去重方式">常用去重方式</h2>
<h3 id="对列表去重-2">对列表去重</h3>
<ul>
<li>用循环查找的方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">news_li = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> li:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> news_li:</span><br><span class="line">        news_li.append(i)</span><br><span class="line"><span class="built_in">print</span> (news_li)</span><br></pre></td></tr></table></figure>
<ul>
<li>用集合的特性set()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">new_li1 = <span class="built_in">list</span>(<span class="built_in">set</span>(li1))</span><br></pre></td></tr></table></figure>
<ul>
<li>使用itertools模块的grouby方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">li2 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">li2.sort() <span class="comment"># 排序</span></span><br><span class="line">it = itertools.groupby(li2)</span><br><span class="line"><span class="keyword">for</span> k, g <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span> (k)</span><br></pre></td></tr></table></figure>
<ul>
<li>运用while循环遍历的方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quchong</span>(<span class="params">lb</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> lb:</span><br><span class="line">        <span class="keyword">while</span> lb.count(x)&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">del</span> lb[lb.index(x)]</span><br><span class="line">    <span class="keyword">return</span> lb</span><br><span class="line">li3 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line">quchong(li3)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用keys()方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li4 = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">5</span>]</span><br><span class="line">formatli = <span class="built_in">list</span>(&#123;&#125;.fromkeys(li4).keys())</span><br><span class="line"><span class="built_in">print</span> (formatli)</span><br></pre></td></tr></table></figure>
<h3 id="对数据框去重-2">对数据框去重</h3>
<ul>
<li>用unique()对单属性列去重</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;<span class="string">&#x27;id&#x27;</span>:[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;A&#x27;</span>],<span class="string">&#x27;age&#x27;</span>:[<span class="number">18</span>,<span class="number">20</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">14</span>,<span class="number">65</span>,<span class="number">14</span>,<span class="number">98</span>]&#125;</span><br><span class="line">data = pd.DataFrame(data)</span><br><span class="line">data.<span class="built_in">id</span>.unique()</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.unique(data.<span class="built_in">id</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>用frame.drop_duplicates()对单属性列去重</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.drop_duplicates([<span class="string">&#x27;id&#x27;</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>用frame.drop_duplicates()对多属性列去重</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.drop_duplicates([<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>用frame.duplicated()对多属性列去重</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isduplicated = data.duplicated([<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;age&#x27;</span>],keep=<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">data.loc[~isduplicated,:]</span><br></pre></td></tr></table></figure>
<h2 id="查找重复元素">查找重复元素</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">&quot;奔奔&quot;</span>, <span class="string">&quot;benben&quot;</span>, <span class="string">&quot;奔奔&quot;</span>]</span><br><span class="line">b = <span class="built_in">dict</span>(Counter(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只展示重复元素</span></span><br><span class="line"><span class="built_in">print</span> ([key <span class="keyword">for</span> key,value <span class="keyword">in</span> b.items() <span class="keyword">if</span> value &gt; <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展现重复元素和重复次数</span></span><br><span class="line"><span class="built_in">print</span> (&#123;key:value <span class="keyword">for</span> key,value <span class="keyword">in</span> b.items()<span class="keyword">if</span> value &gt; <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>方法一：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">myset = <span class="built_in">set</span>(mylist)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> myset:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;the %d has found %d&quot;</span> %(item,mylist.count(item)))</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">the 1 has found 1</span><br><span class="line">the 2 has found 4</span><br><span class="line">the 3 has found 3</span><br><span class="line">the 4 has found 4</span><br></pre></td></tr></table></figure>
<p><strong>方法二：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">Counter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Counter(&#123;2: 4, 4: 4, 3: 3, 1: 1&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>方法三：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">a = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="type">List</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="type">List</span>.count(i) &gt; <span class="number">1</span>:</span><br><span class="line">        a[i] = <span class="type">List</span>.count(i)</span><br><span class="line"><span class="built_in">print</span> (a)</span><br></pre></td></tr></table></figure>
<h2 id="格式化输出">格式化输出</h2>
<h3 id="动态指定长度的实现-2">动态指定长度的实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print %s固定长度格式输出：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%10s, %20s&quot;</span> % (A, B))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果长度不定，以变量len代替：</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%*s&quot;</span> % (<span class="built_in">len</span>, A))</span><br></pre></td></tr></table></figure>
<h3 id="以指定宽度格式化输出（format）-2">以指定宽度格式化输出（format）</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mat = <span class="string">&quot;&#123;:20&#125;\t&#123;:28&#125;\t&#123;:32&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mat.<span class="built_in">format</span>(<span class="string">&quot;占4个长度&quot;</span>,<span class="string">&quot;占8个长度&quot;</span>, <span class="string">&quot;占12长度&quot;</span>))</span><br><span class="line"><span class="comment"># 如果需要居中输出在宽度前面加一个^</span></span><br><span class="line">mat = <span class="string">&quot;&#123;:^20&#125;\t&#123;:^28&#125;\t&#123;:^32&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mat.<span class="built_in">format</span>(<span class="string">&quot;占4个长度&quot;</span>,<span class="string">&quot;占8个长度&quot;</span>, <span class="string">&quot;占12长度&quot;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="Set-相关操作">Set 相关操作</h2>
<p><strong>python</strong>的<code>set</code>和其他语言类似, 是一个无序不重复元素集。基本功能包括关系测试和消除重复元素。集合对象还支持<code>union(联合)</code>, <code>intersection(交)</code>, <code>difference(差)</code>和<code>sysmmetric difference(对称差集)</code>等数学运算。</p>
<p><code>set</code> 支持 <code>x in set</code>, <code>len(set)</code>, 和 <code>for x in set</code>。作为一个无序的集合，<code>set</code>不记录元素位置或者插入点。因此，<code>set</code>不支持 <code>indexing</code>,<code> slicing</code>, 或其它类序列<code>sequence-like</code>的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>(s) </span><br><span class="line"><span class="comment"># set 的长度</span></span><br><span class="line"></span><br><span class="line">x <span class="keyword">in</span> s </span><br><span class="line"><span class="comment"># 测试 x 是否是 s 的成员</span></span><br><span class="line"></span><br><span class="line">x <span class="keyword">not</span> <span class="keyword">in</span> s </span><br><span class="line"><span class="comment"># 测试 x 是否不是 s 的成员</span></span><br><span class="line"></span><br><span class="line">s.issubset(t) s &lt;= t </span><br><span class="line"><span class="comment"># 测试是否 s 中的每一个元素都在 t 中</span></span><br><span class="line"></span><br><span class="line">s.issuperset(t) s &gt;= t </span><br><span class="line"><span class="comment"># 测试是否 t 中的每一个元素都在 s 中</span></span><br><span class="line"></span><br><span class="line">s.union(t) s | t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 和 t 中的每一个元素</span></span><br><span class="line"></span><br><span class="line">s.intersection(t) s &amp; t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 和 t 中的公共元素</span></span><br><span class="line"></span><br><span class="line">s.difference(t) s - t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 中有但是 t 中没有的元素</span></span><br><span class="line"></span><br><span class="line">s.symmetric_difference(t) s ^ t </span><br><span class="line"><span class="comment"># 返回一个新的 set 包含 s 和 t 中不重复的元素</span></span><br><span class="line"></span><br><span class="line">s.copy() </span><br><span class="line"><span class="comment"># 返回 set “s”的一个浅复制</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">hash</span>(s)</span><br><span class="line"><span class="comment"># 返回 s 的 hash 值</span></span><br><span class="line"></span><br><span class="line">s.update(t)</span><br><span class="line">s |= t</span><br><span class="line"><span class="comment"># 返回增加了 set “t”中元素后的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.intersection_update(t)</span><br><span class="line">s &amp;= t</span><br><span class="line"><span class="comment"># 返回只保留含有 set “t”中元素的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.difference_update(t)</span><br><span class="line">s -= t</span><br><span class="line"><span class="comment"># 返回删除了 set “t”中含有的元素后的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.symmetric_difference_update(t)</span><br><span class="line">s ^= t</span><br><span class="line"><span class="comment"># 返回含有 set “t”或者 set “s”中有而不是两者都有的元素的 set “s”</span></span><br><span class="line"></span><br><span class="line">s.add(x)</span><br><span class="line"><span class="comment"># 向 set “s”中增加元素 x</span></span><br><span class="line"></span><br><span class="line">s.remove(x)</span><br><span class="line"><span class="comment"># 从 set “s”中删除元素 x, 如果不存在则引发 KeyError</span></span><br><span class="line"></span><br><span class="line">s.discard(x)</span><br><span class="line"><span class="comment"># 如果在 set “s”中存在元素 x, 则删除</span></span><br><span class="line"></span><br><span class="line">s.pop()</span><br><span class="line"><span class="comment"># 删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyError</span></span><br><span class="line"></span><br><span class="line">s.clear()</span><br><span class="line"><span class="comment"># 删除 set “s”中的所有元素</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 学习笔记</title>
    <url>/2019/09/06/backend_dev/redis/</url>
    <content><![CDATA[<h1>redis</h1>
<h1>redis 简介</h1>
<p>redis 是一个开源的使用 ANSI C 语言编写、<strong>基于内存亦可持久化</strong>的<strong>日志型</strong>、<strong>Key-Value 数据库</strong>，并提供了对多种编程语言的支持。</p>
<p>支持存储的 value 类型包括 <strong>string（字符串）、list（链表）、set （集合）、zset（sorted set --有序集合）和 hash（哈希）</strong>，所以 redis 也被称为数据结构服务器。这些数据类型都支持 <strong>push/pop 、 add/remove 及取交集并集和差集</strong>等操作，且 redis 支持各种不同方式的排序。为了保证效率，数据都是缓存在内存中。 redis 会<strong>周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件</strong>，并且在此基础上实现了主从（master-slave）同步。</p>
<p>redis 支持<strong>主从同步</strong>。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得 redis 可执行<strong>单层树复制</strong>。存盘可以有意无意的对数据进行写操作。由于完全实现了<strong>发布/订阅机制</strong>，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。</p>
<span id="more"></span>
<h2 id="redis的特点">redis的特点</h2>
<ul>
<li>redis 支持<strong>数据的持久化</strong>，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>redis 是<strong>完全在内存中保存数据</strong>的数据库，使用磁盘只是为了持久化。</li>
<li>redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 string，list，set，zset，hash 等<strong>数据结构</strong>的存储。</li>
<li>redis 支持<strong>数据的备份</strong>，即 master-slave 模式的数据备份。</li>
</ul>
<h2 id="redis-优势">redis 优势</h2>
<ul>
<li><strong><code>性能极高</code></strong> —— redis 是一个高性能的 key-value 数据库，读的速度能达到110000次/s，写的速度能达到81000次/s。</li>
<li><strong><code>丰富的数据类型</code></strong> —— redis 支持 string ， hash ，list ，set 及 zset (sorted set) 等数据类型。</li>
<li><strong><code>原子性</code></strong> —— redis 的所有操作都是原子性的，要么成功执行要么失败完全不执行。单个操作是原子性的。<strong>多个操作也支持事务</strong>，即原子性，通过 MULTI 和 EXEC 指令包起来。</li>
<li><strong><code>丰富的特性</code></strong> —— redis 支持 <strong>publish / subscribe</strong> , 通知, <strong>key 过期</strong>等特性。</li>
</ul>
<blockquote>
<p>redis 使用了两种<strong>文件格式</strong>：</p>
</blockquote>
<ul>
<li><code>全量数据格式</code>：把内存中的数据写入磁盘，便于下次读取文件进行加载</li>
<li><code>增量请求文件</code>：把内存中的数据序列化为操作请求，用于读取文件进行replay得到数据，序列化的操作包括 SET、RPUSH、SADD、ZADD。</li>
</ul>
<blockquote>
<p>redis 的<strong>存储分为内存存储、磁盘存储和 log 文件三部分</strong>，配置文件中有三个参数对其进行配置。</p>
</blockquote>
<ul>
<li><code>save seconds updates</code>：save配置，指出在多长时间内，有多少次更新操作，就将数据同步到数据文件。</li>
<li><code>appendonly yes/no</code>：appendonly配置，指出是否在每次更新操作后进行日志记录，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面的save条件来同步的，所以有的数据会在一段时间内只存在于内存中。</li>
<li><code>appendfsync no/always/everysec</code>：appendfsync 配置，no 表示等操作系统进行数据缓存同步到磁盘，always 表示每次更新操作后手动调用 fsync() 将数据写到磁盘， everysec 表示每秒同步一次。</li>
</ul>
<p>redis 运行在内存中但可持久化到磁盘，在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。内存数据库的一个优点是，<strong>相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，可以做很多内部复杂性很强的事情</strong>。</p>
<h1>redis 基础命令</h1>
<h2 id="服务器命令">服务器命令</h2>
<ul>
<li>启动服务： <code>redis-server --service-start</code></li>
<li>关闭服务： <code>redis-server --service-stop</code></li>
<li>使用 redis.conf 开启服务： <code>redis-server /path/to/redis.conf</code></li>
</ul>
<h2 id="客户端命令">客户端命令</h2>
<blockquote>
<p><strong>连接服务器</strong>：<code>redis-cli -h 127.0.0.1 -p 6379 -a abcd</code></p>
</blockquote>
<p>参数说明：</p>
<ul>
<li>-h：即host，服务器的IP地址</li>
<li>-p：即port，服务器的端口</li>
<li>-a：即auth，redis服务器的密码</li>
</ul>
<p>参数可缺省，缺省时默认 -h 为 127.0.0.1 ，-p 为 6379 。</p>
<blockquote>
<p><strong>密码操作</strong>：设置/修改密码： <code>config set requirepass newPassword</code>；查看密码： <code>config get requirepass</code></p>
</blockquote>
<p>也可以通过修改配置文件来实现：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6opk9rkstj30u00uxwtl.jpg" alt="requirepass"></p>
<p><strong>推荐使用修改配置文件的方式。</strong></p>
<p>因为本次连接期间，命令行对配置参数的修改（包括密码），只在本次连接期间有效，并不会同步到 redis.conf 中。断开连接后，下次连接时，使用的仍是配置文件中的参数（包括密码），之前命令行修改的配置参数失效。</p>
<p>redis 命令的关键字<strong>不区分大小写</strong>。</p>
<blockquote>
<p><strong>查看帮助</strong></p>
</blockquote>
<ul>
<li>查看服务器端帮助： <code>redis-server --help</code></li>
<li>查看客户端帮助： <code>redis-cli --help</code></li>
<li>redis 命令行下查看某个命令的说明： <code>help command</code></li>
</ul>
<h1>redis 配置</h1>
<h2 id="服务器参数说明">服务器参数说明</h2>
<blockquote>
<p>redis.conf 配置的是 redis <strong>服务器</strong>。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1      //设置redis服务器的ip地址</span><br><span class="line"></span><br><span class="line">port 6379           //指定端口号</span><br><span class="line"></span><br><span class="line"><span class="built_in">timeout</span> 300         //当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能。默认为0，需要修改。</span><br><span class="line"></span><br><span class="line">loglevel notice     //指定日志记录级别，redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</span><br><span class="line"></span><br><span class="line">logfile stdout      //日志记录方式，需要修改为标准输出。默认为空串<span class="string">&quot;&quot;</span>。</span><br><span class="line"></span><br><span class="line">databases 16        //设置数据库的数量</span><br><span class="line"></span><br><span class="line">save 900 1          //指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合使用，默认是3个。900s=15minutes</span><br><span class="line"></span><br><span class="line">save 300 10         //300s=5minutes</span><br><span class="line"></span><br><span class="line">save 60 10000       //60s=1minute</span><br><span class="line"></span><br><span class="line">rdbcompression <span class="built_in">yes</span>  //指定存储至本地数据库时是否压缩数据，默认为 <span class="built_in">yes</span>，redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</span><br><span class="line"></span><br><span class="line">dbfilename dump.rdb //指定本地数据库文件名，默认值为 dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span> ./              //指定本地数据库存放目录</span><br><span class="line"></span><br><span class="line">requirepass foobared//设置 redis 连接密码，如果配置了连接密码，客户端在连接 redis 时需要提供密码，默认关闭</span><br><span class="line"></span><br><span class="line">maxclients 128      //设置同一时间最大客户端连接数，默认是注释了的</span><br><span class="line"></span><br><span class="line">maxmemory 536870912 //指定 redis 最大内存限制，512M。默认是注释了的，默认单位字节。</span><br><span class="line"></span><br><span class="line">appendonly <span class="built_in">yes</span>      //指定是否在每次更新操作后进行日志记录，redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> //指定日志文件名，默认为 appendonly.aof</span><br><span class="line"></span><br><span class="line">//指定日志更新条件，有3个值：always、everysec、no，默认使用everysec（其余2条是注释了的）</span><br><span class="line"><span class="comment"># appendfsync always//表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）</span></span><br><span class="line">appendfsync everysec//表示每秒同步一次（折中，默认值）</span><br><span class="line"><span class="comment"># appendfsync no    //表示等操作系统进行数据缓存同步到磁盘（快）</span></span><br><span class="line"></span><br><span class="line">activerehashing <span class="built_in">yes</span> //指定是否激活重置哈希，默认为<span class="built_in">yes</span> </span><br></pre></td></tr></table></figure>
<p>redis 在启动时会把数据加载到内存中，达到最大内存后，redis 会先尝试清除已到期或即将到期的 Key，当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区。</p>
<h2 id="命令行操作配置参数">命令行操作配置参数</h2>
<ul>
<li>设置配置参数： <code>CONFIG SET key value</code></li>
<li>查看配置参数： <code>CONFIG GET key</code></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CONFIG GET *           //查看所有的配置参数</span><br></pre></td></tr></table></figure>
<h1>redis Key 键的操作</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> key value       //设置、修改值</span><br><span class="line"></span><br><span class="line">get key             //如果key不存在，返回nil，表示空。</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> key            //返回key对应的value的数据类型</span><br><span class="line"></span><br><span class="line">rename key newKey   //重命名key，即修改键的名称。当key和newKey重名时，或者key不存在时，会提示错误。如果newKey已存在，会覆盖原来的值。</span><br><span class="line"></span><br><span class="line">renamenx key newKey //多了nx。返回一个整数。如果newKey不存在，则执行重命名，返回1；如果newKey已存在，不执行重命名，返回0。就是说newKey不存在时才执行。</span><br><span class="line"></span><br><span class="line">randomkey           //从当前数据库中随机返回一个key</span><br><span class="line"></span><br><span class="line">keys  pattern       //返回所有满足pattern的key</span><br><span class="line"></span><br><span class="line">keys person*        //示例：假设当前数据库中有3个key——person1，person2，person3，则该命令会返回所有以person开头的key，即person1、person2、person3</span><br><span class="line"></span><br><span class="line">exists key          //检测key是否存在，存在返回1，不存在返回0</span><br><span class="line"></span><br><span class="line">dump key            //序列化指定的key，返回序列化得到的二进制数据。</span><br><span class="line"></span><br><span class="line">del  key            //删除指定的键值对。若key存在，则删除key，并返回1；若key不存在，直接返回0.</span><br><span class="line"></span><br><span class="line">expire key seconds  //设置key的过期时间，以秒为单位</span><br><span class="line"></span><br><span class="line">expire age 60       //示例：60s后age过期，会自动删除age。</span><br><span class="line"></span><br><span class="line">expireat key timestamp              //设置key的过期时间。多了at。timestamp是时间戳，到了timestamp指定的时间，key过期，自动删除key。时间戳以秒为单位。</span><br><span class="line"></span><br><span class="line">pexpire  key  milliseconds          //设置key的过期时间，以毫秒为单位。多了前缀p</span><br><span class="line"></span><br><span class="line">pexpireat key milliseconds-timestamp//设置key的过期时间，时间戳，以毫秒为单位。多了前缀p、后缀at。</span><br><span class="line"></span><br><span class="line">move key db         //将键值对移到指定的数据库，相当于剪切。返回db——当前使用的数据库的index。</span><br><span class="line"></span><br><span class="line">select db           //redis默认使用数据库0，也可以用显式指定当前使用的数据库。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line"><span class="built_in">set</span> age 10      //默认使用数据库0</span><br><span class="line">move age 1      //将age键值对移到数据库1中。返回1——表示数据库1</span><br><span class="line">exists age      //此时使用的仍是数据库0，返回0——表示当前数据库中不存在age</span><br><span class="line">select 1        //选择（切换）到数据库1</span><br><span class="line">exists age      //返回1——表示存在age</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6oqr11vylj30di0a6jtd.jpg" alt="select"></p>
<p>端口号后面的 [1] 表示当前使用的是数据库 1 。使用数据库 0 时默认缺省。</p>
<p>redis 中 key 、value 加不加引号均可，都默认作为 String 处理。</p>
<h1>redis 数据类型简介</h1>
<p>redis 支持五种数据类型： string（字符串），hash（哈希），list（列表），set（集合）及 zset ( sorted set 有序集合)。</p>
<h2 id="redis-string">redis string</h2>
<p>string 是 redis 的基础数据类型。</p>
<p>示例： <code>set name &quot;zhangsan&quot;</code></p>
<p>key 、 value 都是 string 类型， key 、 value 带不带引号都行，<strong>习惯上 key 不带引号， value 带引号</strong>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">getset key newValue     //给key设置value，并返回旧的value，如果没有旧的value，返回nil。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line"><span class="built_in">set</span> age 10  </span><br><span class="line">getset age 20           //age 的值被设置为20，并返回旧的值10</span><br><span class="line"></span><br><span class="line">getrange key start end  //获取value的部分</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line"><span class="built_in">set</span> content <span class="string">&quot;hello world!&quot;</span> </span><br><span class="line">getrange content 0 4    //返回content对应value的[0,4]上的字符，<span class="string">&quot;hello&quot;</span>，下标</span><br><span class="line">getrange content 0 -1   //支持负数索引，-1表示最后一个字符</span><br><span class="line"></span><br><span class="line">mget key1 key2 ......   //mget即multiple get，同时获取多个key的value，若某个key不存在，该key返回nil</span><br><span class="line"></span><br><span class="line">setex key <span class="built_in">timeout</span> value //setex即<span class="built_in">set</span> expire，给key设置<span class="built_in">timeout</span>、value，若key已存在，会覆盖原来的<span class="built_in">timeout</span>、value</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line">setex age 60 10         //设置age 60s后过期，value为10</span><br><span class="line"></span><br><span class="line">setnx key value         //在 key 不存在时，为 key 设置value，设置成功返回1；若key已存在，不执行（不会替换原来的value），返回0。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line"><span class="built_in">set</span> age 10              //若age已存在，会则覆盖value</span><br><span class="line">setnx age 20            //age不存在时才设置，age已存在就不设置（不会覆盖原来的value）</span><br><span class="line"></span><br><span class="line">mset key1 value1 key2 value2 ......     //mset即multiple  <span class="built_in">set</span>。同时设置多个键值对。因为是<span class="built_in">set</span>，所以若某个key已存在，会覆盖。</span><br><span class="line"></span><br><span class="line">//示例： </span><br><span class="line">mset name <span class="string">&quot;lisi&quot;</span> age 20 </span><br><span class="line"></span><br><span class="line">msetnx key1 value1 key2 value2 ......   //msetnx即multiple setnx，当key不存在时才设置该key，已存在就不设置该key</span><br><span class="line"></span><br><span class="line">append key content      //若key已存在，则在value末尾追加content；若key不存在，则为其设置值，此时相当于<span class="built_in">set</span> key value。返回操作过后，value（新）的长度</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line">append str <span class="string">&quot;hello&quot;</span>      //之前str不存在，此句命令相当于<span class="built_in">set</span> str <span class="string">&quot;hello&quot;</span></span><br><span class="line">append str <span class="string">&quot; world!&quot;</span>    //之前str已存在，则在其末尾追加<span class="string">&quot; world!&quot;</span>，现在str的值变为<span class="string">&quot;hello world!&quot;</span></span><br><span class="line"></span><br><span class="line">incr key                //incr即increase，如果value是整数（可以是负整数），将value的值+1，并返回操作后的value。如果value不是整数，提示错误。如果key不存在，先将value初始化为0，再执行+1。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line"><span class="built_in">set</span> age 10              //等价于<span class="built_in">set</span> age <span class="string">&quot;10&quot;</span>。</span><br><span class="line">incr age                //value的值+1，变为11，并返回11。value是整数才会+1。</span><br><span class="line">get age                 //11</span><br><span class="line">incr price              //之前price不存在，value会先初始化为0，再+1，返回1</span><br><span class="line">get price               //1</span><br><span class="line"></span><br><span class="line">incrby key amount       //同上，只不过是+amout，不是+1。原来的value要是整数，amount也要是整数，否则提示错误。若key不存在，先初始化value为0。支持负整数（即减）。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line"><span class="built_in">set</span> age 20 </span><br><span class="line">incrby age 5            //+5</span><br><span class="line">get age                 //25</span><br><span class="line"></span><br><span class="line">incrbyfloat key amount  //同上，只不过原来的value可以是浮点数，增量amount也可以是浮点数。当然，整数也行。支持负数（减）。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line"><span class="built_in">set</span> price 2.3 </span><br><span class="line">incrbyfloat price 1.5     </span><br><span class="line">get price               //3.8</span><br><span class="line"></span><br><span class="line">decr key                //同incr key只不过decr是减。decr即decrease。</span><br><span class="line"></span><br><span class="line">decrby key amount       //同incrby  key  amount，只不过是减</span><br></pre></td></tr></table></figure>
<h2 id="redis-hash">redis hash</h2>
<p>redis hash 是一个 string 类型的 field 和 value 的映射表，一个 hash 可储存多个键值对。</p>
<p>一个对象往往有多个属性（键值对形式）， hash 特别适合存储对象。</p>
<p>redis 中一个 hash 可以存储 2<sup>32</sup> - 1个 键值对（40多亿）。</p>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hmset zhangsan name <span class="string">&quot;zhangsan&quot;</span> age 12 gender male score 90</span><br></pre></td></tr></table></figure>
<ul>
<li><code>hmset</code> : hm 即 hash multiple ，set 这里表示设置，不是集合。</li>
<li><code>zhangsan</code> : 即这张 hash 表的名称。 redis 是 key-value 数据库， zhangsan 就是 key ，后面的一堆属性看做一个整体（value）。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hset key fieldName fileValue    //hset即<span class="built_in">hash</span> <span class="built_in">set</span>，<span class="built_in">set</span>这里是设置的意思。往<span class="built_in">hash</span>中添加一个字段（键值对）</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line">hset score zhangsan 90          //score是<span class="built_in">hash</span>的名称，zhangsan 90是一个键值对。若zhangsan这个字段名之前不存在，则添加成功返回1。</span><br><span class="line">hset score lisi 85              //一个<span class="built_in">hash</span>可储存多个键值对（40多亿）。</span><br><span class="line">hset score lisi 100             //之前这个<span class="built_in">hash</span>中已存在lisi这个字段名，会覆盖原来的字段值，返回0.</span><br><span class="line"></span><br><span class="line">hsetnx key fieldName fieldValue //多了后缀nx，同上，只是如果这个<span class="built_in">hash</span>中已存在fieldName，则不执行操作（不覆盖原来的值），此时返回0。即当这个<span class="built_in">hash</span>中fieldName不存在时才添加字段。</span><br><span class="line"></span><br><span class="line">hmset key fileName1 fieldValue1 fieldName2 fieldValue2 ......   //同时添加多个字段。hmset即<span class="built_in">hash</span> multiple <span class="built_in">set</span>，因为是<span class="built_in">set</span>所以字段已存在时会覆盖原有的值。</span><br><span class="line"></span><br><span class="line">hget key fieldName              //获取指定字段的值</span><br><span class="line"></span><br><span class="line">hmget key fieldName1 fieldName2 ......  //同时获取一个或多个字段的值</span><br><span class="line"></span><br><span class="line">hgetall key                     //获取所有字段的值，会同时显示fieldName、fieldValue。hgetall即<span class="built_in">hash</span> get all。</span><br><span class="line"></span><br><span class="line">hdel key fieldName1 fieldName2 ...      //删除一个或多个字段</span><br><span class="line"></span><br><span class="line">hexists key fieldName           //检查该字段是否已存在，已存在则返回1，该fieldName不存在或key不存在，则返回0</span><br><span class="line"></span><br><span class="line">hlen key                        //获取<span class="built_in">hash</span>中的字段（键值对）数量</span><br><span class="line"></span><br><span class="line">hkeys  key                      //获取<span class="built_in">hash</span>中所有的feildName</span><br><span class="line"></span><br><span class="line">hvals key                       //获取<span class="built_in">hash</span>中所有的fieldValue</span><br><span class="line"></span><br><span class="line">hscan key cursor [match pattern] [count count]  //迭代<span class="built_in">hash</span>中的键值对</span><br><span class="line"></span><br><span class="line">hincrby key fieldName acount    //将指定字段的值增加acount。原来的字段值、acount都要是整数，否则提示错误。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line">hincrby score lisi 5            //返回操作后的字段值，假如之前lisi的值是80，则返回85</span><br><span class="line">hincrby score lisi -10          //acount支持负整数，即减。</span><br><span class="line"></span><br><span class="line">hincrbyfloat  key fieldName acount  //同上，但是支持浮点数，就是说整数、浮点数都行。</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：</p>
<ul>
<li>没有 hincr 这个命令 (+1) ；</li>
<li>没有提供 hdecr 命令 (减) ；</li>
<li>都带有前缀 h ：表示 hash 。</li>
</ul>
<h2 id="redis-list">redis list</h2>
<p>redis 列表是简单的字符串列表，列表是有序的，按照插入顺序排序。可以添加一个元素（字符串）到列表的头部（左边）或者尾部（右边）。列表中的元素可以重复</p>
<p>一个列表最多可以包含 2<sup>32</sup> - 1 个元素 (40多亿)。</p>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lpush students <span class="string">&quot;zhangsan&quot;</span> <span class="string">&quot;lisi&quot;</span> <span class="string">&quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>lpush</code> : list push ，往 list 中添加元素。</li>
<li><code>students</code> : 即这个列表的名称（key）。列表中的元素看做一个整体（value）。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lpush key value1 value2 ......  //往列表的头部（左边）推入一个或多个元素，lpush的l表示left。key是列表名称，把列表中的所有元素作为一个整体（value）。若key不存在，会自动创建。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line">lpush students <span class="string">&quot;zhangsan&quot;</span> <span class="string">&quot;lisi&quot;</span> <span class="string">&quot;wangwu&quot;</span>   //返回操作后列表中的总元素个数</span><br><span class="line">//先在列表头部添加“zhangsan”，再在列表头部添加“lisi”，接着在列表头部添加“wangwu”，最后列表的前三个元素依次是<span class="string">&quot;wangwu&quot;</span>、“lisi”、“zhangsan”。</span><br><span class="line"></span><br><span class="line">lpushx key value1 value2 ...... //同上，只是key不存在时，不执行操作（不会自动创建）。要key已存在且key时list类型时才会添加元素。</span><br><span class="line"></span><br><span class="line">lpop key                        //弹出列表的第一个元素，会从列表中移除并返回该元素。</span><br><span class="line"></span><br><span class="line">//l表示left，列表的头部。</span><br><span class="line"></span><br><span class="line">rpush key value1 value2 ......  //在列表尾部推入1个或多个元素。</span><br><span class="line"></span><br><span class="line">rpushx key value1 value2 ...... //尾部，key已存在时才会推入。</span><br><span class="line"></span><br><span class="line">rpop                            //弹出列表的最后一个元素</span><br><span class="line"></span><br><span class="line">//r表示right，列表的尾部。</span><br><span class="line">//上面的l、r命令是一一对应的。</span><br><span class="line"></span><br><span class="line">rpoplpush sourceKey destKey     //弹出sourceKey的最后一个元素，并在destKey的头部推入元素，即剪切。返回该元素。rpoplpush即对sourceKey执行rpop，对destKey执行lpush。</span><br><span class="line"></span><br><span class="line">blpop key1 key2 ... <span class="built_in">timeout</span>     //弹出一个或多个的列表的第一个元素，如果列表为空会阻塞列表直到等待超时或发现可弹出元素为止。blpop即<span class="built_in">bind</span>  lpop。</span><br><span class="line"></span><br><span class="line">//示例： </span><br><span class="line">blpop students 60               //60s</span><br><span class="line"></span><br><span class="line">brpop key1 key2 ...... <span class="built_in">timeout</span></span><br><span class="line"></span><br><span class="line">brpoplpush sourceKey destKey <span class="built_in">timeout</span></span><br><span class="line"></span><br><span class="line">llen key                        //返回列表中的元素个数</span><br><span class="line"></span><br><span class="line">lset key index value            //给指定索引处的元素设置值（即修改元素值）</span><br><span class="line"></span><br><span class="line">lindex key index                //根据index索引元素，返回指定位置上的元素</span><br><span class="line"></span><br><span class="line">lrange key start end            //返回[start，end]区间上的所有元素。start、end是索引，比如0  -1  就是返回所有元素。</span><br><span class="line"></span><br><span class="line">ltrim key start end             //修剪列表，只保留[start，end]区间上的元素，其余元素会被删除。</span><br><span class="line"></span><br><span class="line">linsert key before/after value1 value2  //在元素value1之前/之后插入元素value2。value2是要插入的元素。</span><br><span class="line"></span><br><span class="line">//示例： </span><br><span class="line">linsert student before <span class="string">&quot;lisi&quot;</span> <span class="string">&quot;zhangsan&quot;</span>//在lisi的前面插入zhangsan</span><br><span class="line">//插入成功，返回操作后列表的总长度；若value1不存在，返回-1；若key不存在或key是一个空的list，则返回0.</span><br><span class="line"></span><br><span class="line">lrem key count value            //移除列表中值为value的所有元素。lrem即list remove。count是一个整数，表示要删除的个数、搜索方向。</span><br><span class="line">//count&gt;0：从表头向表尾搜索，移除count个值为value的元素</span><br><span class="line">//count&lt;0：从表尾向表头搜索，移除count的绝对值个值为value的元素</span><br><span class="line">//count=0：移除表中所有的值为value的元素。要遍历列表，从哪边开始结果、速度都是一样的。</span><br><span class="line"></span><br><span class="line">//示例： </span><br><span class="line">lrem scores 0 90                //移除列表中所有的90</span><br></pre></td></tr></table></figure>
<p>以上几个命令中，l 表示 list 。 index 从 0 开始，支持负数索引，index 要是已存在的。</p>
<p>redis 的区间，都是闭区间，[ start ，end ] ，两边都包含。</p>
<h2 id="redis-set">redis set</h2>
<p>redis set 是 string 类型的无序集合。集合成员是唯一的（不允许重复）。</p>
<p>redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
<p>集合的最大成员数为 2<sup>32</sup> - 1 (40多亿)。</p>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sadd mySet <span class="string">&quot;zhangsan&quot;</span> <span class="string">&quot;lisi&quot;</span> <span class="string">&quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>sadd</code> : set add ，往集合中添加元素。</li>
<li><code>mySet</code> : 即集合名称（key）。把集合中的所有元素作为一个整体（value）。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sadd key value1 value2 ...  //向集合中添加一个或多个元素。sadd即<span class="built_in">set</span> add，key是集合的名称。返回此次添加的元素个数。</span><br><span class="line"></span><br><span class="line">scard key                   //返回集合的元素个数</span><br><span class="line"></span><br><span class="line">smembers key                //返回集合中所有的元素</span><br><span class="line"></span><br><span class="line">sismember key elementValue  //判断该集合中是否有elementValue这个元素。有返回1，没有或者key不存在则返回0.</span><br><span class="line"></span><br><span class="line">spop key                    //随机移除并返回集合中的一个元素</span><br><span class="line"></span><br><span class="line">srandmember key             //随机返回集合中的一个元素，并不移除该元素。srandmember即<span class="built_in">set</span> random  member.</span><br><span class="line">//可带一个可选参数：</span><br><span class="line">srandmember key count       //count是一个整数，指定返回的元素个数。</span><br><span class="line">//count&gt;0：随机返回count个元素，这些元素互不相同。随机确定一个返回的元素后，再从剩余的元素中随机。</span><br><span class="line">//count&lt;0：随机返回count的绝对值个元素，这些元素可能相同。每次都是从整个集合中随机一个。</span><br><span class="line">//count的绝对值大于等于集合的元素个数时，返回集合中所有的元素。</span><br><span class="line"></span><br><span class="line">srem key value1 value2 ...  //移除集合中的一个或多个元素，若集合中没有该元素，会忽略该元素。</span><br><span class="line"></span><br><span class="line">smove sourceKey destKey elementValue        //将元素从一个集合移动到另一个集合。（剪切）</span><br><span class="line"></span><br><span class="line">sscan key cursor match pattern count num    //迭代集合中的元素。cursor指定对每元素的操作。</span><br><span class="line">//2个可选参数：</span><br><span class="line">//match pattern     指定配置模式，只迭代符合pattern的元素</span><br><span class="line">//count num         指定要迭代的元素个数</span><br><span class="line"></span><br><span class="line">sinter key1 key2 ...        //返回这些集合的交集</span><br><span class="line"></span><br><span class="line">sinterstore destKey key1 key2 ...           //多了store，求key1、key2.....这些集合的交集，并将交集中的元素存储在destKey集合中，返回交集中的元素个数</span><br><span class="line">//相同用法的还有：</span><br><span class="line">//sunion    并集</span><br><span class="line">//sdiff     差集</span><br></pre></td></tr></table></figure>
<h2 id="redis-sorted-set">redis sorted set</h2>
<p>redis 有序集合和集合一样也是 string 类型元素的集合,且不允许出现重复的成员。</p>
<p>但 sorted set 的每个元素都会关联一个 int 型或 double 型的数值型分数。 redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员不允许重复，但分数(score)可以重复。</p>
<p>有序集合是通过哈希表实现的，添加，删除，查找的复杂度都是O(1)。</p>
<p>集合的最大成员数为 2<sup>32</sup> - 1 (40多亿)。</p>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zadd sortedSet 2 <span class="string">&quot;zhangsan&quot;</span> 2.9 <span class="string">&quot;lisi&quot;</span> 1.3 <span class="string">&quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>zadd</code> : z 代表有序集合。</li>
<li><code>sortedSet</code> : 即有序集合的名称（key）。把有序集合中的所有元素（包括分数）看做一个整体（value）。</li>
<li><code>2 &quot;zhangsan&quot;</code> : 2 就是 “zhangsan” 的 score ，顺序就是根据 score 进行升序排列的。 score 可以是 int 、 double 型。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zadd key score1 value1 score2 value2 ...    //往有序集合中添加一个或多个元素。score是数值型，支持整数、浮点数，支持负数。z代表sorted <span class="built_in">set</span>。</span><br><span class="line"></span><br><span class="line">//示例： </span><br><span class="line">zadd students 1 zhangsan 2 lisi 3 wangwu    //返回此次添加的元素个数。score只是附加信息，真正的元素还是value1，value2，......</span><br><span class="line">//说明：<span class="built_in">hash</span>、list、<span class="built_in">set</span>、sorted <span class="built_in">set</span>，在Reids2.4之前的版本中，1次只支持添加一个元素，不支持1次添加多个元素。</span><br><span class="line"></span><br><span class="line">zcard key                                   //返回元素个数</span><br><span class="line"></span><br><span class="line">zcount key minScore maxScore                //返回分数值在[minScore，maxScore]上的元素个数</span><br><span class="line"></span><br><span class="line">zlexcount key minValue maxValue             //返回元素值在[minValue，maxValue]上的元素个数。</span><br><span class="line">//不能直接用元素值，有3种写法：</span><br><span class="line">//[value   表示包含此元素</span><br><span class="line">//(value  表示不包含此元素</span><br><span class="line">//- 表示第一个元素（包含），+ 表示最后一个元素（包含）</span><br><span class="line">//示例：</span><br><span class="line">zadd set1 1 a 2 b 3 c 4 d</span><br><span class="line">zlexcount set1 - +          //返回总元素个数，4</span><br><span class="line">zlexcount set1 [a [b        //2 。即[a,b]上元素个数</span><br><span class="line">zlexcount set1 (a [b        //1。(a,b]</span><br><span class="line">//不能缺省 [  或  (</span><br><span class="line"> </span><br><span class="line">zrange key minIndex maxIndex [withscores]   //返回索引在[minIndex，maxIndex]上的所有元素。</span><br><span class="line">//索引从0开始，支持负数，-1表示倒数第一个元素，-2表示倒数第二个元素。</span><br><span class="line">//withscores是可选参数，带上则还会显示分数，不带则只显示元素值。</span><br><span class="line"></span><br><span class="line">zrangebyscore key minScore maxScore [withscores]    //返回score在[minScore，maxScore]上的所有元素值。</span><br><span class="line">//默认使用 [ ，闭区间。也可以显示指定为 [ 或 ( 。</span><br><span class="line">//withscores可选，带上时会显示元素的score，不带上时不显示score。</span><br><span class="line">//示例： </span><br><span class="line">zrangebyscore set1 [1 (2                    //获取score在[1,2)上的所有元素</span><br><span class="line"></span><br><span class="line">zrank key elementValue                      //返回该元素值的索引。默认按score进行升序排列。索引从0开始。</span><br><span class="line"></span><br><span class="line">//以上3个命令都是按score升序排列的。下面的3个命令：</span><br><span class="line">zrevrange</span><br><span class="line">zrevrangebyscore</span><br><span class="line">zrevrank</span><br><span class="line">//前缀加不是z，而是zrev。和之前的3个命令一一对应，用法完全相同，只不过是按score降序排列计算的。</span><br><span class="line"></span><br><span class="line">zscore key elementValue                     //返回该元素值对应的score值</span><br><span class="line"></span><br><span class="line">zincrby key increment elementValue          //increment是增量，将指定元素的score增加increment。increment支持负数，即减。</span><br><span class="line"></span><br><span class="line">zrem key value1 value2 ...                  //移除一个或多个元素</span><br><span class="line"></span><br><span class="line">zremrangebyrank key startIndex endIndex     //移除下标在[startIndex，endIndex]上的所有元素。zremrangebyrank即z  remove  range  by  rank</span><br><span class="line"></span><br><span class="line">zremrangebyscore key minScore maxScore      //移除score在[minScore，maxScore]上的所有元素</span><br><span class="line"></span><br><span class="line">zremrangebylex key value1 value2            //移除这2个元素值之间的所有元素。</span><br><span class="line">//不能直接写元素值，可以用 - + 表示，或者在元素值前面加[  (</span><br><span class="line"></span><br><span class="line">zscan key cursor [match pattern] [count num]//迭代</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sorted set 也提供了计算交集、并集的命令，此处不再一一介绍。</p>
<h1>redis 常用命令</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">auth password       //验证密码</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> message        //打印文本</span><br><span class="line"></span><br><span class="line">ping                //测试连接，ping一下redis服务器，如果连接正常（已连接到redis服务器）返回PONG。</span><br><span class="line"></span><br><span class="line">select dbIndex      //选择当前使用的数据库，默认使用数据库0，下标，从0开始。</span><br><span class="line"></span><br><span class="line">quit                //关闭当前连接，并退到上一级命令行</span><br><span class="line"></span><br><span class="line">time                //获取服务器上的当前时间。</span><br><span class="line">//有2个返回值，第一个是当前时间的时间戳（s），第二个是当前这一秒已经逝去的微秒数。</span><br><span class="line">//1秒=10^3毫秒=10^6微秒。</span><br><span class="line">//两者组合可显示微秒级的时间。</span><br><span class="line"></span><br><span class="line">config <span class="built_in">set</span> param value  //设置配置参数</span><br><span class="line"></span><br><span class="line">config get param    //获取配置参数的值</span><br><span class="line"></span><br><span class="line">config rewrite      //将本次连接中，这条命令之前，对配置的设置都同步到redis.conf文件中。</span><br><span class="line">//默认对配置的设置、修改只在本次连接期间有效，并不会同步修改redis.conf文件。断开本次连接，会清除本次连接的配置设置，下次连接时，使用的是redis.conf文件中配置。</span><br><span class="line">//比如：</span><br><span class="line">//配置文件中的密码是abc，连接到redis服务器后</span><br><span class="line">config <span class="built_in">set</span> requirepass 123  //修改密码为123</span><br><span class="line">//这次连接中，密码不再是abc，而是123。但这个修改并不会同步到redis.conf文件中，redis.conf文件中的密码仍是abc。下次连接时，使用密码123会提示密码错误，需要使用abc。</span><br><span class="line">//有2种方式同步到redis.conf文件中：</span><br><span class="line">//1. 直接在redis.conf文件中修改</span><br><span class="line">//2. 连接到redis服务器后，在命令行修改，然后使用 config rewrite 命令同步到redis.conf中。</span><br><span class="line"> </span><br><span class="line">dbsize              //返回当前数据库中，key的数量</span><br><span class="line"></span><br><span class="line">flushdb             //清除当前数据库中所有的key，即清空当前数据库。flushdb即flush  db。</span><br><span class="line"></span><br><span class="line">flushall            //清除所有数据库中的key，即清空所有数据库。flushall即flush  all。</span><br><span class="line"></span><br><span class="line">save                //将redis数据库中的所有数据同步到.rdb文件中。redis数据库中的数据是常驻内存的，save命令将内存中的redis数据库数据同步写到数据库文件.rdb中。</span><br><span class="line"></span><br><span class="line">bgsave              //同上，只不过bgsave是在后台异步保存。</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">.rdb 文件是 redis 的数据库文件，rdb即 redis db。启动 redis 服务的时候，会从 .rdb 文件加载所有的数据库数据到内存。就是说数据库数据有 2 份，一份常驻内存，一份是持久化的磁盘文件。</span><br><span class="line"></span><br><span class="line">.rdb 文件也被称为 redis 数据库的备份文件。可以将一个 .rdb 文件放在redis安装目录下，作为这个  redis 服务器的数据库数据。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">client list             //列出所有的连接</span><br><span class="line"></span><br><span class="line">client <span class="built_in">kill</span> ip:port     //关闭某个连接。</span><br><span class="line">//6379只是redis服务器、客户端程序通信使用的端口号。建立一个redis数据库连接，会单独使用一个端口号，一个redis客户端可以建立多个数据库连接，一个连接对应一个端口号，并不是使用6379。</span><br><span class="line"></span><br><span class="line">shutdown [save/nosave]  //关闭redis服务器。会自动关闭与所有的redis客户端连接、以及与这些客户端建立的数据库连接，并同步数据集到rdb文件中。</span><br><span class="line">//shutdown命令可带一个可选参数：是否将数据集同步到rdb文件中。save——同步，nosave——不同步。</span><br><span class="line"></span><br><span class="line">client <span class="built_in">kill</span> ip:port     //是关闭某个数据库连接，quit是关闭redis客户端（会自动关闭这个客户端建立的所有数据库连接），shutdown save是关闭redis服务器（会自动关闭这个redis服务器的所有数据库连接）。</span><br><span class="line"></span><br><span class="line">slaveof ip port         //原本默认本身是主服务器，此句命令会将当前redis服务器作为某个服务器的从服务器。</span><br><span class="line">//示例： </span><br><span class="line">slaveof 127.23.23.35 6379   //把当前服务器作为127.23.23.35这台服务器的从服务器。</span><br><span class="line">//变成从服务器后，会丢弃原来数据库的数据集，从主服务器复制、同步数据到从服务器。</span><br><span class="line">//slave，意为奴隶、从属。</span><br><span class="line"></span><br><span class="line"><span class="built_in">sync</span>                        //从主服务器复制、同步数据集</span><br><span class="line"></span><br><span class="line">slave no one                </span><br><span class="line">//这句命令是关闭这个从服务器的从主服务器复制数据的功能，使这个从服务器变成一个主服务器。使用的仍是作为从服务器时的数据集。</span><br><span class="line">//当主服务器出问题、或者需要做其他用途的时候，可以把一台从服务器作为主服务器，再把其它的从服务器作为这个主服务器的从属，这样就不会影响服务器的运转。</span><br></pre></td></tr></table></figure>
<h1>redis 事务</h1>
<p>redis 事务可以一次执行多个命令。</p>
<p>常用命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">multi       //开起一个事务，标记一个事务块的开始，multi即multiple</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span>        //执行事务块内的命令</span><br><span class="line"></span><br><span class="line">discard     //取消事务</span><br></pre></td></tr></table></figure>
<p>使用步骤：</p>
<ol>
<li>先使用 multi 命令标记事务开始</li>
<li>将多个命令入队( queue ，队列)</li>
<li>使用 exec 命令执行事务</li>
</ol>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">multi                   //标记事务开始</span><br><span class="line"><span class="built_in">set</span> name <span class="string">&quot;zhangsan&quot;</span>     //依次输入多个命令。输入一条命令后会提示“QUEUED”，表示此条命令已入队</span><br><span class="line"><span class="built_in">set</span> age 20 </span><br><span class="line">get name </span><br><span class="line"><span class="built_in">exec</span>                    //执行事务，会依次执行事务块内的命令，依次显示执行结果。</span><br><span class="line">//exec是执行事务，如果想取消事务，将<span class="built_in">exec</span>换为discard即可。</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6pmw8jc4pj30g60egq3t.jpg" alt=""></p>
<p>单个 redis 命令的执行是原子性的，但 redis 并没有在事务上增加任何维持原子性的机制，所以 redis 事务的执行不是原子性的。</p>
<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>
<p>比如执行事务时，第一条执行成功，第二条执行失败，此时并不会回滚之前的操作（此处指第一条、第二条命令），而是继续执行后面的命令。但会显示第二条的结果是Fail。</p>
<p>即事务中任意命令执行失败，其余的命令依然被执行。</p>
<p>在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令队列中。</p>
<p>redis2.6 以后的版本，在服务器内置了 Lua 环境（Lua解释器），可以通过<code>eval</code>命令执行Lua脚本。</p>
<h1>redis 发布订阅</h1>
<p>redis 发布订阅 (pub/sub) 是一种<strong>消息通信模式</strong>：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。<br>
pub 即 publish ，推送。<br>
sub 即 subscribe ，订阅。</p>
<p>订阅者订阅某个 channel（频道），发布者将消息发布到 redis 服务器， redis 服务器将消息推送给这个频道的订阅者。<br>
channel 管道、通道、频道。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6pqnr02aoj30kt08z0tw.jpg" alt="订阅发布"></p>
<p><strong>redis 的 channel 是公共频道，谁都可以发布消息。</strong></p>
<p>就像微信群、QQ群，谁都可以发送消息，群成员（订阅者）都会收到消息。</p>
<p><strong>redis 的消息是在线即时消息，类似于广播，只有在线的订阅者（连接到 redis  服务器的订阅者），才会收到消息。</strong></p>
<p>若当时不在线，并不会收到消息。后面登陆了（连接到服务器），服务器也不会推送之前（这个客户端未收到）的消息。服务器<strong>只推送一遍</strong>。</p>
<h2 id="使用示例">使用示例</h2>
<p><strong>启动一个客户端，连接到服务器</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -a password</span><br></pre></td></tr></table></figure>
<p><strong>订阅频道</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">subscribe channel1 channel2 ... //可订阅一个或多个频道</span><br></pre></td></tr></table></figure>
<p>会显示订阅的频道的信息，一个频道显示 3 个条目:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;subscribe&quot;</span>                 //固定的值，表示这是一个订阅频道</span><br><span class="line">订阅的频道名</span><br><span class="line">一个int型的数，表示这个频道是当前客户端订阅的第几个频道</span><br></pre></td></tr></table></figure>
<p>订阅之后，当前命令提示符会阻塞，只能接收 redis 服务器推送的消息，不能再执行命令。所以我们再启动一个客户端推送消息。</p>
<p><strong>在另一个 redis 客户端推送消息</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">publish channel message         //channel指定要推送消息到哪个频道，message是要推送的消息</span><br></pre></td></tr></table></figure>
<p>返回当前接收到消息的订阅者的数量。1表示只有一个订阅者收到了这条消息。</p>
<p>我们看到另一个客户端已接收到消息。一条消息显示3个项：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;message&quot;</span>                   //固定值，表示这是一条消息</span><br><span class="line">这条消息来自哪个订阅频道</span><br><span class="line">消息内容</span><br></pre></td></tr></table></figure>
<p>redis 的订阅是临时订阅，只在本次连接期间有效。断开连接后，会清除这个客户端的订阅信息，即取消所有订阅的频道。</p>
<p>谁都可以是发布者，谁都可以发送消息。可以向任何频道发送消息。</p>
<h2 id="相关命令">相关命令</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">subscribe channel1 channel2 ...     //订阅一个或多个频道</span><br><span class="line"></span><br><span class="line">unsubscribe channel1 channel2 ...   //退订一个或多个频道。多了un</span><br><span class="line"></span><br><span class="line">psubscribe pattern1 pattern2 ...    //多了一个p，即pattern，订阅该模式匹配的所有频道，可以有多个匹配模式。</span><br><span class="line"></span><br><span class="line">//示例：</span><br><span class="line">psubscribe tv       //订阅频道tv</span><br><span class="line">psubscribe *home    //订阅所有以home结尾的频道</span><br><span class="line">psubscribe china*   //订阅所有以china开头的频道</span><br><span class="line"></span><br><span class="line">punsubscribe pattern1 pattern2 ...  //退订符合匹配的所有频道，可指定多个匹配模式，满足pattern1或者满足pattern2.....,，注意是或。</span><br><span class="line"></span><br><span class="line">publish channel message             //推送消息到某个频道</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法合集</title>
    <url>/2019/05/10/backend_dev/%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h1>数据结构算法合集</h1>
<h2 id="第一部分：链表">第一部分：链表</h2>
<ul>
<li>从一给定的顺序表L中删除下标i-j（i&lt;=j,包括i,j）的所有元素，假定i,j合法。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中，以数组的形式保存的线性表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k, delta;</span><br><span class="line">    delta = j - i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(k = j + <span class="number">1</span>; k &lt; L.length; ++k)&#123;</span><br><span class="line">        L.data[k - delta]=L.data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length -= delta;<span class="comment">//最后要更新顺序表的表长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有一顺序表L，其元素为整型数据，设计一个算法，将L中所有小于表头元素的数据放在前半部分，大于表头元素的数据放在后半部分。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="type">int</span>  i = <span class="number">0</span>, j = L.length - <span class="number">1</span>;</span><br><span class="line">    temp = L.data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j&amp;&amp; L.data[j] &gt; temp) --j;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            L.data[i] = L.data[j];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j&amp;&amp; L.data[i] &lt; temp) ++i;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            L.data[j] = L.data[i];</span><br><span class="line">            --j; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li>递增非空单链表，设计一个算法删除值域重复的结点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">viod <span class="title function_">dels</span><span class="params">(LNode *L)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next, *q;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == p-&gt;next-&gt;data)&#123;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>带头结点的单链表L，在不建立新结点，只能通过已有结点的条件下将其逆置。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverseList</span><span class="params">(LNode *L)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next, *q;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设计一个算法，删除带头结点的单链表L中最小值结点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delminNode</span><span class="params">(LNode *L)</span>&#123;</span><br><span class="line">    LNode *pre = L, *p = L-&gt;next, *minpre = pre, *minp = p;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data &lt; minp-&gt;data)&#123;</span><br><span class="line">            minp = p;</span><br><span class="line">            minpre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    minpre-&gt;next = minp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(minp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设计一个算法，将一个头结点为A的单链表（其数据域为整型），分解成两个单链表A和B，使保持相对顺序的情况下，A中只有奇数结点，B中只有偶数结点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spList</span><span class="params">(LNode *A, LNode *&amp;B)</span>&#123;</span><br><span class="line">    LNode *p, *q, *r;</span><br><span class="line">    B = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    B-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    r = B;</span><br><span class="line">    p = A;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next-&gt;data%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">            r = q;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有N个个位正整数存放在int型数组A[0,1,…,N-1]中，N为已定义的常量且N&lt;=9，数组A[]的长度为N，另给一个int型变量i，要求只要上述变量（A[0]~A[N-1]与i这N+1个整型变量）写一个算法，找出这N个整数中的最小值，并且要求不能破坏数组A[]中的数据。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 难点： int i 这一个变量来实现通航数组下标 i 和 min 两个变量所实现的功能</span></span><br><span class="line"><span class="comment">// 实现方法： 可以让 i 的十位上的数字作为循环变量，将 i 的个位上的数字用来存储 min </span></span><br><span class="line"><span class="comment">// i % 10 即取 i 个位上的数字，i / 10 即取 i 十位上的数字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> &amp;i)</span>&#123;</span><br><span class="line">    i = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(i/<span class="number">10</span> &lt;= N<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">10</span> &gt; A[i/<span class="number">10</span>])&#123;</span><br><span class="line">            i = i - i%<span class="number">10</span>;</span><br><span class="line">            i = i + A[i/<span class="number">10</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        i = i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = i % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写一个函数，逆序打印单链表中的数据，假设指针L指向了单链表的开始结点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归思想：在表不空的情况下，递归地逆序打印表中第一个数据之后的数据，然后打印第一个数据。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reprint</span><span class="params">(LNode *L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        reprint(L-&gt;next);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, L-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>试编写一个函数，以不多于3n/2的平均比较次数，在一个有n个整型的顺序表A中找出最大最小值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FindMaxMin</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> &amp;max, <span class="type">int</span> &amp;min)</span>&#123;</span><br><span class="line">    max = min = A[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; max)</span><br><span class="line">            max = A[i];</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt; min)</span><br><span class="line">            min = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最坏情况：当表中 n 个整数按从大到小非递增排列时，数据比较次数为 2(n-1) 次</span></span><br><span class="line"><span class="comment">//最好情况：当表中 n 个整数按从小到大非递减排列时，数据比较次数为 n-1 次</span></span><br><span class="line"><span class="comment">//A 中数据的有序性可以认为是等可能的，故，最好最坏情况概率相同</span></span><br><span class="line"><span class="comment">//综上所述，数据平均比较次数为 (2*(n-1)+(n-1))/2 = 3n/2 - 3/2 &lt; 3n/2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>设A=（a1,a2,…,an）和B=（b1,b2,…,bn）均为顺序表，A’和B’分别是除去最大公共前缀后的子表。若A=（b,e,i,j,i,n,g）,B=（b,e,i,f,a,n,g），则A’=（j,i,n,g），B’=（f,a,n,g），若A’=B’=∅，则A=B，若A’=∅且B≠∅，或两者均不为空且A’的第一个元素值小于B’的第一个元素值，则A&lt;B，否则A&gt;B.试写出一个函数，根据上述方法比较A,B大小。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只需先进行一趟循环，过滤掉最大公共前缀，再判断剩余部分，A = B 返回0， A &lt; B 返回-1，否则返回1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">float</span> A[], <span class="type">int</span> An, <span class="type">float</span> B[], <span class="type">int</span> Bn)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 过滤公共前缀*/</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; An &amp;&amp; i &lt; Bn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(A[i] - B[i]) &lt; min)</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* A&#x27;,B&#x27;均为空*/</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= An &amp;&amp; i &gt;= Bn)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* A&#x27; ≠ ∅且B&#x27; ≠ ∅，或A&#x27;第一个元素值小于B&#x27;*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((i &gt;= An &amp;&amp; i &lt; Bn)||A[i] &lt; B[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>键盘输入n个英文字母，输入格式为n,C1,C2,…,Cn，其中n表示字母个数，请编程以这些输入数据建立一个单链表，并要求将字母不重复的存入链表。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每输入一个数据，扫描其在链表中是否出现，如果出现，就什么都不做，否则构造结点，插入表中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createLinkNoSameElem</span><span class="params">(LNode *&amp;head)</span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化链表*/</span></span><br><span class="line">    head = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);<span class="comment">//输入字母个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">/* 若出现过该数据，则退出循环，且此时 p != NULL*/</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data == ch)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 若未出现过该数据，则 p 此时遍历到了表尾结点，进行插入操作，让 p 重新指向新结点*/</span></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">            p-&gt;data = ch;</span><br><span class="line">            <span class="comment">/* 头插法，插入结点*/</span></span><br><span class="line">            p-&gt;next = head-&gt;next;</span><br><span class="line">            head-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将一长度为n的数组的前段k(k&lt;n)个元素逆序后移动到数组后端，要求数组中的数据不丢失。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路：可直接将第一个元素与最后一个元素交换，第二个与倒数第二个元素交换，以此类推，依次执行 k 次，利用顺序表逆置算法将前 k 个按逆序的方式移动到了数组后端</span></span><br><span class="line"><span class="comment">/* a[]:逆置数组，left~right:逆置范围，k:逆置次数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left, j = right; i &lt; j &amp;&amp; i &lt; left + k ; ++i, --j)&#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当 k 大于逆序数组元素个数的一半时，只需要逆序到 i &lt; j 时即可，因为此时整个数组已经完全逆置</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将一长度为n的数组的前段k(k&lt;n)个元素保持原序移动到数组后端，要求数组中的数据不丢失。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路：代码间尽量提高已有代码的复用性，12为本题前一问，则本题思路为，通过将前 k 个元素先进行一次逆序，再将 k 个元素进行一个整体逆序，则前 k 个元素经过两次逆序保持了原来的顺序，而一次交换到了数组最后端。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">moveToEND</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    reverse(a, <span class="number">0</span>, k<span class="number">-1</span>, k);</span><br><span class="line">    reverse(a, <span class="number">0</span>, n<span class="number">-1</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将n(n&gt;1)个数组存放在一维数组R中，设计一个算法，将R中的序列循环左移p(0&lt;p&lt;n)个位置，即将R中的数据由{X0,X1,…,Xn-1}变换为{Xp,Xp+1,…,Xn-1,X0,X1,…,Xp-1}。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路：需实现 R 中序列循环左移 p 个位置，只需将 R 中前 p 个元素逆置，再将剩余元素逆置，最后进行一次整体逆置即可</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">moveP</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> p)</span>&#123;</span><br><span class="line">    reverse(a, <span class="number">0</span>, p<span class="number">-1</span>, p);</span><br><span class="line">    reverse(a, p, n<span class="number">-1</span>, n-p);</span><br><span class="line">    reverse(a, <span class="number">0</span>, n-i, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一由Head指针指出的非空双链表中，结点结构为{lLink,data,rLink},请设计一个算法，将结点数据data值最大的那个结点（最大的结点唯一），移动到链表最前边，要求不得申请新结点空间。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路：①找出最大值结点；②“删除”结点；③插入最大值结点</span></span><br><span class="line"><span class="comment">//&#123;llink,data,rlink&#125;是伪代码表示法，仅只改了名字，llink对应于prior指针，rlink对应于next指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">maxFirst</span><span class="params">(DLNode *head)</span>&#123;</span><br><span class="line">    DLNode *p = head-&gt;rlink, *q = p;</span><br><span class="line">    <span class="type">int</span> max = p-&gt;data;</span><br><span class="line">    <span class="comment">/* 查找*/</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; p_.data)&#123;</span><br><span class="line">            max = p-&gt;data;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;rlink;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 删除*/</span></span><br><span class="line">    DLNode *l = q-&gt;llink, *r = q-&gt;rlink;</span><br><span class="line">    l-&gt;rlink = r;</span><br><span class="line">    <span class="keyword">if</span>(r != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        r-&gt;llink = l;</span><br><span class="line">    <span class="comment">/* 插入*/</span></span><br><span class="line">    q-&gt;llink = head;</span><br><span class="line">    q-&gt;rlink = head-&gt;rlink;</span><br><span class="line">    head-&gt;rlink = q;</span><br><span class="line">    q-&gt;rlink-&gt;llink = q;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<h2 id="第二部分：二叉树">第二部分：二叉树</h2>
<ul>
<li>表达式 (a-(b+c))*(d/e) 存储在如图所示的一颗以二叉链表为存储结构的二叉树中，（二叉树结点的data域为字符型），编写程序求出该表达式的值（操作数均为一位整数）。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">           /  \</span></span><br><span class="line"><span class="comment">          -    /</span></span><br><span class="line"><span class="comment">        /  \  /  \</span></span><br><span class="line"><span class="comment">        a  +  d  e</span></span><br><span class="line"><span class="comment">          / \</span></span><br><span class="line"><span class="comment">          b c </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//分析：递归求值时，首先要知道，左子树的值，右子树的值，再根据根节点的运算符才可以进行下一步运算，故应采用后序遍历来解决此题</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(BTNode *p)</span>&#123;</span><br><span class="line">    <span class="type">int</span> A, B;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>&amp;&amp; p-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">/* 此二叉树为正则二叉树，若度为2，则子树为子表达式*/</span></span><br><span class="line">            A = comp(p-&gt;lchild);</span><br><span class="line">            B = comp(p-&gt;rchild);</span><br><span class="line">            <span class="keyword">return</span> op(A, B, p-&gt;data);<span class="comment">//度为2的结点上，子树根节点为运算操作符</span></span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p-&gt;data - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//度为0的结点上，子树为操作数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写一个算法求一棵二叉树的深度，二叉树以二叉链表为存储方式。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分析：已知一颗左子树的深度，和右子树的深度，如何算出整棵树的深度呢？（递归思想）</span></span><br><span class="line"><span class="comment">//左子树的深度为LD，右子树的深度为RD，则整棵树的深度就是max&#123;LD,RD&#125;+1</span></span><br><span class="line"><span class="comment">//需要得到左右子树的信息后再进行操作，故为后序遍历</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(BTNode *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> LD, RD;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        LD = getDepth(p-&gt;lchild);</span><br><span class="line">        RD = getDepth(p-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> (LD &gt; RD ? LD : RD) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在一棵以二叉链表为存储结构的二叉树中，查找data域值等于key的结点，存在则用 q 指向该结点（找到任何一个即可），否则赋值为NULL，假设data域为int型。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//剪枝操作：当在左子树中找到满足的结点后，无需继续查找右子树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">search</span> <span class="params">(BTNode *p, BTNode *&amp;q, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == key)</span><br><span class="line">            q = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            search(p-&gt;lchild, q, key);</span><br><span class="line">            <span class="keyword">if</span> (q == <span class="literal">NULL</span>)</span><br><span class="line">                search(p-&gt;rchild, q, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>假设二叉树采用二叉链表存储结构存储，设计一个算法，求出二叉树的深度。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面定义的这个结构体为顺序非循环队列的队列元素，可以存储结点指针以及结点所在的层次号</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    BTNode  *p;     <span class="comment">//结点指针</span></span><br><span class="line">    <span class="type">int</span>     lno;    <span class="comment">//结点所在层次号</span></span><br><span class="line">&#125; St;</span><br><span class="line"><span class="type">int</span> <span class="title function_">maxNode</span><span class="params">(BTNode *p)</span> &#123;</span><br><span class="line">    St que[maxSize];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    <span class="type">int</span> Lno, i, j, n, max;</span><br><span class="line">    front = rear = <span class="number">0</span>;</span><br><span class="line">    BTNode *q;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ++rear;</span><br><span class="line">        que[rear].p = b;</span><br><span class="line">        que[rear].lno = <span class="number">1</span>;          <span class="comment">//树根层次号设为1</span></span><br><span class="line">        <span class="keyword">while</span> (front != rear) &#123;</span><br><span class="line">            ++front;</span><br><span class="line">            q = que[front].p;</span><br><span class="line">            Lno = que[front].lno;   <span class="comment">//Lno用来存储当前结点层号</span></span><br><span class="line">            <span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ++rear;</span><br><span class="line">                que[rear].p = q-&gt;lchild;</span><br><span class="line">                <span class="comment">//根据当前结点的层号推知其孩子结点的层号</span></span><br><span class="line">                que[rear].lno = Lno + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                 ++rear;</span><br><span class="line">                que[rear].p = q-&gt;rchild;</span><br><span class="line">                <span class="comment">//根据当前结点的层号推知其孩子结点的层号</span></span><br><span class="line">                que[rear].lno = Lno + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意：此时退出循环，Lno保存了结点的最大层数</span></span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= Lno; ++i) &#123;</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= rear; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (que[j].lno == i)</span><br><span class="line">                    ++n;</span><br><span class="line">                <span class="keyword">if</span>(max &lt; n)</span><br><span class="line">                    max = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;               </span><br></pre></td></tr></table></figure>
<ul>
<li>假设二叉树采用二叉链表存储结构，设计一个算法，利用结点的右孩子指针 rchild，将一颗二叉树的叶子节点按照从左往右的顺序串成一个单链表，（在题目中定义两个指针 head 与 tail，head 初值为 NULL, head 指向第一个结点，tail 指向最后一个结点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">link</span> <span class="params">(BTNode *p, BTNode *&amp;head, BTNode *&amp;tail)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">                head = p;</span><br><span class="line">                tail = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;rchild = p;</span><br><span class="line">                tail = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        link(p-&gt;lchild, head, tail);</span><br><span class="line">        link(p-&gt;rchild, head, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>在二叉树的二叉链式存储结构中，增加一个指向双亲结点的 parent 指针，设计一个算法，给这个指针赋值，并输出所有结点到根节点的路径。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给各个结点的 parent 指针赋值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">triBtree</span> <span class="params">(BTNode *p, BTNode *q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p-&gt;parent = q;  <span class="comment">//q初值为NULL</span></span><br><span class="line">        q = p;          <span class="comment">//让q一直为p的双亲</span></span><br><span class="line">        triBtree(p-&gt;lchild, q);</span><br><span class="line">        triBtree(p-&gt;rchild, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印路径</span></span><br><span class="line"><span class="comment">//单个路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPath</span><span class="params">(BTNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所有结点路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAllPath</span><span class="params">(BTNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printPath(p);</span><br><span class="line">        printAllPath(p-&gt;lchild);</span><br><span class="line">        printAllPath(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>
<ul>
<li>假设满二叉树ｂ的先序遍历序列已经存在于数组中（名称自定义，长度为ｎ），设计一个算法将其转换为后序遍历序列。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change</span> <span class="params">(<span class="type">char</span> pre[], <span class="type">int</span> L1, <span class="type">int</span> R1, <span class="type">char</span> post[], <span class="type">int</span> L2, <span class="type">int</span> R2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (L1 &lt;= R2) &#123;</span><br><span class="line">        post[R2] = pre[L1];</span><br><span class="line">        change(pre, L1+<span class="number">1</span>, (L1+R1+<span class="number">1</span>)/<span class="number">2</span>, post, L2, (L2+R2<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">        change(pre, (L1+R1+<span class="number">1</span>)/<span class="number">2</span>, R1, post, (L2+R2<span class="number">-1</span>)/<span class="number">2</span>, R2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<ul>
<li>假设二叉树采用二叉链式存储结构，设计一个算法，求二叉树中，值为 x 的结点的层号。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> L;</span><br><span class="line"><span class="type">void</span> <span class="title function_">findElemNo</span><span class="params">(BTNode *p, <span class="type">char</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == x)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, L);</span><br><span class="line">        ++L;    <span class="comment">//打印完后，p指针要进入下一层结点，故L要自增1</span></span><br><span class="line">        findElemNo(p-&gt;lchild, x);</span><br><span class="line">        findElemNo(p-&gt;rchild, x);</span><br><span class="line">        --L;    <span class="comment">//p指针将要由下一层返回到上一层，故L要自减1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设中序线索二叉树的类型为TBTNode* InThTree:&lt;1&gt;设计算法，在一棵中序线索二叉树中寻找结点t的子树上中序下的最后一个结点；&lt;2&gt;设计算法，在一棵中序线索二叉树中寻找结点t中序下的前驱；&lt;3&gt;设计算法，在一棵中序线索二叉树中寻找结点t前序下的后继。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1&gt;</span></span><br><span class="line">TBTNode* <span class="title function_">inLast</span> <span class="params">(TBTNode *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    TBTNode *p = t;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; !p-&gt;rtag)<span class="comment">//p非空且p不为线索（rtag == 0）时</span></span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2&gt;</span></span><br><span class="line">TBTNode* <span class="title function_">inPrior</span> <span class="params">(TBTNode *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    TBTNode *p = t-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; !p-&gt;ltag)</span><br><span class="line">        p = inLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3&gt;</span></span><br><span class="line">TBTNode* <span class="title function_">treNext</span><span class="params">(TBTNode *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    TBTNode *p;</span><br><span class="line">    <span class="keyword">if</span>(!t-&gt;ltag)</span><br><span class="line">        p = t-&gt;lchild;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!t-&gt;rtag)</span><br><span class="line">        p = t-&gt;rchild;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//左右都为线索，则到了叶子结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = t;</span><br><span class="line">        <span class="keyword">while</span>(p &amp;&amp; !p-&gt;rtag)</span><br><span class="line">        <span class="comment">/* 沿着线索一直找到第一个有右子树的祖先结点</span></span><br><span class="line"><span class="comment">         * 其第一个右孩子即为前序下的后继结点      */</span></span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>假设二叉树采用二叉链式存储结构，设计一个算法，输出根节点到每个叶子结点的路径。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 先全局定义一个用来存储路径的栈，由于采用先入栈根结点，故栈顶top值初值为0 */</span></span><br><span class="line"><span class="type">char</span> pathStack[maxSize];</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">allPath</span><span class="params">(BTNode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pathStack[top] = p-&gt;data;</span><br><span class="line">        ++top;  <span class="comment">//p自上往下走时，结点入栈</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;       <span class="comment">//p指向叶子结点时，打印路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; top; ++i)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, pathStack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        allPath(p-&gt;lchild);</span><br><span class="line">        allPath(p-&gt;rchild);</span><br><span class="line">        --top;  <span class="comment">//p自下往上走时，结点出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端技能</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS_SOP</title>
    <url>/2020/10/01/soft_power/mac_os/</url>
    <content><![CDATA[<h1>MacOS 使用技巧</h1>
<h1>VIM常用快捷键</h1>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ </span><br><span class="line">// 光标移动到最后一个字符</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> </span><br><span class="line">// 光标移动到首位</span><br><span class="line"></span><br><span class="line">ZZ </span><br><span class="line">// 保存退出</span><br><span class="line"></span><br><span class="line">dt<span class="symbol">&lt;character&gt;</span></span><br><span class="line">// 删除到该字符</span><br><span class="line"></span><br><span class="line"><span class="keyword">f</span><span class="symbol">&lt;character&gt;</span></span><br><span class="line">// 将光标移动到，从光标当前位置开始第一个该字符的位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1>Homebrew</h1>
<h2 id="brew-相关命令-2">brew 相关命令</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">更新：brew update</span><br><span class="line">查看版本：brew -v</span><br><span class="line">帮助信息：brew -h</span><br><span class="line"></span><br><span class="line">查询软件的详细信息：brew info &lt;软件名&gt;</span><br><span class="line">查看安装列表：brew list</span><br><span class="line"></span><br><span class="line">安装软件包：brew install &lt;软件名&gt;</span><br><span class="line">卸载软件包：brew uninstall &lt;软件名&gt;</span><br><span class="line">彻底卸载指定软件，包括旧版本：brew uninstall --force &lt;软件名&gt;</span><br><span class="line"></span><br><span class="line">搜索软件：brew search &lt;正则表达式/软件名&gt;</span><br><span class="line">更新所有软件包：brew upgrade &lt;软件名&gt;</span><br><span class="line">查询有更新版本的软件：brew outdated</span><br><span class="line">清理指定软件的过时包：brew cleanup &lt;软件名&gt;</span><br><span class="line">清理所有的过时软件：brew cleanup</span><br><span class="line">列出需要清理的内容：brew cleanup -n</span><br><span class="line"></span><br><span class="line">用浏览器打开相关包的页面：brew home &lt;软件名&gt;</span><br><span class="line">显示包依赖：brew deps &lt;软件名&gt;</span><br><span class="line">锁定某个包：brew pin $FORMULA</span><br><span class="line">取消锁定：brew unpin $FORMULA</span><br><span class="line">查看已安装的包的依赖，树形显示：brew deps --installed --tree </span><br></pre></td></tr></table></figure>
<h2 id="brew-应用包-2">brew 应用包</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tree</span><br><span class="line">// 显示目录层级关系</span><br><span class="line"></span><br><span class="line">youtube-dl</span><br><span class="line">// 下载youtube视频</span><br><span class="line"></span><br><span class="line">ncdu</span><br><span class="line">// 查看磁盘占用情况</span><br><span class="line"></span><br><span class="line">ffmpeg</span><br><span class="line">// 音视频格式转换转码</span><br><span class="line"></span><br><span class="line">you-get</span><br><span class="line">// 下载爬取视频</span><br><span class="line"></span><br><span class="line">thefuck</span><br><span class="line">// 自动重输正确的建议命令</span><br></pre></td></tr></table></figure>
<h1>zsh + iterm2</h1>
<h2 id="zsh-插件的使用">zsh 插件的使用</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git</span><br><span class="line">// git 快捷指令 由↓查看快捷指令</span><br><span class="line">// <span class="built_in">cat</span> ~/.oh-my-zsh/plugins/git/git.plugin.zsh</span><br><span class="line"></span><br><span class="line">gitignore</span><br><span class="line">// 自动生成gitignore文件</span><br><span class="line">// gi &lt;c/c++/python/...&gt; &gt; .gitignore</span><br><span class="line"></span><br><span class="line">zsh_reload</span><br><span class="line">// src 重载zsh</span><br><span class="line"></span><br><span class="line">git-open</span><br><span class="line">// 在任何一个git目录，输入git-open 就可以打开github对应的页面</span><br><span class="line"></span><br><span class="line">safe-paste</span><br><span class="line">// 当你往 zsh 粘贴脚本时，它不会被立刻运行</span><br><span class="line"></span><br><span class="line">extract</span><br><span class="line">// 万能解压命令</span><br><span class="line"></span><br><span class="line">gh-md-toc</span><br><span class="line">// md目录生成工具，<span class="built_in">alias</span> -&gt; mdtoc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>iterm2 支持 option + 光标点选直接移动光标位置。</li>
<li>iterm2 通过<code>Command + K</code>实现清屏。</li>
</ul>
<h1>Hexo版本升级</h1>
<p>1、全局升级<code>hexo-cli</code>，先<code>hexo version</code>查看当前版本，然后<code>npm i hexo-cli -g</code>，再次<code>hexo version</code>查看是否升级成功。</p>
<p>2、使用<code>npm install -g npm-check</code>和<code>npm-check</code>，检查系统中的插件是否有升级的，可以看到自己前面都安装了那些插件</p>
<p>3、使用<code>npm install -g npm-upgrade</code>和<code>npm-upgrade</code>，升级系统中的插件</p>
<p>4、使用<code>npm update -g</code>和<code>npm update --save</code></p>
<p>如果遇到报错，需要重装xcode-cli：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /Library/Developer/CommandLineTools</span><br><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>软实力</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>productivity</tag>
      </tags>
  </entry>
  <entry>
    <title>PPT 学习笔记</title>
    <url>/2021/11/18/soft_power/ppt/</url>
    <content><![CDATA[<hr>
<h1>PPT 美化四步法</h1>
<ol>
<li><strong>统一字体</strong>。微软雅黑（安全性有保证）。</li>
<li><strong>突出标题</strong>。长短设计，动词短句。</li>
<li><strong>巧取颜色</strong>。从模板和LOGO里面提取强调色。</li>
<li><strong>快速配图</strong>。</li>
</ol>
<h2 id="统一字体">统一字体</h2>
<p><strong>微软雅黑。</strong></p>
<ul>
<li>一级标题字号设置<strong>32号及以上</strong>。</li>
<li>二级标题字号设置<strong>24~28</strong>。</li>
<li>正文字号设置<strong>18~20</strong>。</li>
<li>标题和正文在纵向上需要有一定的错位。<strong>TAB</strong></li>
<li><strong>填充颜色</strong>，字体设置白色的方式，形成颜色的反差，形成层次感。</li>
</ul>
<h2 id="突出标题">突出标题</h2>
<ul>
<li>长度统一。</li>
<li>动词短句。</li>
<li>一级大标题可以设置阴影。</li>
</ul>
<h2 id="巧取颜色">巧取颜色</h2>
<ul>
<li>注意颜色搭配。eg: 红/黑。</li>
<li>正文颜色可以适当灰度处理，突出标题即可。eg: 正文调整为深灰色。</li>
</ul>
<h2 id="快速配图">快速配图</h2>
<ul>
<li>根据标题查找相关图片，注意图文关联。</li>
<li>图片有底色的时候，添加色块来统一底色。</li>
<li>培训类PPT，可以配一些微笑人脸进行情绪调动。</li>
<li>搜图的时候，要打开想象力，用具体场景进行联想搜图，避免和别人重复。</li>
</ul>
<span id="more"></span>
<hr>
<h1>PPT 丑陋四宗罪</h1>
<ol>
<li><strong>Word 搬家</strong>。没有做文字提炼</li>
<li><strong>滥用图片</strong>。文不如字，字不如表，表不如图。滥用图片会导致注意力被分散。</li>
<li><strong>滥用颜色</strong>。不统一，缺乏设计感。</li>
<li><strong>滥用字体</strong>。不统一，缺乏设计感。</li>
</ol>
<hr>
<h1>PPT 排版四步法</h1>
<h2 id="分层对齐">分层对齐</h2>
<ul>
<li>大段文字需要分层，不要堆积在一起。</li>
<li>文字需要换行的情况，设置<strong>两端对齐</strong>，方便阅读。</li>
</ul>
<h2 id="提炼标题">提炼标题</h2>
<ul>
<li>找到正文中的关键字，<strong>提炼出小标题</strong>，单独设置出粗体或者更大的字体。</li>
<li>设置出<strong>项目符号</strong>，并注意将正文于提炼出的小标题设置成不同的项目符号。</li>
</ul>
<h2 id="调整间距">调整间距</h2>
<ul>
<li>行距。<strong>多倍行距</strong>，设置行间距倍数。</li>
<li>段间距，设置标题<strong>段前间距磅数</strong>。</li>
</ul>
<h2 id="添加缩进">添加缩进</h2>
<ul>
<li>将正文内容进行一定的<strong>错位缩进</strong>。</li>
</ul>
<hr>
<h1>PPT 风格标准化四步法</h1>
<ol>
<li><strong>统一导入</strong></li>
<li><strong>统一模板</strong></li>
<li><strong>统一字体</strong></li>
<li><strong>统一颜色</strong></li>
</ol>
<h2 id="统一导入">统一导入</h2>
<ul>
<li>Word 调整</li>
</ul>
<p>将 Word 改造成有层级的大纲</p>
<ol>
<li>Word 中点击<strong>视图</strong>，选择<strong>大纲</strong>视图</li>
<li><strong>大纲级别设置</strong>，标题设置为一级，正文设置为二级</li>
<li>点击<strong>发送到PPT</strong>，一键导入到PPT</li>
</ol>
<blockquote>
<p>一键将 Word 内容导入到 PPT 相关设置：<br>
Windows 版本下对 Word 进行以下设置：</p>
<ol>
<li>点击左上角<strong>自定义快速导入工具栏</strong></li>
<li>点击<strong>其他命令</strong></li>
<li>选择<strong>快速访问工具栏</strong></li>
<li>选择<strong>不在功能区中的命令</strong></li>
<li>找到<strong>发送到PPT</strong>，点击<strong>添加</strong></li>
</ol>
<p><strong>macOS</strong>下，通过将文本保存为<strong>RTF格式</strong>文件之后，在PPT中导入该大纲文件即可。</p>
</blockquote>
<p>注意：这个方法要注意提前进行大纲设置，且只能导入文字，导入之前尽量保证文本所有字体的统一。</p>
<h2 id="统一模板">统一模板</h2>
<p>点击<strong>设计</strong>，点击<strong>主题</strong>，选择想要设置的模板和模板变体。</p>
<p>注意：自己导入主题的时候，要注意 PPT 主题的完整。</p>
<ul>
<li>创建主题</li>
</ul>
<p>新建 PPT，点击<strong>视图</strong>，点击<strong>幻灯片母版</strong>，可以开始编辑母版板式，编辑完了之后，点击<strong>设计</strong>，点击<strong>主题</strong>，选择<strong>保存当前主题</strong>，即可保存一个自定义模板。</p>
<h2 id="统一字体-2">统一字体</h2>
<p>点击<strong>开始</strong>，点击<strong>替换</strong>，选择<strong>替换字体</strong>，可以将字体统一的文档替换成新的字体。</p>
<ul>
<li>统一 PPT 中一级标题的字体</li>
</ul>
<p>点击<strong>视图</strong>，点击<strong>大纲视图</strong>，按住<strong>Ctrl</strong>,选中所有的标题，然后在<strong>开始</strong>菜单栏中修改对应的字体，最后记得将视图修改回<strong>普通</strong>。</p>
<h2 id="统一颜色">统一颜色</h2>
<p>点击<strong>开始</strong>，点击<strong>格式刷</strong>，选择调整好颜色的文本框（类似于吸管的作用），然后选择需要统一颜色的文本框逐一点击即可，按<strong>ESC</strong>键退出格式刷。</p>
<hr>
<h1>PPT 设计基本原则合集</h1>
<h2 id="封面">封面</h2>
<ul>
<li>突出标题。字号尽量大，竖向排版。</li>
<li>可以配图，但是避免图片吸引过多的注意力，所以最多只占用一半的版面。</li>
<li>为了不显得标题单薄，可以适当添加附加信息，字号要小（16~18），竖向排版。</li>
</ul>
<h2 id="目录">目录</h2>
<ul>
<li>横向排版，方便阅读。</li>
<li>强调内容，而非序号。</li>
<li>可以配图，但是避免图片吸引过多的注意力，所以最多只占用一半的版面。</li>
</ul>
<h2 id="产品介绍">产品介绍</h2>
<ul>
<li>好的产品自己会说话，弱化文字内容，强化产品图片。</li>
<li>图片版面接近一半，要有冲击力，诱惑力。</li>
</ul>
<h1>PPT 操作小技巧合集</h1>
<ol>
<li>拖拽圆形时，按shift键可以创建正圆</li>
<li>框选项目之后，按住ctrl进行拖拽可以对所选项目进行复制</li>
<li>按住ctrl点选项目可以进行多选</li>
</ol>
]]></content>
      <categories>
        <category>软实力</category>
      </categories>
      <tags>
        <tag>office</tag>
        <tag>ppt</tag>
      </tags>
  </entry>
</search>
