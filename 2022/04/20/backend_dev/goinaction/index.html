<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"collie2nd.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"waline","storage":true,"lazyload":false,"nav":null,"activeClass":"waline"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="GO IN ACTION第 1 章：关于 Go 语言的介绍本章主要内容 用 Go 语言解决现代计算难题 使用 Go 语言工具  本章小结 Go 语言是现代的、快速的，带有一个强大的标准库。 Go 语言内置对并发的支持。 Go 语言使用接口作为代码复用的基础模块。">
<meta property="og:type" content="article">
<meta property="og:title" content="《Go in Action》读书笔记">
<meta property="og:url" content="http://collie2nd.github.io/2022/04/20/backend_dev/goinaction/index.html">
<meta property="og:site_name" content="试过重启了吗">
<meta property="og:description" content="GO IN ACTION第 1 章：关于 Go 语言的介绍本章主要内容 用 Go 语言解决现代计算难题 使用 Go 语言工具  本章小结 Go 语言是现代的、快速的，带有一个强大的标准库。 Go 语言内置对并发的支持。 Go 语言使用接口作为代码复用的基础模块。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://pic.colliexyy.com/16456783729444.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456784619966.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456784684067.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456785047191.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456785352268.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456787227017.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456787379595.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456789214463.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456789279256.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456789448794.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456789501715.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456789562770.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456790245075.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456790474052.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456790285047.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456790805527.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456790845095.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456792126348.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456792372571.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456792583487.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456793372822.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456793486607.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456793524862.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456793684336.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456793791903.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456794334532.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456794506167.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456794746728.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456794874952.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456795142159.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456795522106.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456795648957.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456795776727.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456796242116.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456796486532.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456796565200.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456796876518.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456797022738.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456796908521.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456797308594.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456797524566.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456798193068.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456798231494.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456798257437.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456798319556.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456798492658.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16456798555094.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16450993159728.jpg">
<meta property="og:image" content="http://pic.colliexyy.com/16450994882616.jpg">
<meta property="article:published_time" content="2022-04-19T16:00:00.000Z">
<meta property="article:modified_time" content="2022-04-19T16:00:00.000Z">
<meta property="article:author" content="Collie">
<meta property="article:tag" content="read">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://pic.colliexyy.com/16456783729444.jpg">


<link rel="canonical" href="http://collie2nd.github.io/2022/04/20/backend_dev/goinaction/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://collie2nd.github.io/2022/04/20/backend_dev/goinaction/","path":"2022/04/20/backend_dev/goinaction/","title":"《Go in Action》读书笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《Go in Action》读书笔记 | 试过重启了吗</title>
  




<link rel="dns-prefetch" href="comment.colliexyy.com">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">试过重启了吗</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Collie's Site</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">14</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">3</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">42</span></a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#GO-IN-ACTION"><span class="nav-number">1.</span> <span class="nav-text">GO IN ACTION</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-1-%E7%AB%A0%EF%BC%9A%E5%85%B3%E4%BA%8E-Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">第 1 章：关于 Go 语言的介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="nav-number">2.1.</span> <span class="nav-text">本章主要内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="nav-number">2.2.</span> <span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-2-%E7%AB%A0%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B%E4%B8%80%E4%B8%AA-Go-%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">第 2 章：快速开始一个 Go 程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9-1"><span class="nav-number">3.1.</span> <span class="nav-text">本章主要内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-1"><span class="nav-number">3.2.</span> <span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-3-%E7%AB%A0%EF%BC%9A%E6%89%93%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7%E9%93%BE"><span class="nav-number">4.</span> <span class="nav-text">第 3 章：打包和工具链</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9-2"><span class="nav-number">4.1.</span> <span class="nav-text">本章主要内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%BC%E5%85%A5"><span class="nav-number">4.2.</span> <span class="nav-text">远程导入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E5%AF%BC%E5%85%A5"><span class="nav-number">4.3.</span> <span class="nav-text">命名导入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">4.4.</span> <span class="nav-text">Go 常用命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A5%E5%88%86%E4%BA%AB%E4%B8%BA%E7%9B%AE%E7%9A%84%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%A0%81%E5%BA%93"><span class="nav-number">4.5.</span> <span class="nav-text">以分享为目的创建代码库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E5%9C%A8%E6%9C%80%E6%B5%81%E8%A1%8C%E7%9A%84%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="nav-number">4.6.</span> <span class="nav-text">现在最流行的依赖管理工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96"><span class="nav-number">4.7.</span> <span class="nav-text">第三方依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-2"><span class="nav-number">4.8.</span> <span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E5%92%8C%E6%98%A0%E5%B0%84"><span class="nav-number">5.</span> <span class="nav-text">第 4 章：数组、切片和映射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9-3"><span class="nav-number">5.1.</span> <span class="nav-text">本章主要内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">5.2.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87"><span class="nav-number">5.3.</span> <span class="nav-text">切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%A0%E5%B0%84"><span class="nav-number">5.4.</span> <span class="nav-text">映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-3"><span class="nav-number">5.5.</span> <span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-5-%E7%AB%A0%EF%BC%9AGo-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="nav-number">6.</span> <span class="nav-text">第 5 章：Go 语言的类型系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9-4"><span class="nav-number">6.1.</span> <span class="nav-text">本章主要内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%EF%BC%9A%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.2.</span> <span class="nav-text">多态：嵌入类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E5%BC%80%E5%92%8C%E6%9C%AA%E5%85%AC%E5%BC%80%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">6.3.</span> <span class="nav-text">公开和未公开标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-4"><span class="nav-number">6.4.</span> <span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-6-%E7%AB%A0%EF%BC%9A%E5%B9%B6%E5%8F%91"><span class="nav-number">7.</span> <span class="nav-text">第 6 章：并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9-5"><span class="nav-number">7.1.</span> <span class="nav-text">本章主要内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#goroutines"><span class="nav-number">7.2.</span> <span class="nav-text">goroutines</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%9E%E4%BA%89%E7%8A%B6%E6%80%81"><span class="nav-number">7.3.</span> <span class="nav-text">竞争状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E4%BD%8F%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="nav-number">7.4.</span> <span class="nav-text">锁住共享资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E9%81%93"><span class="nav-number">7.5.</span> <span class="nav-text">通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-5"><span class="nav-number">7.6.</span> <span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-7-%E7%AB%A0%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">第 7 章：并发模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9-6"><span class="nav-number">8.1.</span> <span class="nav-text">本章主要内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runner"><span class="nav-number">8.2.</span> <span class="nav-text">runner</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pool"><span class="nav-number">8.3.</span> <span class="nav-text">pool</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#work"><span class="nav-number">8.4.</span> <span class="nav-text">work</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-6"><span class="nav-number">8.5.</span> <span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-8-%E7%AB%A0%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-number">9.</span> <span class="nav-text">第 8 章：标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9-7"><span class="nav-number">9.1.</span> <span class="nav-text">本章主要内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E4%B8%8E%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-number">9.2.</span> <span class="nav-text">文档与源代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97"><span class="nav-number">9.3.</span> <span class="nav-text">记录日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6%E7%9A%84%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%99%A8"><span class="nav-number">9.4.</span> <span class="nav-text">定制的日志记录器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81-x2F-%E8%A7%A3%E7%A0%81"><span class="nav-number">9.5.</span> <span class="nav-text">编码&#x2F;解码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="nav-number">9.6.</span> <span class="nav-text">输入和输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-7"><span class="nav-number">9.7.</span> <span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-9-%E7%AB%A0%EF%BC%9A%E6%B5%8B%E8%AF%95%E5%92%8C%E6%80%A7%E8%83%BD"><span class="nav-number">10.</span> <span class="nav-text">第 9 章：测试和性能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9-8"><span class="nav-number">10.1.</span> <span class="nav-text">本章主要内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">10.2.</span> <span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%B5%8B%E8%AF%95"><span class="nav-number">10.3.</span> <span class="nav-text">基础测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E7%BB%84%E6%B5%8B%E8%AF%95"><span class="nav-number">10.4.</span> <span class="nav-text">表组测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E4%BB%BF%E8%B0%83%E7%94%A8"><span class="nav-number">10.5.</span> <span class="nav-text">模仿调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%82%B9"><span class="nav-number">10.6.</span> <span class="nav-text">测试服务端点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">10.7.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="nav-number">10.8.</span> <span class="nav-text">基准测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-8"><span class="nav-number">10.9.</span> <span class="nav-text">本章小结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Collie"
      src="/images/blue.gif">
  <p class="site-author-name" itemprop="name">Collie</p>
  <div class="site-description" itemprop="description">less is more</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/collie2nd" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;collie2nd" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:collie1158@qq.com" title="E-Mail → mailto:collie1158@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/6213715897" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6213715897" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/collie2nd" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;collie2nd" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/collie2nd" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;collie2nd" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/collie2nd" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;collie2nd" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/collie2nd" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://collie2nd.github.io/2022/04/20/backend_dev/goinaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blue.gif">
      <meta itemprop="name" content="Collie">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="试过重启了吗">
      <meta itemprop="description" content="less is more">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《Go in Action》读书笔记 | 试过重启了吗">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Go in Action》读书笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-20 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-20T00:00:00+08:00">2022-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">后端技能</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2022/04/20/backend_dev/goinaction/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2022/04/20/backend_dev/goinaction/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>25k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>23 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="GO-IN-ACTION"><a href="#GO-IN-ACTION" class="headerlink" title="GO IN ACTION"></a>GO IN ACTION</h1><h1 id="第-1-章：关于-Go-语言的介绍"><a href="#第-1-章：关于-Go-语言的介绍" class="headerlink" title="第 1 章：关于 Go 语言的介绍"></a>第 1 章：关于 Go 语言的介绍</h1><h2 id="本章主要内容"><a href="#本章主要内容" class="headerlink" title="本章主要内容"></a>本章主要内容</h2><ul>
<li>用 Go 语言解决现代计算难题</li>
<li>使用 Go 语言工具</li>
</ul>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>Go 语言是现代的、快速的，带有一个强大的<strong>标准库</strong>。</li>
<li>Go 语言内置对<strong>并发</strong>的支持。</li>
<li>Go 语言使用<strong>接口</strong>作为代码复用的基础模块。</li>
</ul>
<span id="more"></span>

<h1 id="第-2-章：快速开始一个-Go-程序"><a href="#第-2-章：快速开始一个-Go-程序" class="headerlink" title="第 2 章：快速开始一个 Go 程序"></a>第 2 章：快速开始一个 Go 程序</h1><h2 id="本章主要内容-1"><a href="#本章主要内容-1" class="headerlink" title="本章主要内容"></a>本章主要内容</h2><ul>
<li>学习如何写一个复杂的 Go 程序</li>
<li>声明类型、变量、函数和方法</li>
<li>启动并同步操作 goroutine</li>
<li>使用接口写通用的代码</li>
<li>处理程序逻辑和错误</li>
<li>如果需要声明初始值为零值的变量，应该使用 var 关键字声明变量；如果提供确切的非零值初始化变量或者使用函数返回值创建变量，应该使用简化变量声明运算符。</li>
<li>当代码导入了一个包时，程序可以直接访问这个包中任意一个公开的标识符。这些标识符以大写字母开头。以小写字母开头的标识符是不公开的，不能被其他包中的代码直接访问。</li>
<li>在 Go 语言中，所有变量都被初始化为其零值。对于数值类型，零值是 0；对于字符串类型，零值是空字符串；对于布尔类型，零值是 false；对于指针，零值是 nil。对于引用类型来说，所引用的底层数据结构会被初始化为对应的零值。</li>
<li>不仅仅是 Go 语言，很多语言都允许一个函数返回多个值。<strong>一般会像 RetrieveFeeds 函数这样声明一个函数返回一个值和一个错误值。如果发生了错误，永远不要使用该函数返回的另一个值。</strong> 这时必须忽略另一个值，否则程序会产生更多的错误，甚至崩溃。</li>
<li>使用 sync 包的 WaitGroup 跟踪所有启动的 goroutine。非常推荐使用 WaitGroup 来跟踪 goroutine 的工作是否完成。WaitGroup 是一个计数信号量，我们可以利用它来统计所有的 goroutine 是不是都完成了工作。</li>
<li>Go 语言中，所有的变量都以值的方式传递。因为指针变量的值是所指向的内存地址，在函数间传递指针变量，是在传递这个地址值，所以依旧被看作以值的方式在传递。</li>
<li><strong>因为有了闭包，函数可以直接访问到那些没有作为参数传入的变量。</strong> 匿名函数并没有拿到这些变量的副本，而是直接访问外层函数作用域中声明的这些变量本身。因为 matcher 和 feed 变量每次调用时值不相同，所以并没有使用闭包的方式访问这两个变量。</li>
<li>goroutine 里面调用了 WaitGroup 的 Wait 方法。这个方法会导致 goroutine 阻塞，直到 WaitGroup 内部的计数到达 0。</li>
<li><strong>因为 Go 编译器可以根据赋值运算符右边的值来推导类型，声明常量的时候不需要指定类型。</strong></li>
<li>常量的名称使用小写字母开头，表示它只能在当前包内的代码里直接访问，而不暴露到包外面。</li>
<li>每个字段的声明最后 &#96; 引号里的部分被称作标记（tag），每个标记将结构类型里字段对应到 JSON 文档里指定名字的字段。</li>
<li>使用关键字 defer 来安排调用 Close 方法，可以保证这个函数一定会被调用。哪怕函数意外崩溃终止，也能保证关键字 defer 安排调用的函数会被执行。<strong>关键字 defer 可以缩短打开文件和关闭文件之间间隔的代码行数，有助提高代码可读性，减少错误。</strong></li>
<li>Decode 方法接受一个类型为 interface{}的值作为参数。这个类型在 Go 语言里很特殊，一般会配合 reflect 包里提供的反射功能一起使用。</li>
<li>如果接口类型只包含一个方法，那么这个类型的名字以 er 结尾。如果接口类型内部声明了多个方法，其名字需要与其行为关联。</li>
<li>如果要让一个用户定义的类型实现一个接口，这个用户定义的类型要实现接口类型里声明的所有方法。</li>
<li><strong>空结构在创建实例时，不会分配任何内存。这种结构很适合创建没有任何状态的类型。</strong></li>
<li>如果声明函数的时候带有接收者，则意味着声明了一个方法。这个方法会和指定的接收者的类型绑在一起。Search 方法与 defaultMatcher 类型的值绑在一起。这意味着我们可以使用 defaultMatcher 类型的值或者指向这个类型值的指针来调用 Search 方法。</li>
<li><strong>因为大部分方法在被调用后都需要维护接收者的值的状态，所以，一个最佳实践是，将方法的接收者声明为指针。</strong></li>
<li><strong>使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时候被调用。使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用。</strong></li>
<li>程序里所有的 init 方法都会在 main 函数启动前被调用。</li>
<li>我们使用下划线标识符作为别名导入 matchers 包，完成了这个调用。这种方法可以让编译器在导入未被引用的包时不报错，而且依旧会定位到包内的 init 函数。</li>
<li>append 这个内置函数会根据切片需要，决定是否要增加切片的长度和容量。这个函数的第一个参数是希望追加到的切片，第二个参数是要追加的值。</li>
<li><strong>使用指针可以在函数间或者 goroutine 间共享数据。</strong></li>
</ul>
<h2 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>每个代码文件都属于一个包，而包名应该与代码文件所在的文件夹同名。</li>
<li>Go 语言提供了多种声明和初始化变量的方式。如果变量的值没有显式初始化，编译器会将变量初始化为零值。</li>
<li>使用指针可以在函数间或者 goroutine 间共享数据。</li>
<li>通过启动 goroutine 和使用通道完成并发和同步。</li>
<li>Go 语言提供了内置函数来支持 Go 语言内部的数据结构。</li>
<li>标准库包含很多包，能做很多很有用的事情。</li>
<li>使用 Go 接口可以编写通用的代码和框架。</li>
</ul>
<h1 id="第-3-章：打包和工具链"><a href="#第-3-章：打包和工具链" class="headerlink" title="第 3 章：打包和工具链"></a>第 3 章：打包和工具链</h1><h2 id="本章主要内容-2"><a href="#本章主要内容-2" class="headerlink" title="本章主要内容"></a>本章主要内容</h2><ul>
<li>如何组织 Go 代码</li>
<li>使用 Go 语言自带的相关命令</li>
<li>使用其他开发者提供的工具</li>
<li>与其他开发者合作</li>
<li>所有 Go 语言的程序都会组织成若干组文件，每组文件被称为一个包。这样每个包的代码都可以作为很小的复用单元，被其他项目引用。</li>
<li>所有的 .go 文件，除了空行和注释，都应该在第一行声明自己所属的包。每个包都在一个单独的目录里。</li>
<li>同一个目录下的所有 .go 文件必须声明同一个包名。</li>
<li>给包命名的惯例是使用包所在目录的名字。</li>
<li>所有用 Go 语言编译的可执行程序都必须有一个名叫 main 的包。</li>
<li>当编译器发现某个包的名字为 main 时，它一定也会发现名为 main() 的函数，否则不会创建可执行文件。</li>
<li><strong>程序编译时，会使用声明 main 包的代码所在的目录的目录名作为二进制可执行文件的文件名。</strong></li>
<li>记住，在 Go 语言里，<strong>命令是指任何可执行程序。包更常用来指语义上可导入的功能单元。</strong></li>
<li><code>go doc fmt</code></li>
<li><code>go doc strings</code></li>
<li>GOPATH 指定的这些目录就是开发者的个人工作空间。</li>
<li>编译器会首先查找 Go 的安装目录，然后才会按顺序查找 GOPATH 变量里列出的目录。</li>
</ul>
<h2 id="远程导入"><a href="#远程导入" class="headerlink" title="远程导入"></a>远程导入</h2><ul>
<li>目前的大势所趋是，使用分布式版本控制系统（Distributed Version Control Systems DVCS）来分享代码，如 GitHub、Launchpad 还有 Bitbucket。Go 语言的工具链本身就支持从这些网站及类似网站获取源代码。</li>
<li>go get 将获取任意指定的 URL 的包，或者一个已经导入的包所依赖的其他包。由于 go get 的这种递归特性，这个命令会扫描某个包的源码树，获取能找到的所有依赖包。</li>
</ul>
<h2 id="命名导入"><a href="#命名导入" class="headerlink" title="命名导入"></a>命名导入</h2><ul>
<li><strong>命名导入是指，在 import 语句给出的包路径的左侧定义一个名字，将导入的包命名为新名字。</strong></li>
<li>当你导入了一个不在代码里使用的包时，Go 编译器会编译失败，并输出一个错误。Go 开发团队认为，这个特性可以防止导入了未被使用的包，避免代码变得臃肿。</li>
<li>有时，用户可能需要导入一个包，但是不需要引用这个包的标识符。在这种情况，可以使用空白标识符_来重命名这个导入。</li>
<li>每个包可以包含任意多个 init 函数，这些函数都会在程序执行开始的时候被调用。</li>
</ul>
<h2 id="Go-常用命令"><a href="#Go-常用命令" class="headerlink" title="Go 常用命令"></a>Go 常用命令</h2><ul>
<li>build 和 clean 命令会执行编译和清理的工作。</li>
<li><strong>在不包含文件名时，go 工具会默认使用当前目录来编译。</strong></li>
<li>因为构建包是很常用的动作，所以也可以直接指定包。go build github.com&#x2F;goinaction&#x2F;code&#x2F;chapter3&#x2F;wordcount</li>
<li>也可以在指定包的时候使用通配符。<code>...</code>表示匹配所有的字符串。</li>
<li>除了指定包，大部分 Go 命令使用短路径作为参数。</li>
<li>go run 命令会先构建 wordcount.go 里包含的程序，然后执行构建后的程序。</li>
<li><strong>vet 命令会帮开发人员检测代码的常见错误。</strong></li>
<li>fmt 命令会自动格式化开发人员指定的源代码文件并保存。</li>
<li>如果开发人员使用命令行提示符工作，可以在终端上直接使用 go doc 命令来打印文档。go doc tar</li>
<li>如果开发人员认为一个浏览器界面会更有效率，可以使用 godoc 程序来启动一个 Web 服务器，通过点击的方式来查看 Go 语言的包的文档。godoc -http&#x3D;:6060</li>
<li><strong>如果想给包写一段文字量比较大的文档，可以在工程里包含一个叫作 doc.go 的文件，使用同样的包名，并把包的介绍使用注释加在包名声明之前。</strong></li>
</ul>
<h2 id="以分享为目的创建代码库"><a href="#以分享为目的创建代码库" class="headerlink" title="以分享为目的创建代码库"></a>以分享为目的创建代码库</h2><ul>
<li>包应该在代码库的根目录中。在创建想要分享的代码库的时候，包名应该就是代码库的名字，而且包的源代码应该位于代码库目录结构的根目录。</li>
<li>包可以非常小。</li>
<li>对代码执行 go fmt。</li>
<li>给代码写文档。</li>
</ul>
<h2 id="现在最流行的依赖管理工具"><a href="#现在最流行的依赖管理工具" class="headerlink" title="现在最流行的依赖管理工具"></a>现在最流行的依赖管理工具</h2><ul>
<li>godep</li>
<li>vender</li>
<li>gopkg.in</li>
</ul>
<h2 id="第三方依赖"><a href="#第三方依赖" class="headerlink" title="第三方依赖"></a>第三方依赖</h2><ul>
<li>像 godep 和 vender 这种社区工具已经使用第三方（verdoring）导入路径重写这种特性解决了依赖问题。其思想是把所有的依赖包复制到工程代码库中的目录里，然后使用工程内部的依赖包所在目录来重写所有的导入路径。</li>
<li>gb 基于工程将 Go 工具链工作空间的元信息做替换。这种依赖管理的方法不需要重写工程内代码的导入路径。而且导入路径依旧通过 go get 和 GOPATH 工作空间来管理。</li>
<li>gb 工程会区分开发人员写的代码和开发人员需要依赖的代码。开发人员的代码所依赖的代码被称作第三方代码（vendored code）。</li>
<li>gb 一个最好的特点是，不需要重写导入路径。</li>
<li>gb 工程与 Go 官方工具链（包括 go get）并不兼容。因为 gb 不需要设置 GOPATH，而 Go 工具链无法理解 gb 工程的目录结构，所以无法用 Go 工具链构建、测试或者获取代码。构建（如代码清单 3-16 所示）和测试 gb 工程需要先进入$PROJECT 目录，并使用 gb 工具。</li>
</ul>
<h2 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>在 Go 语言中包是组织代码的基本单位。</li>
<li>环境变量 GOPATH 决定了 Go 源代码在磁盘上被保存、编译和安装的位置。</li>
<li>可以为每个工程设置不同的 GOPATH，以保持源代码和依赖的隔离。</li>
<li>go 工具是在命令行上工作的最好工具。</li>
<li>开发人员可以使用 go get 来获取别人的包并将其安装到自己的 GOPATH 指定的目录。</li>
<li>想要为别人创建包很简单，只要把源代码放到公用代码库，并遵守一些简单规则就可以了。</li>
<li><strong>Go 语言在设计时将分享代码作为语言的核心特性和驱动力。</strong></li>
<li>推荐使用依赖管理工具来管理依赖。</li>
<li>有很多社区开发的依赖管理工具，如 godep、vender 和 gb。</li>
</ul>
<h1 id="第-4-章：数组、切片和映射"><a href="#第-4-章：数组、切片和映射" class="headerlink" title="第 4 章：数组、切片和映射"></a>第 4 章：数组、切片和映射</h1><h2 id="本章主要内容-3"><a href="#本章主要内容-3" class="headerlink" title="本章主要内容"></a>本章主要内容</h2><ul>
<li>数组的内部实现和基础功能</li>
<li>使用切片管理数据集合</li>
<li>使用映射管理键值对</li>
<li><strong>Go 语言有 3 种数据结构可以让用户管理集合数据：数组、切片和映射。</strong></li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>在 Go 语言里，数组是一个长度固定的数据类型，用于存储一段具有相同的类型的元素的连续块。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。</li>
<li>声明数组时需要指定内部存储的数据的类型，以及需要存储的元素的数量，这个数量也称为数组的长度。<code>var array [5]int</code></li>
<li>一旦声明，数组里存储的数据类型和数组长度就都不能改变了。如果需要存储更多的元素，就需要先创建一个更长的数组，再把原来数组里的值复制到新数组里。</li>
<li>一种快速创建数组并初始化的方式是使用数组字面量。<code>array := [5]int&#123;10, 20, 30, 40, 50&#125;</code></li>
<li><strong>如果使用<code>...</code>替代数组的长度，Go 语言会根据初始化时数组元素的数量来确定该数组的长度。<code>array := [...]int&#123;10, 20, 30, 40, 50&#125;</code></strong></li>
<li><strong>声明数组并指定特定元素的值。<code>array := [5]int&#123;1: 10, 2: 20&#125;</code></strong></li>
<li>声明一个所有元素都是指针的数组。使用<code>*</code>运算符就可以访问元素指针所指向的值。</li>
<li>数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相同的数组，才能互相赋值。</li>
<li>声明二维数组<ul>
<li>声明一个二维整型数组，两个维度分别存储 4 个元素和 2 个元素：<code>var array [4][2]int</code></li>
<li>使用数组字面量来声明并初始化一个二维整型数组：<code>array := [4][2]int&#123;&#123;10, 11&#125;, &#123;20, 21&#125;, &#123;30, 31&#125;, &#123;40, 41&#125;&#125;</code></li>
<li>声明并初始化外层数组中索引为 1 个和 3 的元素：<code>array := [4][2]int&#123;1: &#123;20, 21&#125;, 3: &#123;40, 41&#125;&#125;</code></li>
<li>声明并初始化外层数组和内层数组的单个元素：<code>array := [4][2]int&#123;1: &#123;0: 20&#125;, 3: &#123;1: 41&#125;&#125;</code></li>
</ul>
</li>
<li>在函数之间传递变量时，总是以值的方式传递的。<strong>如果这个变量是一个数组，意味着整个数组，不管有多长，都会完整复制，并传递给函数。有一种更好且更有效的方法来处理这个操作。可以只传入指向数组的指针，这样只需要复制 8 字节的数据。</strong></li>
</ul>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><ul>
<li>切片是一种数据结构，这种数据结构便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。切片的动态增长是通过内置函数 append 来实现的。这个函数可以快速且高效地增长切片。还可以通过对切片再次切片来缩小一个切片的大小。因为切片的底层内存也是在连续块中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处。</li>
<li>切片是有 3 个字段的数据结构，分别是<strong>指向底层数组的指针、切片访问的元素的个数（即长度）和切片允许增长到的元素个数（即容量）。</strong><br><img src="http://pic.colliexyy.com/16456783729444.jpg"></li>
<li><strong>是否能提前知道切片需要的容量通常会决定要如何创建切片，频繁的复制移动底层数组会产生不必要的性能消耗。</strong></li>
<li>一种创建切片的方法是使用内置的 make 函数。当使用 make 时，需要传入一个参数，指定切片的长度。<code>slice := make([]string, 5)</code></li>
<li>如果只指定长度，那么切片的容量和长度相等。也可以分别指定长度和容量。<code>slice := make([]int, 3, 5)</code></li>
<li>不允许创建容量小于长度的切片。</li>
<li>另一种常用的创建切片的方法是使用切片字面量。初始的长度和容量会基于初始化时提供的元素的个数确定。<code>slice := []string&#123;&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;&#125;</code></li>
<li>当使用切片字面量时，可以设置初始长度和容量。要做的就是在初始化时给出所需的长度和容量作为索引。<code>slice := []string&#123;99: &quot;&quot;&#125;</code></li>
<li><strong>记住，如果在<code>[]</code>运算符里指定了一个值，包括<code>...</code>，那么创建的就是数组而不是切片。</strong></li>
<li>创建 <strong>nil 切片</strong>。<code>var slice []int</code><br><img src="http://pic.colliexyy.com/16456784619966.jpg"></li>
<li>利用初始化，通过声明一个切片可以创建一个<strong>空切片</strong>。<code>slice := make([]int, 0) 或 slice := []int&#123;&#125;</code><br> <img src="http://pic.colliexyy.com/16456784684067.jpg"></li>
<li>对切片里某个索引指向的元素赋值和对数组里某个索引指向的元素赋值的方法完全一样。使用<code>[]</code>操作符就可以改变某个元素的值。</li>
<li>切片之所以被称为切片，是因为创建一个新的切片就是把底层数组切出一部分。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 5 个元素</span></span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">// 创建一个新切片</span></span><br><span class="line"><span class="comment">// 其长度为 2 个元素，容量为 4 个元素</span></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><img src="http://pic.colliexyy.com/16456785047191.jpg"></p>
<ul>
<li>newSlice 无法访问到它所指向的底层数组的第一个元素之前的部分。</li>
<li>需要记住的是，现在<strong>两个切片共享同一个底层数组。如果一个切片修改了该底层数组的共享部分，另一个切片也能感知到。</strong></li>
<li>切片只能访问到其长度内的元素。试图访问超出其长度的元素将会导致语言运行时异常。</li>
<li>相对于数组而言，使用切片的一个好处是，可以按需增加切片的容量。</li>
<li>函数 append 总是会增加新切片的长度，而容量有可能会改变，也可能不会改变，这取决于被操作的切片的可用容量。</li>
<li>如果切片的底层数组没有足够的可用容量，append 函数会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值。</li>
<li>函数 append 会智能地处理底层数组的容量增长。<strong>在切片的容量小于 1000 个元素时，总是会成倍地增加容量。一旦元素个数超过 1000，容量的增长因子会设为 1.25，也就是会每次增加 25%的容量。</strong> 随着语言的演化，这种增长算法可能会有所改变。</li>
<li>第三个索引可以用来控制新切片的容量。其目的并不是要增加容量，而是要限制容量。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符串切片</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 5 个元素</span></span><br><span class="line">source := []<span class="type">string</span>&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Grape&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 将第三个元素切片，并限制容量</span></span><br><span class="line"><span class="comment">// 其长度为 1 个元素，容量为 2 个元素</span></span><br><span class="line">slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>]</span><br><span class="line"><span class="comment">// 对于 slice[i:j:k] 或 [2:3:4]</span></span><br><span class="line"><span class="comment">// 长度: j – i 或 3 * 2 = 1</span></span><br><span class="line"><span class="comment">// 容量: k – i 或 4 * 2 = 2</span></span><br></pre></td></tr></table></figure>

<p><img src="http://pic.colliexyy.com/16456785352268.jpg"></p>
<ul>
<li>如果试图设置的容量比可用的容量还大，就会得到一个语言运行时错误。</li>
<li><strong>如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个 append 操作创建新的底层数组，与原有的底层数组分离。新切片与原有的底层数组分离后，可以安全地进行后续修改。</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符串切片</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 5 个元素</span></span><br><span class="line">source := []<span class="type">string</span>&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Grape&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 对第三个元素做切片，并限制容量</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 1 个元素</span></span><br><span class="line">slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 向 slice 追加新字符串</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="string">&quot;Kiwi&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>内置函数 append 也是一个可变参数的函数。这意味着可以在一次调用传递多个追加的值。如果使用<code>...</code>运算符，可以将一个切片的所有元素追加到另一个切片里。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建两个切片，并分别用两个整数进行初始化</span></span><br><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">s2 := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// 将两个切片追加在一起，并显示结果</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="built_in">append</span>(s1, s2...))</span><br><span class="line">Output:</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>当迭代切片时，关键字 range 会返回两个值。第一个值是当前迭代到的索引位置，第二个值是该位置对应元素值的一份副本。range 创建了每个元素的副本，而不是直接返回对该元素的引用。</li>
<li>for range 迭代切片</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 4 个元素</span></span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line"><span class="comment">// 迭代每一个元素，并显示其值</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Index: %d Value: %d\n&quot;</span>, index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>传统 for 循环迭代切片</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片</span></span><br><span class="line"><span class="comment">// 其长度和容量都是 4 个元素</span></span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line"><span class="comment">// 从第三个元素开始迭代每个元素</span></span><br><span class="line"><span class="keyword">for</span> index := <span class="number">2</span>; index &lt; <span class="built_in">len</span>(slice); index++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Index: %d Value: %d\n&quot;</span>, index, slice[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>有两个特殊的内置函数 len 和 cap，可以用于处理数组、切片和通道。对于切片，函数 len 返回切片的长度，函数 cap 返回切片的容量。</li>
<li>多维切片</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片的切片</span></span><br><span class="line">slice := [][]<span class="type">int</span>&#123;&#123;<span class="number">10</span>&#125;, &#123;<span class="number">100</span>, <span class="number">200</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://pic.colliexyy.com/16456787227017.jpg"></p>
<ul>
<li>在函数间传递切片就是要在函数间以值的方式传递切片。由于切片的尺寸很小，在函数间复制和传递切片成本也很低。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配包含 100 万个整型值的切片</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1e6</span>)</span><br><span class="line"><span class="comment">// 将 slice 传递到函数 foo</span></span><br><span class="line">slice = foo(slice)</span><br><span class="line"><span class="comment">// 函数 foo 接收一个整型切片，并返回这个切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(slice []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>在 64 位架构的机器上，一个切片需要 24 字节的内存：指针字段需要 8 字节，长度和容量字段分别需要 8 字节。由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底层数组。</strong></li>
<li>在函数间传递 24 字节的数据会非常快速、简单。这也是切片效率高的地方。不需要传递指针和处理复杂的语法，只需要复制切片，按想要的方式修改数据，然后传递回一份新的切片副本。</li>
</ul>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p><img src="http://pic.colliexyy.com/16456787379595.jpg"></p>
<ul>
<li>映射里基于键来存储值。映射功能强大的地方是，能够<strong>基于键快速检索数据</strong>。键就像索引一样，指向与该键关联的值。</li>
<li><strong>映射是无序的集合。无序的原因是映射的实现使用了散列表。</strong></li>
<li>使用 make 声明映射</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个映射，键的类型是 string，值的类型是 int</span></span><br><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 创建一个映射，键和值的类型都是 string</span></span><br><span class="line"><span class="comment">// 使用两个键值对初始化映射</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;Red&quot;</span>: <span class="string">&quot;#da1337&quot;</span>, <span class="string">&quot;Orange&quot;</span>: <span class="string">&quot;#e95a22&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>映射的键可以是任何值。这个值的类型可以是内置的类型，也可以是结构类型，只要这个值可以使用&#x3D;&#x3D;运算符做比较。切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的键，使用这些类型会造成编译错误</li>
<li>声明一个存储字符串切片的映射。<code>dict := map[int][]string&#123;&#125;</code></li>
<li>空映射 &amp; 映射赋值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空映射，用来存储颜色以及颜色对应的十六进制代码</span></span><br><span class="line">colors := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 将 Red 的代码加入到映射</span></span><br><span class="line">colors[<span class="string">&quot;Red&quot;</span>] = <span class="string">&quot;#da1337&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>nil 映射</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过声明映射创建一个 nil 映射</span></span><br><span class="line"><span class="keyword">var</span> colors <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"><span class="comment">// 将 Red 的代码加入到映射</span></span><br><span class="line">colors[<span class="string">&quot;Red&quot;</span>] = <span class="string">&quot;#da1337&quot;</span></span><br><span class="line">Runtime Error:</span><br><span class="line"><span class="built_in">panic</span>: runtime <span class="type">error</span>: assignment to entry in <span class="literal">nil</span> <span class="keyword">map</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从映射获取值并判断键是否存在</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取键 Blue 对应的值</span></span><br><span class="line">value, exists := colors[<span class="string">&quot;Blue&quot;</span>]</span><br><span class="line"><span class="comment">// 这个键存在吗？</span></span><br><span class="line"><span class="keyword">if</span> exists &#123;</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>从映射获取值，并通过该值是否为对应类型的空值，从而判断键是否存在</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取键 Blue 对应的值</span></span><br><span class="line">value := colors[<span class="string">&quot;Blue&quot;</span>]</span><br><span class="line"><span class="comment">// 这个键存在吗？</span></span><br><span class="line"><span class="keyword">if</span> value != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 range 迭代映射</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个映射，存储颜色以及颜色对应的十六进制代码</span></span><br><span class="line">colors := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;AliceBlue&quot;</span>: <span class="string">&quot;#f0f8ff&quot;</span>,</span><br><span class="line"><span class="string">&quot;Coral&quot;</span>: <span class="string">&quot;#ff7F50&quot;</span>,</span><br><span class="line"><span class="string">&quot;DarkGray&quot;</span>: <span class="string">&quot;#a9a9a9&quot;</span>,</span><br><span class="line"><span class="string">&quot;ForestGreen&quot;</span>: <span class="string">&quot;#228b22&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显示映射里的所有颜色</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> colors &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Key: %s Value: %s\n&quot;</span>, key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果想把一个键值对从映射里删除，就使用内置的 delete 函数。<code>delete(colors, &quot;Coral&quot;)</code></li>
<li><strong>在函数间传递映射并不会制造出该映射的一个副本。实际上，当传递映射给一个函数，并对这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改。</strong></li>
</ul>
<h2 id="本章小结-3"><a href="#本章小结-3" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>数组是构造切片和映射的基石。</li>
<li>Go 语言里切片经常用来处理数据的集合，映射用来处理具有键值对结构的数据。</li>
<li>内置函数 make 可以创建切片和映射，并指定原始的长度和容量。也可以直接使用切片和映射字面量，或者使用字面量作为变量的初始值。</li>
<li>切片有容量限制，不过可以使用内置的 append 函数扩展容量。</li>
<li>映射的增长没有容量或者任何限制。</li>
<li>内置函数 len 可以用来获取切片或者映射的长度。</li>
<li>内置函数 cap 只能用于切片。</li>
<li>通过组合，可以创建多维数组和多维切片。也可以使用切片或者其他映射作为映射的值。但是切片不能用作映射的键。</li>
<li><strong>将切片或者映射传递给函数成本很小，并且不会复制底层的数据结构。</strong></li>
</ul>
<h1 id="第-5-章：Go-语言的类型系统"><a href="#第-5-章：Go-语言的类型系统" class="headerlink" title="第 5 章：Go 语言的类型系统"></a>第 5 章：Go 语言的类型系统</h1><h2 id="本章主要内容-4"><a href="#本章主要内容-4" class="headerlink" title="本章主要内容"></a>本章主要内容</h2><ul>
<li><p>声明新的用户定义的类型</p>
</li>
<li><p>使用方法，为类型增加新的行为</p>
</li>
<li><p>了解何时使用指针，何时使用值</p>
</li>
<li><p>通过接口实现多态</p>
</li>
<li><p>通过组合来扩展或改变类型</p>
</li>
<li><p>公开或者未公开的标识符</p>
</li>
<li><p><strong>Go 语言是一种静态类型的编程语言。这意味着，编译器需要在编译时知晓程序里每个值的类型。</strong></p>
</li>
<li><p>一个 int 值的大小可能是 8 字节（64 位），也可能是 4 字节（32 位）。</p>
</li>
<li><p>当用户声明一个新类型时，这个声明就给编译器提供了一个框架，告知必要的内存大小和表示信息。</p>
</li>
<li><p>结构里每个字段都会用一个已知类型声明。这个已知类型可以是内置类型，也可以是其他用户定义的类型。<br><img src="http://pic.colliexyy.com/16456789214463.jpg"><br><img src="http://pic.colliexyy.com/16456789279256.jpg"></p>
</li>
<li><p><strong>任何时候，创建一个变量并初始化为其零值，习惯是使用关键字 var。</strong></p>
</li>
<li><p><strong>一个短变量声明操作符在一次操作中完成两件事情：声明一个变量，并初始化。</strong><br><img src="http://pic.colliexyy.com/16456789448794.jpg"><br><img src="http://pic.colliexyy.com/16456789501715.jpg"><br><img src="http://pic.colliexyy.com/16456789562770.jpg"></p>
</li>
<li><p>基于一个已有的类型，将其作为新类型的类型说明。<code>type Duration int64</code>（虽然 int64 是基础类型，Go 并不认为 Duration 和 int64 是同一种类型。）</p>
</li>
<li><p>关键字 func 和函数名之间的参数被称作接收者，将函数与接收者的类型绑在一起。如果一个函数有接收者，这个函数就被称为方法。</p>
</li>
<li><p>Go 语言里有两种类型的接收者：值接收者和指针接收者。</p>
</li>
<li><p>值接受者</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> notify() &#123;</span><br><span class="line">    <span class="comment">// 使用值来调用</span></span><br><span class="line">    bill := user&#123;<span class="string">&quot;Bill&quot;</span>, <span class="string">&quot;bill@email.com&quot;</span>&#125;</span><br><span class="line">    bill.notify()</span><br><span class="line">    <span class="comment">// 使用值的指针来调用，这时候操作的仍然是值的副本</span></span><br><span class="line">    lisa := &amp;user&#123;<span class="string">&quot;Lisa&quot;</span>, <span class="string">&quot;lisa@email.com&quot;</span>&#125;</span><br><span class="line">    lisa.notify()  <span class="comment">// Go背后执行的操作实际是：(*lisa).notify()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>指针接收者</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> changeEmail(email <span class="type">string</span>) &#123;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>当调用使用指针接收者声明的方法时，这个方法会共享调用方法时接收者所指向的值</strong><br><img src="http://pic.colliexyy.com/16456790245075.jpg"></li>
<li><strong>值接收者使用值的副本来调用方法，而指针接受者使用实际值来调用方法。</strong></li>
<li><strong>也可以使用一个值来调用使用指针接收者声明的方法</strong><br><img src="http://pic.colliexyy.com/16456790474052.jpg"><br><img src="http://pic.colliexyy.com/16456790285047.jpg"></li>
<li>如果给这个类型增加或者删除某个值，是要创建一个新的值，还是要更改当前的值？<strong>如果是要创建一个新值，该类型的方法就使用值接收者。如果是要修改当前值，就使用指针接收者。</strong></li>
<li>内置类型是由语言提供的一组类型。我们已经见过这些类型，分别是数值类型、字符串类型和布尔类型。</li>
<li>Go 语言里的引用类型有如下几个：切片、映射、通道、接口和函数类型。</li>
<li><strong>是使用值接收者还是指针接收者，不应该由该方法是否修改了接收到的值来决定。这个决策应该基于该类型的本质。</strong></li>
<li>这条规则的一个例外是，需要让类型值符合某个接口的时候，即便类型的本质是非原始本质的，也可以选择使用值接收者声明方法。这样做完全符合接口值调用方法的机制。</li>
<li>接口</li>
<li>多态是指代码可以根据类型的具体实现采取不同行为的能力。如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值。</li>
<li><strong>接口值是一个两个字长度的数据结构，第一个字包含一个指向内部表的指针。这个内部表叫作 iTable，包含了所存储的值的类型信息。iTable 包含了已存储的值的类型信息以及与这个值相关联的一组方法。第二个字是一个指向所存储值的指针。</strong> 将类型信息和指针组合在一起，就将这两个值组成了一种特殊的关系。<br><img src="http://pic.colliexyy.com/16456790805527.jpg"><br><img src="http://pic.colliexyy.com/16456790845095.jpg"></li>
<li>方法集定义了一组关联到给定类型的值或者指针的方法。定义方法时使用的接收者的类型决定了这个方法是关联到值，还是关联到指针，还是两个都关联。</li>
<li><strong>如果使用指针接收者来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。如果使用值接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。</strong></li>
<li>为什么会有这种限制？事实上，编译器并不是总能自动获得一个值的地址。</li>
</ul>
<h2 id="多态：嵌入类型"><a href="#多态：嵌入类型" class="headerlink" title="多态：嵌入类型"></a>多态：嵌入类型</h2><ul>
<li>Go 语言允许用户扩展或者修改已有类型的行为。这个功能对代码复用很重要，在修改已有类型以符合新类型的时候也很重要。这个功能是通过嵌入类型（type embedding）完成的。嵌入类型是将已有的类型直接声明在新的结构类型里。被嵌入的类型被称为新的外部类型的内部类型。</li>
<li>通过嵌入类型，与内部类型相关的标识符会提升到外部类型上。这些被提升的标识符就像直接声明在外部类型里的标识符一样，也是外部类型的一部分。这样外部类型就组合了内部类型包含的所有属性，并且可以添加新的字段和方法。<strong>外部类型也可以通过声明与内部类型标识符同名的标识符来覆盖内部标识符的字段或者方法。这就是扩展或者修改已有类型的方法。</strong></li>
<li>要嵌入一个类型，只需要声明这个类型的名字就可以了。</li>
<li>一旦我们将 user 类型嵌入 admin，我们就可以说 user 是外部类型 admin 的内部类型。有了内部类型和外部类型这两个概念，就能更容易地理解这两种类型之间的关系。</li>
<li><strong>虽然没有指定内部类型对应的字段名，还是可以使用内部类型的类型名，来访问到内部类型的值。<code>ad.user.notify()</code></strong></li>
<li>由于内部类型的标识符提升到了外部类型，我们可以直接通过外部类型的值来访问内部类型的标识符。</li>
<li>由于内部类型的提升，内部类型实现的接口会自动提升到外部类型。这意味着由于内部类型的实现，外部类型也同样实现了这个接口。<code>ad.notify()</code></li>
<li>如果外部类型实现了 notify 方法，内部类型的实现就不会被提升。不过内部类型的值一直存在，因此还可以通过直接访问内部类型的值，来调用没有被提升的内部类型实现的方法。</li>
</ul>
<h2 id="公开和未公开标识符"><a href="#公开和未公开标识符" class="headerlink" title="公开和未公开标识符"></a>公开和未公开标识符</h2><ul>
<li>要想设计出好的 API，需要使用某种规则来控制声明后的标识符的可见性。</li>
<li>当一个标识符的名字以小写字母开头时，这个标识符就是未公开的，即包外的代码不可见。如果一个标识符以大写字母开头，这个标识符就是公开的，即被包外的代码可见。</li>
<li><strong>将工厂函数命名为 New 是 Go 语言的一个习惯。</strong></li>
<li>New 函数创建了一个未公开的类型的值，并将这个值返回给调用者。</li>
<li>第一，公开或者未公开的标识符，不是一个值。第二，短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量。</li>
<li>永远不能显式创建一个未公开的类型的变量，不过短变量声明操作符可以这么做。</li>
<li><strong>即便内部类型是未公开的，内部类型里声明的字段依旧是公开的。既然内部类型的标识符提升到了外部类型，这些公开的字段也可以通过外部类型的字段的值来访问。</strong></li>
</ul>
<h2 id="本章小结-4"><a href="#本章小结-4" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>使用关键字 struct 或者通过指定已经存在的类型，可以声明用户定义的类型。</li>
<li>方法提供了一种给用户定义的类型增加行为的方式。</li>
<li><u><strong>设计类型时需要确认类型的本质是原始的，还是非原始的。</strong></u></li>
<li>接口是声明了一组行为并支持多态的类型。</li>
<li>嵌入类型提供了扩展类型的能力，而无需使用继承。</li>
<li>标识符要么是从包里公开的，要么是在包里未公开的。</li>
</ul>
<h1 id="第-6-章：并发"><a href="#第-6-章：并发" class="headerlink" title="第 6 章：并发"></a>第 6 章：并发</h1><h2 id="本章主要内容-5"><a href="#本章主要内容-5" class="headerlink" title="本章主要内容"></a>本章主要内容</h2><ul>
<li>使用 goroutine 运行程序</li>
<li>检测并修正竞争状态</li>
<li>利用通道共享数据</li>
<li>Go 语言里的并发指的是能让某个函数独立于其他函数运行的能力。</li>
<li><strong>Go 语言的并发同步模型来自一个叫作通信顺序进程（Communicating Sequential Processes，CSP）的范型（paradigm）。</strong></li>
<li><strong>CSP 是一种消息传递模型，通过在 goroutine 之间传递数据来传递消息，而不是对数据进行加锁来实现同步访问。</strong></li>
<li>用于在 goroutine 之间同步和传递数据的关键数据类型叫作通道（channel）。</li>
<li>使用通道可以使编写并发程序更容易，也能够让并发程序出错更少。</li>
<li>什么是操作系统的线程（thread）和进程（process）？<ul>
<li><strong>进程可以看作一个包含了应用程序在运行中需要用到和维护的各种资源的容器。</strong> 这些资源包括但不限于内存地址空间、文件和设备的句柄以及线程。</li>
<li><strong>一个线程是一个执行空间，这个空间会被操作系统调度来运行函数中所写的代码。</strong></li>
<li><strong>每个进程至少包含一个线程，每个进程的初始线程被称作主线程。</strong> 因为执行这个线程的空间是应用程序的本身的空间，所以当主线程终止时，应用程序也会终止。</li>
<li><strong>操作系统会在物理处理器上调度线程来运行，而 Go 语言的运行时会在逻辑处理器上调度 goroutine 来运行。</strong></li>
</ul>
</li>
<li>1.5 版本上，Go 语言的运行时默认会为每个可用的物理处理器分配一个逻辑处理器。</li>
<li>如果创建一个 goroutine 并准备运行，这个 goroutine 就会被放到调度器的全局运行队列中。之后，调度器就将这些队列中的 goroutine 分配给一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列中。本地运行队列中的 goroutine 会一直等待直到自己被分配的逻辑处理器执行。<br><img src="http://pic.colliexyy.com/16456792126348.jpg"></li>
<li>如果一个 goroutine 需要做一个网络 I&#x2F;O 调用，流程上会有些不一样。在这种情况下，goroutine 会和逻辑处理器分离，并移到集成了网络轮询器的运行池。一旦该轮询器指示某个网络读或者写操作已经就绪，对应的 goroutine 就会重新分配到逻辑处理器上来完成操作。</li>
<li>并发（concurrency）不是并行（parallelism）。<br><img src="http://pic.colliexyy.com/16456792372571.jpg"></li>
<li><strong>并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。</strong> 在很多情况下，并发的效果比并行好，因为操作系统和硬件的总资源一般很少，但能支持系统同时做很多事情。</li>
<li>如果希望让 goroutine 并行，必须使用多于一个逻辑处理器。当有多个逻辑处理器时，调度器会将 goroutine 平等分配到每个逻辑处理器上。这会让 goroutine 在不同的线程上运行。</li>
<li>不过要想真的实现并行的效果，用户需要让自己的程序运行在有多个物理处理器的机器上。否则，哪怕 Go 语言运行时使用多个线程，goroutine 依然会在同一个物理处理器上并发运行，达不到并行的效果。</li>
</ul>
<h2 id="goroutines"><a href="#goroutines" class="headerlink" title="goroutines"></a>goroutines</h2><ul>
<li>调用了 runtime 包的 GOMAXPROCS 函数。这个函数允许程序更改调度器可以使用的逻辑处理器的数量。如果不想在代码里做这个调用，也可以通过修改和这个函数名字一样的环境变量的值来更改逻辑处理器的数量。</li>
<li>WaitGroup 是一个计数信号量，可以用来记录并维护运行的 goroutine。</li>
<li>如果 WaitGroup 的值大于 0，Wait 方法就会阻塞。</li>
<li>关键字 defer 会修改函数调用时机，在正在执行的函数返回时才真正调用 defer 声明的函数。</li>
<li>当 goroutine 占用时间过长时，调度器会停止当前正运行的 goroutine，并给其他可运行的 goroutine 运行的机会。<br><img src="http://pic.colliexyy.com/16456792583487.jpg"></li>
<li>给每个可用的核心分配一个逻辑处理器 <code>runtime.GOMAXPROCS(runtime.NumCPU())</code></li>
<li>需要强调的是，使用多个逻辑处理器并不意味着性能更好。在修改任何语言运行时配置参数的时候，都需要配合基准测试来评估程序的运行效果。</li>
<li>记住，只有在有多个逻辑处理器且可以同时让每个 goroutine 运行在一个可用的物理处理器上的时候，goroutine 才会并行运行。</li>
</ul>
<h2 id="竞争状态"><a href="#竞争状态" class="headerlink" title="竞争状态"></a>竞争状态</h2><ul>
<li>如果两个或者多个 goroutine 在没有互相同步的情况下，访问某个共享的资源，并试图同时读和写这个资源，就处于相互竞争的状态，这种情况被称作竞争状态（race candition）。</li>
<li><strong>对一个共享资源的读和写操作必须是原子化的，换句话说，同一时刻只能有一个 goroutine 对共享资源进行读和写操作。</strong></li>
<li><strong>当前 goroutine 从线程退出，并放回到队列：<code>runtime.Gosched()</code></strong></li>
<li><code>go build -race</code>可以在代码里检测竞争状态。在查找这类错误的时候，这个工具非常好用，尤其是在竞争状态并不像这个例子里这么明显的时候。</li>
<li>一种修正代码、消除竞争状态的办法是，使用 Go 语言提供的锁机制，来锁住共享资源，从而保证 goroutine 的同步状态。</li>
</ul>
<h2 id="锁住共享资源"><a href="#锁住共享资源" class="headerlink" title="锁住共享资源"></a>锁住共享资源</h2><ul>
<li>如果需要顺序访问一个整型变量或者一段代码，atomic 和 sync 包里的函数提供了很好的解决方案。</li>
<li>原子函数能够以很底层的加锁机制来同步访问整型变量和指针。<ul>
<li><strong>atmoic 包的 AddInt64 函数会同步整型值的加法，方法是强制同一时刻只能有一个 goroutine 运行并完成这个加法操作。</strong> 当 goroutine 试图去调用任何原子函数时，这些 goroutine 都会自动根据所引用的变量做同步处理。</li>
<li><strong>另外两个有用的原子函数是 LoadInt64 和 StoreInt64。这两个函数提供了一种安全地读和写一个整型值的方式。</strong></li>
<li>原子函数会将这些读写调用互相同步，保证这些操作都是安全的，不会进入竞争状态。</li>
</ul>
</li>
<li>另一种同步访问共享资源的方式是使用互斥锁（mutex）。<ul>
<li><strong>互斥锁用于在代码上创建一个临界区，保证同一时间只有一个 goroutine 可以执行这个临界区代码。</strong></li>
<li>同一时刻只有一个 goroutine 可以进入临界区。之后，直到调用 Unlock()函数之后，其他 goroutine 才能进入临界区。</li>
</ul>
</li>
</ul>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><ul>
<li>原子函数和互斥锁都能工作，但是依靠它们都不会让编写并发程序变得更简单，更不容易出错，或者更有趣。</li>
<li>当一个资源需要在 goroutine 之间共享时，通道在 goroutine 之间架起了一个管道，并提供了确保同步交换数据的机制。</li>
<li>声明通道时，需要指定将要被共享的数据的类型。</li>
<li>可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。</li>
<li><strong>使用 make 创建通道。make 的第一个参数需要是关键字 chan，之后跟着允许通道交换的数据的类型。</strong><br><img src="http://pic.colliexyy.com/16456793372822.jpg"></li>
<li>向通道发送值或者指针需要用到&lt;-操作符<br><img src="http://pic.colliexyy.com/16456793486607.jpg"><br><img src="http://pic.colliexyy.com/16456793524862.jpg"></li>
<li><strong>无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。</strong> 如果两个 goroutine 没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。<br><img src="http://pic.colliexyy.com/16456793684336.jpg"></li>
<li><strong>有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。</strong> 这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。</li>
<li>有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。<br><img src="http://pic.colliexyy.com/16456793791903.jpg"></li>
<li>当<strong>通道关闭后，goroutine 依旧可以从通道接收数据，但是不能再向通道里发送数据。</strong> 能够从已经关闭的通道接收数据这一点非常重要，因为这允许通道关闭后依旧能取出其中缓冲的全部值，而不会有数据丢失。<strong>从一个已经关闭且没有数据的通道里获取数据，总会立刻返回，并返回一个通道类型的零值。</strong></li>
</ul>
<h2 id="本章小结-5"><a href="#本章小结-5" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>并发是指 goroutine 运行的时候是相互独立的。</li>
<li>使用关键字 go 创建 goroutine 来运行函数。</li>
<li><strong>goroutine 在逻辑处理器上执行，而逻辑处理器具有独立的系统线程和运行队列。</strong></li>
<li>竞争状态是指两个或者多个 goroutine 试图访问同一个资源。</li>
<li>原子函数和互斥锁提供了一种防止出现竞争状态的办法。</li>
<li>通道提供了一种在两个 goroutine 之间共享数据的简单方法。</li>
<li><strong>无缓冲的通道保证同时交换数据，而有缓冲的通道不做这种保证。</strong></li>
</ul>
<h1 id="第-7-章：并发模式"><a href="#第-7-章：并发模式" class="headerlink" title="第 7 章：并发模式"></a>第 7 章：并发模式</h1><h2 id="本章主要内容-6"><a href="#本章主要内容-6" class="headerlink" title="本章主要内容"></a>本章主要内容</h2><ul>
<li>控制程序的生命周期</li>
<li>管理可复用的资源池</li>
<li>创建可以处理任务的 goroutine 池</li>
</ul>
<h2 id="runner"><a href="#runner" class="headerlink" title="runner"></a>runner</h2><ul>
<li><strong>runner 包用于展示如何使用通道来监视程序的执行时间，如果程序运行时间太长，也可以用 runner 包来终止程序。</strong> 当开发需要调度后台处理任务的程序的时候，这种模式会很有用。这个程序可能会作为 cron 作业执行，或者在基于定时任务的云环境（如 iron.io）里执行。<br><img src="http://pic.colliexyy.com/16456794334532.jpg"></li>
<li>在设计上，可支持以下终止点：<br>_ 程序可以在分配的时间内完成工作，正常终止；<br>_ 程序没有及时完成工作，“自杀”； * 接收到操作系统发送的中断事件，程序立刻试图清理状态并停止工作。<br><img src="http://pic.colliexyy.com/16456794506167.jpg"></li>
<li>通道 interrupt 被初始化为缓冲区容量为 1 的通道。这可以保证通道至少能接收一个来自语言运行时的 os.Signal 值，确保语言运行时发送这个事件的时候不会被阻塞。如果 goroutine 没有准备好接收这个值，这个值就会被丢弃。</li>
<li>通道 complete 被初始化为无缓冲的通道。当执行任务的 goroutine 完成时，会向这个通道发送一个 error 类型的值或者 nil 值。之后就会等待 main 函数接收这个值。一旦 main 接收了这个 error 值，goroutine 就可以安全地终止了。</li>
<li>最后一个通道 timeout 是用 time 包的 After 函数初始化的。After 函数返回一个 time.Time 类型的通道。语言运行时会在指定的 duration 时间到期之后，向这个通道发送一个 time.Time 的值。</li>
<li>task 字段的零值是 nil，已经满足初始化的要求，所以没有被明确初始化。</li>
<li>可变参数可以接受任意数量的值作为传入参数。</li>
<li>方法 gotInterrupt 展示了带 default 分支的 select 语句的经典用法。<br><img src="http://pic.colliexyy.com/16456794746728.jpg"></li>
<li>代码试图从 interrupt 通道去接收信号。一般来说，select 语句在没有任何要接收的数据时会阻塞，不过有了第 98 行的 default 分支就不会阻塞了。default 分支会将接收 interrupt 通道的阻塞调用转变为非阻塞的。如果 interrupt 通道有中断信号需要接收，就会接收并处理这个中断。如果没有需要接收的信号，就会执行 default 分支。</li>
<li>方法 Start 实现了程序的主流程。<br><img src="http://pic.colliexyy.com/16456794874952.jpg"></li>
</ul>
<h2 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h2><ul>
<li>本章会介绍 pool 包。在 Go 1.6 及之后的版本中，标准库里自带了资源池的实现（sync.Pool）。推荐使用。</li>
<li>这个包用于展示如何使用有缓冲的通道实现资源池，来管理可以在任意数量的 goroutine 之间共享及独立使用的资源。这种模式在需要共享一组静态资源的情况（如共享数据库连接或者内存缓冲区）下非常有用。如果 goroutine 需要从池里得到这些资源中的一个，它可以从池里申请，使用完后归还到资源池里。</li>
<li>Pool 的结构允许调用者根据所需数量创建不同的资源池。只要某类资源实现了 io.Closer 接口，就可以用这个资源池来管理。<br><img src="http://pic.colliexyy.com/16456795142159.jpg"></li>
<li>sync.Mutex 类型的互斥锁用来保证在多个 goroutine 访问资源池时，池内的值是安全的。</li>
<li>resources 字段被声明为 io.Closer 接口类型的通道。这个通道是作为一个有缓冲的通道创建的，用来保存共享的资源。由于通道的类型是一个接口，所以池可以管理任意实现了 io.Closer 接口的资源类型。</li>
<li>factory 字段是一个函数类型。任何一个没有输入参数且返回一个 io.Closer 和一个 error 接口值的函数，都可以赋值给这个字段。这个函数的目的是，当池需要一个新资源时，可以用这个函数创建。这个函数的实现细节超出了 pool 包的范围，并且需要由包的使用者实现并提供。</li>
<li>closed 字段是一个标志，表示 Pool 是否已经被关闭。</li>
<li>Go 语言里会经常创建 error 接口变量。这可以让调用者来判断某个包里的函数或者方法返回的具体的错误值（如果可能存在多种错误值的情况下。）。</li>
<li>Acquire 方法在还有可用资源时会从资源池里返回一个资源，否则会为该调用创建并返回一个新的资源。</li>
<li>一旦程序不再使用资源池，需要调用这个资源池的 Close 方法。在同一时刻只能有一个 goroutine 执行这段代码。事实上，当这段代码被执行时，必须保证其他 goroutine 中没有同时执行 Release 方法。</li>
<li>Release 方法的任务是如果不再需要已经获得的资源，必须将这个资源释放回资源池里。和 Close 方法中的互斥量是同一个互斥量。这样可以阻止这两个方法在不同 goroutine 里同时运行。</li>
<li>唯一标识是通过 atomic.AddInt32 函数生成的。这个函数可以安全地增加包级变量 idCounter 的值。</li>
</ul>
<h2 id="work"><a href="#work" class="headerlink" title="work"></a>work</h2><ul>
<li>work 包的目的是展示如何使用无缓冲的通道来创建一个 goroutine 池，这些 goroutine 执行并控制一组工作，让其并发执行。</li>
<li>在这种情况下，使用无缓冲的通道要比随意指定一个缓冲区大小的有缓冲的通道好，因为这个情况下既不需要一个工作队列，也不需要一组 goroutine 配合执行。</li>
<li>无缓冲的通道保证两个 goroutine 之间的数据交换。</li>
<li>这种使用无缓冲的通道的方法允许使用者知道什么时候 goroutine 池正在执行工作，而且如果池里的所有 goroutine 都忙，无法接受新的工作的时候，也能及时通过通道来通知调用者。</li>
<li>使用无缓冲的通道不会有工作在队列里丢失或者卡住，所有工作都会被处理。<br><img src="http://pic.colliexyy.com/16456795522106.jpg"></li>
<li>work 包的工厂函数<br><img src="http://pic.colliexyy.com/16456795648957.jpg"></li>
<li>代码展示了 New 函数，这个函数使用固定数量的 goroutine 来创建一个工作池。goroutine 的数量作为参数传给 New 函数。</li>
<li>在第 22 行，创建了一个 Pool 类型的值，并使用无缓冲的通道来初始化 work 字段。</li>
<li>之后，在第 26 行，初始化 WaitGroup 需要等待的数量，并在第 27 行到第 34 行，创建了同样数量的 goroutine。</li>
<li>这些 goroutine 只接收 Worker 类型的接口值，并调用这个值的 Task 方法。</li>
<li>代码清单 7-31 里的 for range 循环会一直阻塞，直到从 work 通道收到一个 Worker 接口值。</li>
<li>如果收到一个值，就会执行这个值的 Task 方法。一旦 work 通道被关闭（所有任务结束后，在 shutdown 中关闭），for range 循环就会结束，并调用 WaitGroup 的 Done 方法。然后 goroutine 终止。<br><img src="http://pic.colliexyy.com/16456795776727.jpg"></li>
<li>Shutdown 方法做了两件事，首先，它关闭了 work 通道，这会导致所有池里的 goroutine 停止工作，并调用 WaitGroup 的 Done 方法；然后，Shutdown 方法调用 WaitGroup 的 Wait 方法，这会让 Shutdown 方法等待所有 goroutine 终止。</li>
</ul>
<h2 id="本章小结-6"><a href="#本章小结-6" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>可以使用通道来控制程序的生命周期。</li>
<li><strong>带 default 分支的 select 语句可以用来尝试向通道发送或者接收数据，而不会阻塞。</strong></li>
<li><strong>有缓冲的通道可以用来管理一组可复用的资源。</strong></li>
<li>语言运行时会处理好通道的协作和同步。</li>
<li><strong>使用无缓冲的通道来创建完成工作的 goroutine 池。</strong></li>
<li>任何时间都可以用无缓冲的通道来让两个 goroutine 交换数据，在通道操作完成时一定保证对方接收到了数据。</li>
</ul>
<h1 id="第-8-章：标准库"><a href="#第-8-章：标准库" class="headerlink" title="第 8 章：标准库"></a>第 8 章：标准库</h1><h2 id="本章主要内容-7"><a href="#本章主要内容-7" class="headerlink" title="本章主要内容"></a>本章主要内容</h2><ul>
<li>输出数据以及记录日志</li>
<li>对 JSON 进行编码和解码</li>
<li>处理输入&#x2F;输出，并以流的方式处理数据</li>
<li>让标准库里多个包协同工作</li>
<li>Go 标准库是一组核心包，用来扩展和增强语言的能力。这些包为语言增加了大量不同的类型。开发人员可以直接使用这些类型，而不用再写自己的包或者去下载其他人发布的第三方包。</li>
<li>标准库本身是经过良好设计的，并且比其他语言的标准库提供了更多的功能。</li>
</ul>
<h2 id="文档与源代码"><a href="#文档与源代码" class="headerlink" title="文档与源代码"></a>文档与源代码</h2><p><img src="http://pic.colliexyy.com/16456796242116.jpg"></p>
<ul>
<li>不管用什么方式安装 Go，标准库的源代码都会安装在$GOROOT&#x2F;src&#x2F;pkg 文件夹中。</li>
<li>作为 Go 发布包的一部分，标准库的源代码是经过预编译的。这些预编译后的文件，称作归档文件（archive file）。可以 在$GOROOT&#x2F;pkg 文件夹中找到已经安装的各目标平台和操作系统的归档文件。</li>
<li>归档文件是特殊的 Go 静态库文件，由 Go 的构建工具创建，并在编译和链接最终程序时被使用。归档文件可以让构建的速度更快。</li>
</ul>
<h2 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h2><ul>
<li>日志是开发人员的眼睛和耳朵，可以用来跟踪、调试和分析代码。</li>
<li>标准库提供了 log 包，可以对日志做一些最基本的配置。根据特殊需要，开发人员还可以自己定制日志记录器。</li>
<li>传统的 CLI（命令行界面）程序直接将输出写到名为 stdout 的设备上。</li>
<li>stderr 设备被创建为日志的默认目的地。</li>
<li>如果用户的程序只记录日志，没有程序输出，更常用的方式是将一般的日志信息写到 stdout，将错误或者警告信息写到 stderr。</li>
<li><strong>通常程序会在 init()函数里配置日志参数，这样程序一开始就能使用 log 包进行正确的输出。</strong></li>
<li>有几个和 log 包相关联的标志，这些标志用来控制可以写到每个日志项的其他信息。<br><img src="http://pic.colliexyy.com/16456796486532.jpg"></li>
<li>关键字 iota 在常量声明区里有特殊的作用。这个关键字让编译器为每个常量复制相同的表达式，直到声明区结束，或者遇到一个新的赋值语句。关键字 iota 的另一个功能是，iota 的初始值为 0，之后 iota 的值在每次处理为常量后，都会自增 1。<br><img src="http://pic.colliexyy.com/16456796565200.jpg"></li>
<li>Fatal 系列函数用来写日志消息，然后使用 os.Exit(1)终止程序。</li>
<li>Panic 系列函数用来写日志消息，然后触发一个 panic。除非程序执行 recover 函数，否则会导致程序打印调用栈后终止。</li>
<li>Print 系列函数是写日志消息的标准方法。</li>
<li>log 包有一个很方便的地方就是，这些日志记录器是多 goroutine 安全的。这意味着在多个 goroutine 可以同时调用来自同一个日志记录器的这些函数，而不 会有彼此间的写冲突。</li>
</ul>
<h2 id="定制的日志记录器"><a href="#定制的日志记录器" class="headerlink" title="定制的日志记录器"></a>定制的日志记录器</h2><ul>
<li>要想创建一个定制的日志记录器，需要创建一个 Logger 类型值。可以给每个日志记录器配置一个单独的目的地，并独立设置其前缀和标志。<br><img src="http://pic.colliexyy.com/16456796876518.jpg"></li>
<li>为了创建每个日志记录器，我们使用了 log 包的 New 函数，它创建并正确初始化一个 Logger 类型的值。<br><img src="http://pic.colliexyy.com/16456797022738.jpg"></li>
<li>当某个等级的日志不重要时，使用 Discard 变量可以禁用这个等级的日志。</li>
<li><strong>MultiWriter 函数是一个变参函数，可以接受任意个实现了 io.Writer 接口的值。这个函数会返回一个 io.Writer 值，这个值会把所有传入的 io.Writer 的值绑在一起。当对这个返回值进行写入时，会向所有绑在一起的 io.Writer 值做写入。</strong></li>
<li>Logger 类型实现的所有方法<br><img src="http://pic.colliexyy.com/16456796908521.jpg"></li>
</ul>
<h2 id="编码-x2F-解码"><a href="#编码-x2F-解码" class="headerlink" title="编码&#x2F;解码"></a>编码&#x2F;解码</h2><ul>
<li>如果程序需要处理 XML 或者 JSON，可以使用标准库里名为 xml 和 json 的包，它们可以处理这些格式的数据。</li>
<li>在今天，JSON 远比 XML 流行。这主要是因为与 XML 相比，使用 JSON 需要处理的标签更少。而这就意味着网络传输时每个消息的数据更少，从而提升整个系统的性能。而且，JSON 可以转换为 BSON（Binary JavaScript Object Notation，二进制 JavaScript 对象标记），进一步缩小每个消息的数据长度。<br><img src="http://pic.colliexyy.com/16456797308594.jpg"></li>
<li>每个字段最后使用单引号声明了一个字符串。这些字符串被称作标签（tag），是提供每个字段的元信息的一种机制，将 JSON 文档和结构类型里的字段一一映射起来。</li>
<li>如果不存在标签，编码和解码过程会试图以大小写无关的方式，直接使用字段的名字进行匹配。如果无法匹配，对应的结构类型里的字段就包含其零值。</li>
<li>Decode 方法接受一个 interface{} 类型的值做参数，并返回一个 error 值。任何类型都实现了一个空接口 interface{}。这意味着 Decode 方法可以接受任意类型的值。使用反射，Decode 方法会拿到传入值的类型信息。然后，在读取 JSON 响应的过程中，Decode 方法会将对应的响应解码为这个类型的值。</li>
<li><strong>有时，需要处理的 JSON 文档会以 string 的形式存在。在这种情况下，需要将 string 转换为 byte 切片（[]byte），并使用 json 包的 Unmarshal 函数进行反序列化的处理。</strong></li>
<li>有时，无法为 JSON 的格式声明一个结构类型，而是需要更加灵活的方式来处理 JSON 文档。在这种情况下，可以将 JSON 文档解码到一个 map 变量中。</li>
<li>变量 c 声明为一个 map 类型，其键是 string 类型，其值是 interface{} 类型。这意味着这个 map 类型可以使用任意类型的值作为给定键的值。var c map[string]interface{}</li>
<li>展示了如何将 contact 键的值转换为另一个键是 string 类型，值是 interface{} 类型的 map 类型。<br><img src="http://pic.colliexyy.com/16456797524566.jpg"></li>
<li>使用 json 包的 MarshalIndent 函数进行编码。这个函数可以很方便地将 Go 语言的 map 类型的值或者结构类型的值转换为易读格式的 JSON 文档。</li>
<li>序列化（marshal）是指将数据转换为 JSON 字符串的过程。</li>
</ul>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><ul>
<li><strong>类 UNIX 的操作系统如此伟大的一个原因是，一个程序的输出可以是另一个程序的输入这一理念。</strong> 依照这个哲学，这类操作系统创建了一系列的简单程序，每个程序只做一件事，并把这件事做得非常好。之后，将这些程序组合在一起，可以创建一些脚本做一些很惊艳的事情。这些程序使用 stdin 和 stdout 设备作为通道，在进程之间传递数据。</li>
<li>与 stdout 和 stdin 对应，这个包含有 io.Writer 和 io.Reader 两个接口。</li>
<li>所有实现了这两个接口的类型的值，都可以使用 io 包提供的所有功能，也可以用于其他包里接受这两个接口的函数以及方法。这是用接口类型来构造函数和 API 最美妙的地方。</li>
<li>由于 io.Writer 和 io.Reader 提供了足够的抽象，这些 io 包里的函数和方法并不知道数据的类型，也不知道这些数据在物理上是如何读和写的。<br><img src="http://pic.colliexyy.com/16456798193068.jpg"><br><img src="http://pic.colliexyy.com/16456798231494.jpg"><br><img src="http://pic.colliexyy.com/16456798257437.jpg"><br><img src="http://pic.colliexyy.com/16456798319556.jpg"></li>
<li>在 bytes 包的源代码里，为 Buffer 类型声明的 Write 方法<br><img src="http://pic.colliexyy.com/16456798492658.jpg"></li>
<li>os 包的源代码里，为 File 类型声明的 Write 方法<br><img src="http://pic.colliexyy.com/16456798555094.jpg"></li>
<li>应该花时间看一下标准库中提供了些什么，以及它是如何实现的——不仅要防止重新造轮子，还要理解 Go 语言的设计者的习惯，并将这些习惯应用到自己的包和 API 的设计上。</li>
</ul>
<h2 id="本章小结-7"><a href="#本章小结-7" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>标准库有特殊的保证，并且被社区广泛应用。</li>
<li>使用标准库的包会让你的代码更易于管理，别人也会更信任你的代码。</li>
<li>100 余个包被合理组织，分布在 38 个类别里。</li>
<li>标准库里的 log 包拥有记录日志所需的一切功能。</li>
<li>标准库里的 xml 和 json 包让处理这两种数据格式变得很简单。</li>
<li>io 包支持以流的方式高效处理数据。</li>
<li>接口允许你的代码组合已有的功能。</li>
<li><strong>阅读标准库的代码是熟悉 Go 语言习惯的好方法。</strong></li>
</ul>
<h1 id="第-9-章：测试和性能"><a href="#第-9-章：测试和性能" class="headerlink" title="第 9 章：测试和性能"></a>第 9 章：测试和性能</h1><h2 id="本章主要内容-8"><a href="#本章主要内容-8" class="headerlink" title="本章主要内容"></a>本章主要内容</h2><ul>
<li>编写单元测试来验证代码的正确性</li>
<li>使用 httptest 来模拟基于 HTTP 的请求和响应</li>
<li>使用示例代码来给包写文档</li>
<li>通过基准测试来检查性能</li>
<li><strong>作为一名合格的开发者，不应该在程序开发完之后才开始写测试代码。</strong></li>
<li>使用 Go 语言的测试框架，可以在开发的过程中就进行单元测试和基准测试。</li>
<li>和 go build 命令类似，go test 命令可以用来执行写好的测试代码，需要做的就是遵守一些规则来写测试。而且，可以将测试无缝地集成到代码工程和持续集成系统里。</li>
</ul>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ul>
<li>单元测试是用来测试包或者程序的一部分代码或者一组代码的函数。</li>
<li>一个场景是正向路经测试，就是在正常执行的情况下，保证代码不产生错误的测试。</li>
<li>一些单元测试可能会测试负向路径的场景，保证代码不仅会产生错误，而且是预期的错误。</li>
<li>基础测试（basic test）只使用一组参数和结果来测试一段代码。</li>
<li>表组测试（table test）也会测试一段代码，但是会使用多组参数和结果进行测试。</li>
<li>使用一些方法来模仿（mock）测试代码需要使用到的外部资源，如数据库或者网络服务器。</li>
</ul>
<h2 id="基础测试"><a href="#基础测试" class="headerlink" title="基础测试"></a>基础测试</h2><ul>
<li>调用 go test -v 来运行这个测试（-v 表示提供冗余输出）。</li>
<li>Go 语言的测试工具只会认为<strong>以 <code>_test.go</code> 结尾的文件是测试文件</strong>。</li>
<li>testing 包提供了从测试框架到报告测试的输出和状态的各种测试功能的支持。<br><img src="http://pic.colliexyy.com/16450993159728.jpg"></li>
<li>第 09 行和第 10 行声明了两个常量，这两个常量包含写测试输出时会用到的对号（√）和叉号（×）</li>
<li>一个测试函数必须是公开的函数，并且<strong>以 Test 单词开头</strong>。不但函数名字要以 Test 开头，而且<strong>函数的签名必须接收一个指向 testing.T 类型的指针，并且不返回任何值</strong>。</li>
<li>测试的输出需使用完整易读的语句，来记录为什么需要这个测试，具体测试了什么，以及测试的结果是什么。</li>
<li>使用方法 t.Log 来输出测试的消息。这个方法还有一个名为 t.Logf 的版本，可以格式化消息。</li>
<li><strong>如果执行 go test 的时候没有加入冗余选项（-v），除非测试失败，否则我们是看不到任何测试输出的。</strong></li>
<li>每个测试函数都应该通过解释这个测试的给定要求（given need），来说明为什么应该存在这个测试。</li>
<li>特别说明了要测试的值。</li>
<li>在每种情况下，我们都会说明测试应有的结果。如果调用失败，除了结果，还会输出叉号以及得到的错误值。如果测试成功，会输出对号。</li>
<li>t.Fatal 方法不但报告这个单元测试已经失败，而且会向测试输出写一些消息，而后<strong>立刻停止这个测试函数的执行</strong>。如果除了这个函数外还有其他没有执行的测试函数，会继续执行其他测试函数。这个方法对应的格式化版本名为 t.Fatalf。</li>
<li>如果需要报告测试失败，但是<strong>并不想停止当前测试函数的执行</strong>，可以使用 t.Error 系列方法</li>
</ul>
<h2 id="表组测试"><a href="#表组测试" class="headerlink" title="表组测试"></a>表组测试</h2><ul>
<li>表组测试除了会有一组不同的输入值和期望结果之外，其余部分都很像基础单元测试。</li>
</ul>
<h2 id="模仿调用"><a href="#模仿调用" class="headerlink" title="模仿调用"></a>模仿调用</h2><ul>
<li>依赖不属于你的或者你无法操作的服务来进行测试，也不是一个好习惯。这两点会严重影响测试持续集成和部署的自动化。</li>
<li>httptest 的包让开发人员可以模仿基于 HTTP 的网络调用。</li>
<li>模仿（mocking）是一个很常用的技术手段，用来在运行测试时模拟访问不可用的资源。包 httptest 可以让你能够模仿互联网资源的请求和响应。</li>
<li>httptest.Server 的值是整个模仿服务的关键。</li>
<li>HandlerFunc 类型是一个适配器，允许常规函数作为 HTTP 的处理函数使用。<br><img src="http://pic.colliexyy.com/16450994882616.jpg"></li>
<li>当我们使用由模仿服务器提供的 URL 时，http.Get 调用依旧会按我们预期的方式运行。http.Get 方法调用时并不知道我们的调用是否经过互联网。</li>
<li>如果仔细看用于调用的 URL，会发现这个 URL 使用了 localhost 作为地址，端口是 52065。这个端口号每次运行测试时都会改变。</li>
</ul>
<h2 id="测试服务端点"><a href="#测试服务端点" class="headerlink" title="测试服务端点"></a>测试服务端点</h2><ul>
<li>服务端点（endpoint）是指与服务宿主信息无关，用来分辨某个服务的地址，一般是不包含宿主的一个路径。</li>
<li>如果在构造网络 API，你会希望直接测试自己的服务的所有服务端点，而不用启动整个网络服务。</li>
<li>handlers_test 包的名字也使用<code>_test</code>结尾。<strong>如果包使用这种方式命名，测试代码只能访问包里公开的标识符。</strong> 即便测试代码文件和被测试的代码放在同一个文件夹中，也只能访问公开的标识符。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul>
<li>Go 语言很重视给代码编写合适的文档。专门内置了 godoc 工具来从代码直接生成文档。这个工具的另一个特性是示例代码。</li>
<li>开发人员可以创建自己的示例，并且在包的 Go 文档里展示。</li>
<li><strong>示例基于已经存在的函数或者方法。我们需要使用 Example 作为函数名的开始。</strong></li>
<li><strong>示例代码的函数名字必须基于已经存在的公开的函数或者方法。</strong></li>
<li>写示例代码的目的是展示某个函数或者方法的特定使用方法。</li>
<li><strong>这个<code>Output:</code>标记用来在文档中标记出示例函数运行后期望的输出。</strong></li>
<li>Go 的测试框架知道如何比较注释里的期望输出和标准输出的最终输出。如果两者匹配，这个示例作为测试就会通过，并加入到包的 Go 文档里。如果输出不匹配，这个示例作为测试就会失败。</li>
<li>示例的一组完整文档，包括代码和期望的输出。</li>
<li>由于这个示例也是测试的一部分，可以使用 go test 工具来运行这个示例函数。</li>
<li>运行测试时，使用<code>-run</code>选项指定了特定的函数。<code>-run</code> 选项接受任意的正则表达式，来指定要运行的测试函数。这个选项既支持单元测试，也支持示例函数。</li>
</ul>
<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><ul>
<li>基准测试是一种测试代码性能的方法。</li>
<li>想要测试解决同一问题的不同方案的性能，以及查看哪种解决方案的性能更好时，基准测试就会很有用。</li>
<li>基准测试也可以用来识别某段代码的 CPU 或者内存效率问题，而这段代码的效率可能会严重影响整个应用程序的性能。</li>
<li>许多开发人员会用基准测试来测试不同的并发模式，或者用基准测试来辅助配置工作池的数量，以保证能最大化系统的吞吐量。</li>
<li>基准测试的文件名也必须以<code>_test.go</code>结尾。同时也必须导入 testing 包。</li>
<li><strong>基准测试函数必须以 Benchmark 开头，接受一个指向 testing.B 类型的指针作为唯一参数。</strong></li>
<li><strong>基准测试框架默认会在持续 1 * 秒的时间内，反复调用需要测试的函数。</strong></li>
<li><strong>测试框架每次调用测试函数时，都会增加 b.N 的值。</strong></li>
<li>第一次调用时，b.N 的值为 1。需要注意，一定要将所有要进行基准测试的代码都放到循环里，并且循环要使用 b.N 的值。否则，测试的结果是不可靠的。</li>
<li>如果我们只希望运行基准测试函数，需要加入-bench 选项。<code>go test -v -run=&quot;none&quot; -bench=&quot;BenchmarkSprintf&quot;</code></li>
<li><strong>给<code>-run</code>选项传递了字符串”none”，来保证在运行制订的基准测试函数之前没有单元测试会被运行。</strong></li>
<li><strong>默认情况下，基准测试的最小运行时间是 1 秒。如果想让运行时间更长，可以使用另一个名为<code>-benchtime</code>的选项来更改测试执行的最短时间。</strong></li>
<li><strong>对大多数测试来说，超过 3 秒的基准测试并不会改变测试的精确度。</strong></li>
<li>在代码开始执行循环之前需要进行初始化时，b.ResetTimer 方法用来重置计时器，保证测试代码执行前的初始化代码，不会干扰计时器的结果。</li>
<li><strong>运行基准测试时，另一个很有用的选项是-benchmem 选项。这个选项可以提供每次操作分配内存的次数，以及总共分配内存的字节数。</strong></li>
<li><strong>单位为 allocs&#x2F;op 的值表示每次操作从堆上分配内存的次数。</strong></li>
<li><strong>单位为 B&#x2F;op 的值表示每次操作分配的字节数。</strong></li>
</ul>
<h2 id="本章小结-8"><a href="#本章小结-8" class="headerlink" title="本章小结"></a>本章小结</h2><ul>
<li>测试功能被内置到 Go 语言中，Go 语言提供了必要的测试工具。</li>
<li>go test 工具用来运行测试。</li>
<li>测试文件总是以_test.go 作为文件名的结尾。</li>
<li>表组测试是利用一个测试函数测试多组值的好办法。</li>
<li>包中的示例代码，既能用于测试，也能用于文档。</li>
<li>基准测试提供了探查代码性能的机制。</li>
</ul>

    </div>

    
    
    
      


    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="Collie 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Collie 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Collie
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://collie2nd.github.io/2022/04/20/backend_dev/goinaction/" title="《Go in Action》读书笔记">http://collie2nd.github.io/2022/04/20/backend_dev/goinaction/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://twitter.com/LIUVOUS">
          <span class="icon">
            <i class="fab fa-twitter"></i>
          </span>

          <span class="label">Twitter</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="/images/t_me.jpg">
          <span class="icon">
            <i class="fab fa-telegram"></i>
          </span>

          <span class="label">Telegram</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
          <span class="icon">
            <i class="fab fa-weixin"></i>
          </span>

          <span class="label">WeChat</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/read/" rel="tag"><i class="fa fa-tag"></i> read</a>
              <a href="/tags/golang/" rel="tag"><i class="fa fa-tag"></i> golang</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/03/16/backend_dev/Go%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" rel="prev" title="《Go 并发编程实战》读书笔记">
                  <i class="fa fa-chevron-left"></i> 《Go 并发编程实战》读书笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/05/30/backend_dev/golang_excel/" rel="next" title="Go 操作 Excel 总结">
                  Go 操作 Excel 总结 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Collie</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">242k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:40</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>




  




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"comment.colliexyy.com","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"ヾﾉ≧∀≦)o来啊，快活啊!","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":["nick"],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2022/04/20/backend_dev/goinaction/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
